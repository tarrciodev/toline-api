
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Toliner
 * 
 */
export type Toliner = $Result.DefaultSelection<Prisma.$TolinerPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectSubscription
 * 
 */
export type ProjectSubscription = $Result.DefaultSelection<Prisma.$ProjectSubscriptionPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Subcategory
 * 
 */
export type Subcategory = $Result.DefaultSelection<Prisma.$SubcategoryPayload>
/**
 * Model FreelancerEvaluation
 * 
 */
export type FreelancerEvaluation = $Result.DefaultSelection<Prisma.$FreelancerEvaluationPayload>
/**
 * Model Quotation
 * 
 */
export type Quotation = $Result.DefaultSelection<Prisma.$QuotationPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Portifolio
 * 
 */
export type Portifolio = $Result.DefaultSelection<Prisma.$PortifolioPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Charge
 * 
 */
export type Charge = $Result.DefaultSelection<Prisma.$ChargePayload>
/**
 * Model Balance
 * 
 */
export type Balance = $Result.DefaultSelection<Prisma.$BalancePayload>
/**
 * Model VerificationCode
 * 
 */
export type VerificationCode = $Result.DefaultSelection<Prisma.$VerificationCodePayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model CertificationTest
 * 
 */
export type CertificationTest = $Result.DefaultSelection<Prisma.$CertificationTestPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Alternative
 * 
 */
export type Alternative = $Result.DefaultSelection<Prisma.$AlternativePayload>
/**
 * Model TestAttempt
 * 
 */
export type TestAttempt = $Result.DefaultSelection<Prisma.$TestAttemptPayload>
/**
 * Model Answer
 * 
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProjectStatus: {
  created: 'created',
  onGoing: 'onGoing',
  completed: 'completed'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const PaymentStatus: {
  pending: 'pending',
  resolved: 'resolved',
  rejected: 'rejected'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const ChargeStatus: {
  pending: 'pending',
  resolved: 'resolved',
  rejected: 'rejected'
};

export type ChargeStatus = (typeof ChargeStatus)[keyof typeof ChargeStatus]

}

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type ChargeStatus = $Enums.ChargeStatus

export const ChargeStatus: typeof $Enums.ChargeStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Toliners
 * const toliners = await prisma.toliner.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Toliners
   * const toliners = await prisma.toliner.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.toliner`: Exposes CRUD operations for the **Toliner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Toliners
    * const toliners = await prisma.toliner.findMany()
    * ```
    */
  get toliner(): Prisma.TolinerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectSubscription`: Exposes CRUD operations for the **ProjectSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectSubscriptions
    * const projectSubscriptions = await prisma.projectSubscription.findMany()
    * ```
    */
  get projectSubscription(): Prisma.ProjectSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subcategory`: Exposes CRUD operations for the **Subcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subcategories
    * const subcategories = await prisma.subcategory.findMany()
    * ```
    */
  get subcategory(): Prisma.SubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelancerEvaluation`: Exposes CRUD operations for the **FreelancerEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelancerEvaluations
    * const freelancerEvaluations = await prisma.freelancerEvaluation.findMany()
    * ```
    */
  get freelancerEvaluation(): Prisma.FreelancerEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotation`: Exposes CRUD operations for the **Quotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotations
    * const quotations = await prisma.quotation.findMany()
    * ```
    */
  get quotation(): Prisma.QuotationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portifolio`: Exposes CRUD operations for the **Portifolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Portifolios
    * const portifolios = await prisma.portifolio.findMany()
    * ```
    */
  get portifolio(): Prisma.PortifolioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.charge`: Exposes CRUD operations for the **Charge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Charges
    * const charges = await prisma.charge.findMany()
    * ```
    */
  get charge(): Prisma.ChargeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balance`: Exposes CRUD operations for the **Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balance.findMany()
    * ```
    */
  get balance(): Prisma.BalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationCode`: Exposes CRUD operations for the **VerificationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationCodes
    * const verificationCodes = await prisma.verificationCode.findMany()
    * ```
    */
  get verificationCode(): Prisma.VerificationCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificationTest`: Exposes CRUD operations for the **CertificationTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CertificationTests
    * const certificationTests = await prisma.certificationTest.findMany()
    * ```
    */
  get certificationTest(): Prisma.CertificationTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alternative`: Exposes CRUD operations for the **Alternative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alternatives
    * const alternatives = await prisma.alternative.findMany()
    * ```
    */
  get alternative(): Prisma.AlternativeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testAttempt`: Exposes CRUD operations for the **TestAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestAttempts
    * const testAttempts = await prisma.testAttempt.findMany()
    * ```
    */
  get testAttempt(): Prisma.TestAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Toliner: 'Toliner',
    User: 'User',
    Project: 'Project',
    ProjectSubscription: 'ProjectSubscription',
    Category: 'Category',
    Subcategory: 'Subcategory',
    FreelancerEvaluation: 'FreelancerEvaluation',
    Quotation: 'Quotation',
    Conversation: 'Conversation',
    Message: 'Message',
    Portifolio: 'Portifolio',
    Payment: 'Payment',
    Charge: 'Charge',
    Balance: 'Balance',
    VerificationCode: 'VerificationCode',
    Skill: 'Skill',
    CertificationTest: 'CertificationTest',
    Question: 'Question',
    Alternative: 'Alternative',
    TestAttempt: 'TestAttempt',
    Answer: 'Answer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "toliner" | "user" | "project" | "projectSubscription" | "category" | "subcategory" | "freelancerEvaluation" | "quotation" | "conversation" | "message" | "portifolio" | "payment" | "charge" | "balance" | "verificationCode" | "skill" | "certificationTest" | "question" | "alternative" | "testAttempt" | "answer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Toliner: {
        payload: Prisma.$TolinerPayload<ExtArgs>
        fields: Prisma.TolinerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TolinerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TolinerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>
          }
          findFirst: {
            args: Prisma.TolinerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TolinerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>
          }
          findMany: {
            args: Prisma.TolinerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>[]
          }
          create: {
            args: Prisma.TolinerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>
          }
          createMany: {
            args: Prisma.TolinerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TolinerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>[]
          }
          delete: {
            args: Prisma.TolinerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>
          }
          update: {
            args: Prisma.TolinerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>
          }
          deleteMany: {
            args: Prisma.TolinerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TolinerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TolinerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>[]
          }
          upsert: {
            args: Prisma.TolinerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TolinerPayload>
          }
          aggregate: {
            args: Prisma.TolinerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToliner>
          }
          groupBy: {
            args: Prisma.TolinerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TolinerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TolinerCountArgs<ExtArgs>
            result: $Utils.Optional<TolinerCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectSubscription: {
        payload: Prisma.$ProjectSubscriptionPayload<ExtArgs>
        fields: Prisma.ProjectSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.ProjectSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>
          }
          findMany: {
            args: Prisma.ProjectSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>[]
          }
          create: {
            args: Prisma.ProjectSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>
          }
          createMany: {
            args: Prisma.ProjectSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.ProjectSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>
          }
          update: {
            args: Prisma.ProjectSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.ProjectSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.ProjectSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.ProjectSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectSubscription>
          }
          groupBy: {
            args: Prisma.ProjectSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Subcategory: {
        payload: Prisma.$SubcategoryPayload<ExtArgs>
        fields: Prisma.SubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findFirst: {
            args: Prisma.SubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findMany: {
            args: Prisma.SubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          create: {
            args: Prisma.SubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          createMany: {
            args: Prisma.SubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          delete: {
            args: Prisma.SubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          update: {
            args: Prisma.SubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.SubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          aggregate: {
            args: Prisma.SubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubcategory>
          }
          groupBy: {
            args: Prisma.SubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryCountAggregateOutputType> | number
          }
        }
      }
      FreelancerEvaluation: {
        payload: Prisma.$FreelancerEvaluationPayload<ExtArgs>
        fields: Prisma.FreelancerEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelancerEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelancerEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>
          }
          findFirst: {
            args: Prisma.FreelancerEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelancerEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>
          }
          findMany: {
            args: Prisma.FreelancerEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>[]
          }
          create: {
            args: Prisma.FreelancerEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>
          }
          createMany: {
            args: Prisma.FreelancerEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelancerEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>[]
          }
          delete: {
            args: Prisma.FreelancerEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>
          }
          update: {
            args: Prisma.FreelancerEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.FreelancerEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelancerEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreelancerEvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>[]
          }
          upsert: {
            args: Prisma.FreelancerEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelancerEvaluationPayload>
          }
          aggregate: {
            args: Prisma.FreelancerEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelancerEvaluation>
          }
          groupBy: {
            args: Prisma.FreelancerEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelancerEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelancerEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<FreelancerEvaluationCountAggregateOutputType> | number
          }
        }
      }
      Quotation: {
        payload: Prisma.$QuotationPayload<ExtArgs>
        fields: Prisma.QuotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findFirst: {
            args: Prisma.QuotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          findMany: {
            args: Prisma.QuotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          create: {
            args: Prisma.QuotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          createMany: {
            args: Prisma.QuotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          delete: {
            args: Prisma.QuotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          update: {
            args: Prisma.QuotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          deleteMany: {
            args: Prisma.QuotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>[]
          }
          upsert: {
            args: Prisma.QuotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotationPayload>
          }
          aggregate: {
            args: Prisma.QuotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotation>
          }
          groupBy: {
            args: Prisma.QuotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotationCountArgs<ExtArgs>
            result: $Utils.Optional<QuotationCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Portifolio: {
        payload: Prisma.$PortifolioPayload<ExtArgs>
        fields: Prisma.PortifolioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortifolioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortifolioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>
          }
          findFirst: {
            args: Prisma.PortifolioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortifolioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>
          }
          findMany: {
            args: Prisma.PortifolioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>[]
          }
          create: {
            args: Prisma.PortifolioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>
          }
          createMany: {
            args: Prisma.PortifolioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortifolioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>[]
          }
          delete: {
            args: Prisma.PortifolioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>
          }
          update: {
            args: Prisma.PortifolioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>
          }
          deleteMany: {
            args: Prisma.PortifolioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortifolioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortifolioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>[]
          }
          upsert: {
            args: Prisma.PortifolioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortifolioPayload>
          }
          aggregate: {
            args: Prisma.PortifolioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortifolio>
          }
          groupBy: {
            args: Prisma.PortifolioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortifolioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortifolioCountArgs<ExtArgs>
            result: $Utils.Optional<PortifolioCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Charge: {
        payload: Prisma.$ChargePayload<ExtArgs>
        fields: Prisma.ChargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          findFirst: {
            args: Prisma.ChargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          findMany: {
            args: Prisma.ChargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>[]
          }
          create: {
            args: Prisma.ChargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          createMany: {
            args: Prisma.ChargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>[]
          }
          delete: {
            args: Prisma.ChargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          update: {
            args: Prisma.ChargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          deleteMany: {
            args: Prisma.ChargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>[]
          }
          upsert: {
            args: Prisma.ChargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChargePayload>
          }
          aggregate: {
            args: Prisma.ChargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharge>
          }
          groupBy: {
            args: Prisma.ChargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChargeCountArgs<ExtArgs>
            result: $Utils.Optional<ChargeCountAggregateOutputType> | number
          }
        }
      }
      Balance: {
        payload: Prisma.$BalancePayload<ExtArgs>
        fields: Prisma.BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findFirst: {
            args: Prisma.BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          findMany: {
            args: Prisma.BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          create: {
            args: Prisma.BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          createMany: {
            args: Prisma.BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          delete: {
            args: Prisma.BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          update: {
            args: Prisma.BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          deleteMany: {
            args: Prisma.BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>[]
          }
          upsert: {
            args: Prisma.BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BalancePayload>
          }
          aggregate: {
            args: Prisma.BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalance>
          }
          groupBy: {
            args: Prisma.BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BalanceCountAggregateOutputType> | number
          }
        }
      }
      VerificationCode: {
        payload: Prisma.$VerificationCodePayload<ExtArgs>
        fields: Prisma.VerificationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findFirst: {
            args: Prisma.VerificationCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          findMany: {
            args: Prisma.VerificationCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          create: {
            args: Prisma.VerificationCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          createMany: {
            args: Prisma.VerificationCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          delete: {
            args: Prisma.VerificationCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          update: {
            args: Prisma.VerificationCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          deleteMany: {
            args: Prisma.VerificationCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>[]
          }
          upsert: {
            args: Prisma.VerificationCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationCodePayload>
          }
          aggregate: {
            args: Prisma.VerificationCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationCode>
          }
          groupBy: {
            args: Prisma.VerificationCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCodeCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCodeCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      CertificationTest: {
        payload: Prisma.$CertificationTestPayload<ExtArgs>
        fields: Prisma.CertificationTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>
          }
          findFirst: {
            args: Prisma.CertificationTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>
          }
          findMany: {
            args: Prisma.CertificationTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>[]
          }
          create: {
            args: Prisma.CertificationTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>
          }
          createMany: {
            args: Prisma.CertificationTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>[]
          }
          delete: {
            args: Prisma.CertificationTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>
          }
          update: {
            args: Prisma.CertificationTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>
          }
          deleteMany: {
            args: Prisma.CertificationTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificationTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>[]
          }
          upsert: {
            args: Prisma.CertificationTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationTestPayload>
          }
          aggregate: {
            args: Prisma.CertificationTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificationTest>
          }
          groupBy: {
            args: Prisma.CertificationTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationTestCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationTestCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Alternative: {
        payload: Prisma.$AlternativePayload<ExtArgs>
        fields: Prisma.AlternativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlternativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlternativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          findFirst: {
            args: Prisma.AlternativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlternativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          findMany: {
            args: Prisma.AlternativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>[]
          }
          create: {
            args: Prisma.AlternativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          createMany: {
            args: Prisma.AlternativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlternativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>[]
          }
          delete: {
            args: Prisma.AlternativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          update: {
            args: Prisma.AlternativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          deleteMany: {
            args: Prisma.AlternativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlternativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlternativeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>[]
          }
          upsert: {
            args: Prisma.AlternativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlternativePayload>
          }
          aggregate: {
            args: Prisma.AlternativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlternative>
          }
          groupBy: {
            args: Prisma.AlternativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlternativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlternativeCountArgs<ExtArgs>
            result: $Utils.Optional<AlternativeCountAggregateOutputType> | number
          }
        }
      }
      TestAttempt: {
        payload: Prisma.$TestAttemptPayload<ExtArgs>
        fields: Prisma.TestAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>
          }
          findFirst: {
            args: Prisma.TestAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>
          }
          findMany: {
            args: Prisma.TestAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>[]
          }
          create: {
            args: Prisma.TestAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>
          }
          createMany: {
            args: Prisma.TestAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>[]
          }
          delete: {
            args: Prisma.TestAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>
          }
          update: {
            args: Prisma.TestAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>
          }
          deleteMany: {
            args: Prisma.TestAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>[]
          }
          upsert: {
            args: Prisma.TestAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestAttemptPayload>
          }
          aggregate: {
            args: Prisma.TestAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestAttempt>
          }
          groupBy: {
            args: Prisma.TestAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<TestAttemptCountAggregateOutputType> | number
          }
        }
      }
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>
        fields: Prisma.AnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer>
          }
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    toliner?: TolinerOmit
    user?: UserOmit
    project?: ProjectOmit
    projectSubscription?: ProjectSubscriptionOmit
    category?: CategoryOmit
    subcategory?: SubcategoryOmit
    freelancerEvaluation?: FreelancerEvaluationOmit
    quotation?: QuotationOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    portifolio?: PortifolioOmit
    payment?: PaymentOmit
    charge?: ChargeOmit
    balance?: BalanceOmit
    verificationCode?: VerificationCodeOmit
    skill?: SkillOmit
    certificationTest?: CertificationTestOmit
    question?: QuestionOmit
    alternative?: AlternativeOmit
    testAttempt?: TestAttemptOmit
    answer?: AnswerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TolinerCountOutputType
   */

  export type TolinerCountOutputType = {
    projectsOwned: number
    projectsFreelanced: number
    subscriptions: number
    specialization: number
    portifolio: number
    freelancerEvaluation: number
    charges: number
    payments: number
    freelancerPayments: number
  }

  export type TolinerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectsOwned?: boolean | TolinerCountOutputTypeCountProjectsOwnedArgs
    projectsFreelanced?: boolean | TolinerCountOutputTypeCountProjectsFreelancedArgs
    subscriptions?: boolean | TolinerCountOutputTypeCountSubscriptionsArgs
    specialization?: boolean | TolinerCountOutputTypeCountSpecializationArgs
    portifolio?: boolean | TolinerCountOutputTypeCountPortifolioArgs
    freelancerEvaluation?: boolean | TolinerCountOutputTypeCountFreelancerEvaluationArgs
    charges?: boolean | TolinerCountOutputTypeCountChargesArgs
    payments?: boolean | TolinerCountOutputTypeCountPaymentsArgs
    freelancerPayments?: boolean | TolinerCountOutputTypeCountFreelancerPaymentsArgs
  }

  // Custom InputTypes
  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TolinerCountOutputType
     */
    select?: TolinerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountProjectsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountProjectsFreelancedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSubscriptionWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountSpecializationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountPortifolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortifolioWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountFreelancerEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelancerEvaluationWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountChargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChargeWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TolinerCountOutputType without action
   */
  export type TolinerCountOutputTypeCountFreelancerPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    conversations: number
    skills: number
    TestAttempt: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    skills?: boolean | UserCountOutputTypeCountSkillsArgs
    TestAttempt?: boolean | UserCountOutputTypeCountTestAttemptArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAttemptWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    subscriptions: number
    skills: number
    conversations: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscriptions?: boolean | ProjectCountOutputTypeCountSubscriptionsArgs
    skills?: boolean | ProjectCountOutputTypeCountSkillsArgs
    conversations?: boolean | ProjectCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSubscriptionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    skills: number
    toliners: number
    subcategories: number
    projects: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CategoryCountOutputTypeCountSkillsArgs
    toliners?: boolean | CategoryCountOutputTypeCountTolinersArgs
    subcategories?: boolean | CategoryCountOutputTypeCountSubcategoriesArgs
    projects?: boolean | CategoryCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountTolinersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TolinerWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    members: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ConversationCountOutputTypeCountMembersArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type PortifolioCountOutputType
   */

  export type PortifolioCountOutputType = {
    skills: number
  }

  export type PortifolioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | PortifolioCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * PortifolioCountOutputType without action
   */
  export type PortifolioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortifolioCountOutputType
     */
    select?: PortifolioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortifolioCountOutputType without action
   */
  export type PortifolioCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    users: number
    portifolios: number
    projects: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | SkillCountOutputTypeCountUsersArgs
    portifolios?: boolean | SkillCountOutputTypeCountPortifoliosArgs
    projects?: boolean | SkillCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountPortifoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortifolioWhereInput
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }


  /**
   * Count Type CertificationTestCountOutputType
   */

  export type CertificationTestCountOutputType = {
    questions: number
    attempts: number
  }

  export type CertificationTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | CertificationTestCountOutputTypeCountQuestionsArgs
    attempts?: boolean | CertificationTestCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * CertificationTestCountOutputType without action
   */
  export type CertificationTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTestCountOutputType
     */
    select?: CertificationTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CertificationTestCountOutputType without action
   */
  export type CertificationTestCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * CertificationTestCountOutputType without action
   */
  export type CertificationTestCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAttemptWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    alternatives: number
    answers: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alternatives?: boolean | QuestionCountOutputTypeCountAlternativesArgs
    answers?: boolean | QuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAlternativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternativeWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }


  /**
   * Count Type AlternativeCountOutputType
   */

  export type AlternativeCountOutputType = {
    answers: number
  }

  export type AlternativeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | AlternativeCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * AlternativeCountOutputType without action
   */
  export type AlternativeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlternativeCountOutputType
     */
    select?: AlternativeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlternativeCountOutputType without action
   */
  export type AlternativeCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }


  /**
   * Count Type TestAttemptCountOutputType
   */

  export type TestAttemptCountOutputType = {
    answers: number
  }

  export type TestAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | TestAttemptCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * TestAttemptCountOutputType without action
   */
  export type TestAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttemptCountOutputType
     */
    select?: TestAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestAttemptCountOutputType without action
   */
  export type TestAttemptCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Toliner
   */

  export type AggregateToliner = {
    _count: TolinerCountAggregateOutputType | null
    _avg: TolinerAvgAggregateOutputType | null
    _sum: TolinerSumAggregateOutputType | null
    _min: TolinerMinAggregateOutputType | null
    _max: TolinerMaxAggregateOutputType | null
  }

  export type TolinerAvgAggregateOutputType = {
    gainPerOurs: number | null
  }

  export type TolinerSumAggregateOutputType = {
    gainPerOurs: number | null
  }

  export type TolinerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    jobDescription: string | null
    isVerified: boolean | null
    createdAt: Date | null
    isSuspended: boolean | null
    isActive: boolean | null
    hasCompletedProfile: boolean | null
    hasAprovedProfile: boolean | null
    gainPerOurs: number | null
    nacionality: string | null
  }

  export type TolinerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    jobDescription: string | null
    isVerified: boolean | null
    createdAt: Date | null
    isSuspended: boolean | null
    isActive: boolean | null
    hasCompletedProfile: boolean | null
    hasAprovedProfile: boolean | null
    gainPerOurs: number | null
    nacionality: string | null
  }

  export type TolinerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    jobDescription: number
    isVerified: number
    createdAt: number
    bankAccount: number
    identification: number
    isSuspended: number
    isActive: number
    hasCompletedProfile: number
    hasAprovedProfile: number
    gainPerOurs: number
    nacionality: number
    _all: number
  }


  export type TolinerAvgAggregateInputType = {
    gainPerOurs?: true
  }

  export type TolinerSumAggregateInputType = {
    gainPerOurs?: true
  }

  export type TolinerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    jobDescription?: true
    isVerified?: true
    createdAt?: true
    isSuspended?: true
    isActive?: true
    hasCompletedProfile?: true
    hasAprovedProfile?: true
    gainPerOurs?: true
    nacionality?: true
  }

  export type TolinerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    jobDescription?: true
    isVerified?: true
    createdAt?: true
    isSuspended?: true
    isActive?: true
    hasCompletedProfile?: true
    hasAprovedProfile?: true
    gainPerOurs?: true
    nacionality?: true
  }

  export type TolinerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    jobDescription?: true
    isVerified?: true
    createdAt?: true
    bankAccount?: true
    identification?: true
    isSuspended?: true
    isActive?: true
    hasCompletedProfile?: true
    hasAprovedProfile?: true
    gainPerOurs?: true
    nacionality?: true
    _all?: true
  }

  export type TolinerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Toliner to aggregate.
     */
    where?: TolinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Toliners to fetch.
     */
    orderBy?: TolinerOrderByWithRelationInput | TolinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TolinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Toliners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Toliners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Toliners
    **/
    _count?: true | TolinerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TolinerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TolinerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TolinerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TolinerMaxAggregateInputType
  }

  export type GetTolinerAggregateType<T extends TolinerAggregateArgs> = {
        [P in keyof T & keyof AggregateToliner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToliner[P]>
      : GetScalarType<T[P], AggregateToliner[P]>
  }




  export type TolinerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TolinerWhereInput
    orderBy?: TolinerOrderByWithAggregationInput | TolinerOrderByWithAggregationInput[]
    by: TolinerScalarFieldEnum[] | TolinerScalarFieldEnum
    having?: TolinerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TolinerCountAggregateInputType | true
    _avg?: TolinerAvgAggregateInputType
    _sum?: TolinerSumAggregateInputType
    _min?: TolinerMinAggregateInputType
    _max?: TolinerMaxAggregateInputType
  }

  export type TolinerGroupByOutputType = {
    id: string
    name: string
    email: string
    jobDescription: string | null
    isVerified: boolean
    createdAt: Date
    bankAccount: JsonValue | null
    identification: JsonValue | null
    isSuspended: boolean
    isActive: boolean
    hasCompletedProfile: boolean
    hasAprovedProfile: boolean
    gainPerOurs: number | null
    nacionality: string | null
    _count: TolinerCountAggregateOutputType | null
    _avg: TolinerAvgAggregateOutputType | null
    _sum: TolinerSumAggregateOutputType | null
    _min: TolinerMinAggregateOutputType | null
    _max: TolinerMaxAggregateOutputType | null
  }

  type GetTolinerGroupByPayload<T extends TolinerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TolinerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TolinerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TolinerGroupByOutputType[P]>
            : GetScalarType<T[P], TolinerGroupByOutputType[P]>
        }
      >
    >


  export type TolinerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    jobDescription?: boolean
    isVerified?: boolean
    createdAt?: boolean
    bankAccount?: boolean
    identification?: boolean
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: boolean
    nacionality?: boolean
    projectsOwned?: boolean | Toliner$projectsOwnedArgs<ExtArgs>
    projectsFreelanced?: boolean | Toliner$projectsFreelancedArgs<ExtArgs>
    subscriptions?: boolean | Toliner$subscriptionsArgs<ExtArgs>
    specialization?: boolean | Toliner$specializationArgs<ExtArgs>
    portifolio?: boolean | Toliner$portifolioArgs<ExtArgs>
    freelancerEvaluation?: boolean | Toliner$freelancerEvaluationArgs<ExtArgs>
    user?: boolean | Toliner$userArgs<ExtArgs>
    charges?: boolean | Toliner$chargesArgs<ExtArgs>
    balance?: boolean | Toliner$balanceArgs<ExtArgs>
    payments?: boolean | Toliner$paymentsArgs<ExtArgs>
    freelancerPayments?: boolean | Toliner$freelancerPaymentsArgs<ExtArgs>
    _count?: boolean | TolinerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["toliner"]>

  export type TolinerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    jobDescription?: boolean
    isVerified?: boolean
    createdAt?: boolean
    bankAccount?: boolean
    identification?: boolean
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: boolean
    nacionality?: boolean
  }, ExtArgs["result"]["toliner"]>

  export type TolinerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    jobDescription?: boolean
    isVerified?: boolean
    createdAt?: boolean
    bankAccount?: boolean
    identification?: boolean
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: boolean
    nacionality?: boolean
  }, ExtArgs["result"]["toliner"]>

  export type TolinerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    jobDescription?: boolean
    isVerified?: boolean
    createdAt?: boolean
    bankAccount?: boolean
    identification?: boolean
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: boolean
    nacionality?: boolean
  }

  export type TolinerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "jobDescription" | "isVerified" | "createdAt" | "bankAccount" | "identification" | "isSuspended" | "isActive" | "hasCompletedProfile" | "hasAprovedProfile" | "gainPerOurs" | "nacionality", ExtArgs["result"]["toliner"]>
  export type TolinerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectsOwned?: boolean | Toliner$projectsOwnedArgs<ExtArgs>
    projectsFreelanced?: boolean | Toliner$projectsFreelancedArgs<ExtArgs>
    subscriptions?: boolean | Toliner$subscriptionsArgs<ExtArgs>
    specialization?: boolean | Toliner$specializationArgs<ExtArgs>
    portifolio?: boolean | Toliner$portifolioArgs<ExtArgs>
    freelancerEvaluation?: boolean | Toliner$freelancerEvaluationArgs<ExtArgs>
    user?: boolean | Toliner$userArgs<ExtArgs>
    charges?: boolean | Toliner$chargesArgs<ExtArgs>
    balance?: boolean | Toliner$balanceArgs<ExtArgs>
    payments?: boolean | Toliner$paymentsArgs<ExtArgs>
    freelancerPayments?: boolean | Toliner$freelancerPaymentsArgs<ExtArgs>
    _count?: boolean | TolinerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TolinerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TolinerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TolinerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Toliner"
    objects: {
      projectsOwned: Prisma.$ProjectPayload<ExtArgs>[]
      projectsFreelanced: Prisma.$ProjectPayload<ExtArgs>[]
      subscriptions: Prisma.$ProjectSubscriptionPayload<ExtArgs>[]
      specialization: Prisma.$CategoryPayload<ExtArgs>[]
      portifolio: Prisma.$PortifolioPayload<ExtArgs>[]
      freelancerEvaluation: Prisma.$FreelancerEvaluationPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      charges: Prisma.$ChargePayload<ExtArgs>[]
      balance: Prisma.$BalancePayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      freelancerPayments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      jobDescription: string | null
      isVerified: boolean
      createdAt: Date
      bankAccount: Prisma.JsonValue | null
      identification: Prisma.JsonValue | null
      isSuspended: boolean
      isActive: boolean
      hasCompletedProfile: boolean
      hasAprovedProfile: boolean
      gainPerOurs: number | null
      nacionality: string | null
    }, ExtArgs["result"]["toliner"]>
    composites: {}
  }

  type TolinerGetPayload<S extends boolean | null | undefined | TolinerDefaultArgs> = $Result.GetResult<Prisma.$TolinerPayload, S>

  type TolinerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TolinerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TolinerCountAggregateInputType | true
    }

  export interface TolinerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Toliner'], meta: { name: 'Toliner' } }
    /**
     * Find zero or one Toliner that matches the filter.
     * @param {TolinerFindUniqueArgs} args - Arguments to find a Toliner
     * @example
     * // Get one Toliner
     * const toliner = await prisma.toliner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TolinerFindUniqueArgs>(args: SelectSubset<T, TolinerFindUniqueArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Toliner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TolinerFindUniqueOrThrowArgs} args - Arguments to find a Toliner
     * @example
     * // Get one Toliner
     * const toliner = await prisma.toliner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TolinerFindUniqueOrThrowArgs>(args: SelectSubset<T, TolinerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Toliner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerFindFirstArgs} args - Arguments to find a Toliner
     * @example
     * // Get one Toliner
     * const toliner = await prisma.toliner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TolinerFindFirstArgs>(args?: SelectSubset<T, TolinerFindFirstArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Toliner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerFindFirstOrThrowArgs} args - Arguments to find a Toliner
     * @example
     * // Get one Toliner
     * const toliner = await prisma.toliner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TolinerFindFirstOrThrowArgs>(args?: SelectSubset<T, TolinerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Toliners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Toliners
     * const toliners = await prisma.toliner.findMany()
     * 
     * // Get first 10 Toliners
     * const toliners = await prisma.toliner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tolinerWithIdOnly = await prisma.toliner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TolinerFindManyArgs>(args?: SelectSubset<T, TolinerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Toliner.
     * @param {TolinerCreateArgs} args - Arguments to create a Toliner.
     * @example
     * // Create one Toliner
     * const Toliner = await prisma.toliner.create({
     *   data: {
     *     // ... data to create a Toliner
     *   }
     * })
     * 
     */
    create<T extends TolinerCreateArgs>(args: SelectSubset<T, TolinerCreateArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Toliners.
     * @param {TolinerCreateManyArgs} args - Arguments to create many Toliners.
     * @example
     * // Create many Toliners
     * const toliner = await prisma.toliner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TolinerCreateManyArgs>(args?: SelectSubset<T, TolinerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Toliners and returns the data saved in the database.
     * @param {TolinerCreateManyAndReturnArgs} args - Arguments to create many Toliners.
     * @example
     * // Create many Toliners
     * const toliner = await prisma.toliner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Toliners and only return the `id`
     * const tolinerWithIdOnly = await prisma.toliner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TolinerCreateManyAndReturnArgs>(args?: SelectSubset<T, TolinerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Toliner.
     * @param {TolinerDeleteArgs} args - Arguments to delete one Toliner.
     * @example
     * // Delete one Toliner
     * const Toliner = await prisma.toliner.delete({
     *   where: {
     *     // ... filter to delete one Toliner
     *   }
     * })
     * 
     */
    delete<T extends TolinerDeleteArgs>(args: SelectSubset<T, TolinerDeleteArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Toliner.
     * @param {TolinerUpdateArgs} args - Arguments to update one Toliner.
     * @example
     * // Update one Toliner
     * const toliner = await prisma.toliner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TolinerUpdateArgs>(args: SelectSubset<T, TolinerUpdateArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Toliners.
     * @param {TolinerDeleteManyArgs} args - Arguments to filter Toliners to delete.
     * @example
     * // Delete a few Toliners
     * const { count } = await prisma.toliner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TolinerDeleteManyArgs>(args?: SelectSubset<T, TolinerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Toliners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Toliners
     * const toliner = await prisma.toliner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TolinerUpdateManyArgs>(args: SelectSubset<T, TolinerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Toliners and returns the data updated in the database.
     * @param {TolinerUpdateManyAndReturnArgs} args - Arguments to update many Toliners.
     * @example
     * // Update many Toliners
     * const toliner = await prisma.toliner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Toliners and only return the `id`
     * const tolinerWithIdOnly = await prisma.toliner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TolinerUpdateManyAndReturnArgs>(args: SelectSubset<T, TolinerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Toliner.
     * @param {TolinerUpsertArgs} args - Arguments to update or create a Toliner.
     * @example
     * // Update or create a Toliner
     * const toliner = await prisma.toliner.upsert({
     *   create: {
     *     // ... data to create a Toliner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Toliner we want to update
     *   }
     * })
     */
    upsert<T extends TolinerUpsertArgs>(args: SelectSubset<T, TolinerUpsertArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Toliners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerCountArgs} args - Arguments to filter Toliners to count.
     * @example
     * // Count the number of Toliners
     * const count = await prisma.toliner.count({
     *   where: {
     *     // ... the filter for the Toliners we want to count
     *   }
     * })
    **/
    count<T extends TolinerCountArgs>(
      args?: Subset<T, TolinerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TolinerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Toliner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TolinerAggregateArgs>(args: Subset<T, TolinerAggregateArgs>): Prisma.PrismaPromise<GetTolinerAggregateType<T>>

    /**
     * Group by Toliner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TolinerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TolinerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TolinerGroupByArgs['orderBy'] }
        : { orderBy?: TolinerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TolinerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTolinerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Toliner model
   */
  readonly fields: TolinerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Toliner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TolinerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectsOwned<T extends Toliner$projectsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$projectsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectsFreelanced<T extends Toliner$projectsFreelancedArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$projectsFreelancedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Toliner$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialization<T extends Toliner$specializationArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$specializationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    portifolio<T extends Toliner$portifolioArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$portifolioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelancerEvaluation<T extends Toliner$freelancerEvaluationArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$freelancerEvaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Toliner$userArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    charges<T extends Toliner$chargesArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$chargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balance<T extends Toliner$balanceArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$balanceArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Toliner$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelancerPayments<T extends Toliner$freelancerPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Toliner$freelancerPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Toliner model
   */
  interface TolinerFieldRefs {
    readonly id: FieldRef<"Toliner", 'String'>
    readonly name: FieldRef<"Toliner", 'String'>
    readonly email: FieldRef<"Toliner", 'String'>
    readonly jobDescription: FieldRef<"Toliner", 'String'>
    readonly isVerified: FieldRef<"Toliner", 'Boolean'>
    readonly createdAt: FieldRef<"Toliner", 'DateTime'>
    readonly bankAccount: FieldRef<"Toliner", 'Json'>
    readonly identification: FieldRef<"Toliner", 'Json'>
    readonly isSuspended: FieldRef<"Toliner", 'Boolean'>
    readonly isActive: FieldRef<"Toliner", 'Boolean'>
    readonly hasCompletedProfile: FieldRef<"Toliner", 'Boolean'>
    readonly hasAprovedProfile: FieldRef<"Toliner", 'Boolean'>
    readonly gainPerOurs: FieldRef<"Toliner", 'Float'>
    readonly nacionality: FieldRef<"Toliner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Toliner findUnique
   */
  export type TolinerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * Filter, which Toliner to fetch.
     */
    where: TolinerWhereUniqueInput
  }

  /**
   * Toliner findUniqueOrThrow
   */
  export type TolinerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * Filter, which Toliner to fetch.
     */
    where: TolinerWhereUniqueInput
  }

  /**
   * Toliner findFirst
   */
  export type TolinerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * Filter, which Toliner to fetch.
     */
    where?: TolinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Toliners to fetch.
     */
    orderBy?: TolinerOrderByWithRelationInput | TolinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Toliners.
     */
    cursor?: TolinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Toliners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Toliners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Toliners.
     */
    distinct?: TolinerScalarFieldEnum | TolinerScalarFieldEnum[]
  }

  /**
   * Toliner findFirstOrThrow
   */
  export type TolinerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * Filter, which Toliner to fetch.
     */
    where?: TolinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Toliners to fetch.
     */
    orderBy?: TolinerOrderByWithRelationInput | TolinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Toliners.
     */
    cursor?: TolinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Toliners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Toliners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Toliners.
     */
    distinct?: TolinerScalarFieldEnum | TolinerScalarFieldEnum[]
  }

  /**
   * Toliner findMany
   */
  export type TolinerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * Filter, which Toliners to fetch.
     */
    where?: TolinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Toliners to fetch.
     */
    orderBy?: TolinerOrderByWithRelationInput | TolinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Toliners.
     */
    cursor?: TolinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Toliners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Toliners.
     */
    skip?: number
    distinct?: TolinerScalarFieldEnum | TolinerScalarFieldEnum[]
  }

  /**
   * Toliner create
   */
  export type TolinerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * The data needed to create a Toliner.
     */
    data: XOR<TolinerCreateInput, TolinerUncheckedCreateInput>
  }

  /**
   * Toliner createMany
   */
  export type TolinerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Toliners.
     */
    data: TolinerCreateManyInput | TolinerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Toliner createManyAndReturn
   */
  export type TolinerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * The data used to create many Toliners.
     */
    data: TolinerCreateManyInput | TolinerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Toliner update
   */
  export type TolinerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * The data needed to update a Toliner.
     */
    data: XOR<TolinerUpdateInput, TolinerUncheckedUpdateInput>
    /**
     * Choose, which Toliner to update.
     */
    where: TolinerWhereUniqueInput
  }

  /**
   * Toliner updateMany
   */
  export type TolinerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Toliners.
     */
    data: XOR<TolinerUpdateManyMutationInput, TolinerUncheckedUpdateManyInput>
    /**
     * Filter which Toliners to update
     */
    where?: TolinerWhereInput
    /**
     * Limit how many Toliners to update.
     */
    limit?: number
  }

  /**
   * Toliner updateManyAndReturn
   */
  export type TolinerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * The data used to update Toliners.
     */
    data: XOR<TolinerUpdateManyMutationInput, TolinerUncheckedUpdateManyInput>
    /**
     * Filter which Toliners to update
     */
    where?: TolinerWhereInput
    /**
     * Limit how many Toliners to update.
     */
    limit?: number
  }

  /**
   * Toliner upsert
   */
  export type TolinerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * The filter to search for the Toliner to update in case it exists.
     */
    where: TolinerWhereUniqueInput
    /**
     * In case the Toliner found by the `where` argument doesn't exist, create a new Toliner with this data.
     */
    create: XOR<TolinerCreateInput, TolinerUncheckedCreateInput>
    /**
     * In case the Toliner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TolinerUpdateInput, TolinerUncheckedUpdateInput>
  }

  /**
   * Toliner delete
   */
  export type TolinerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    /**
     * Filter which Toliner to delete.
     */
    where: TolinerWhereUniqueInput
  }

  /**
   * Toliner deleteMany
   */
  export type TolinerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Toliners to delete
     */
    where?: TolinerWhereInput
    /**
     * Limit how many Toliners to delete.
     */
    limit?: number
  }

  /**
   * Toliner.projectsOwned
   */
  export type Toliner$projectsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Toliner.projectsFreelanced
   */
  export type Toliner$projectsFreelancedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Toliner.subscriptions
   */
  export type Toliner$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    where?: ProjectSubscriptionWhereInput
    orderBy?: ProjectSubscriptionOrderByWithRelationInput | ProjectSubscriptionOrderByWithRelationInput[]
    cursor?: ProjectSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSubscriptionScalarFieldEnum | ProjectSubscriptionScalarFieldEnum[]
  }

  /**
   * Toliner.specialization
   */
  export type Toliner$specializationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Toliner.portifolio
   */
  export type Toliner$portifolioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    where?: PortifolioWhereInput
    orderBy?: PortifolioOrderByWithRelationInput | PortifolioOrderByWithRelationInput[]
    cursor?: PortifolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortifolioScalarFieldEnum | PortifolioScalarFieldEnum[]
  }

  /**
   * Toliner.freelancerEvaluation
   */
  export type Toliner$freelancerEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    where?: FreelancerEvaluationWhereInput
    orderBy?: FreelancerEvaluationOrderByWithRelationInput | FreelancerEvaluationOrderByWithRelationInput[]
    cursor?: FreelancerEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelancerEvaluationScalarFieldEnum | FreelancerEvaluationScalarFieldEnum[]
  }

  /**
   * Toliner.user
   */
  export type Toliner$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Toliner.charges
   */
  export type Toliner$chargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    where?: ChargeWhereInput
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    cursor?: ChargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Toliner.balance
   */
  export type Toliner$balanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    where?: BalanceWhereInput
  }

  /**
   * Toliner.payments
   */
  export type Toliner$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Toliner.freelancerPayments
   */
  export type Toliner$freelancerPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Toliner without action
   */
  export type TolinerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    type: string | null
    createdAt: Date | null
    tag: string | null
    clientBio: string | null
    freelancerBio: string | null
    avatarUrl: string | null
    tolinerId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    type: string | null
    createdAt: Date | null
    tag: string | null
    clientBio: string | null
    freelancerBio: string | null
    avatarUrl: string | null
    tolinerId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    type: number
    createdAt: number
    tag: number
    clientBio: number
    freelancerBio: number
    avatarUrl: number
    tolinerId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    type?: true
    createdAt?: true
    tag?: true
    clientBio?: true
    freelancerBio?: true
    avatarUrl?: true
    tolinerId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    type?: true
    createdAt?: true
    tag?: true
    clientBio?: true
    freelancerBio?: true
    avatarUrl?: true
    tolinerId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    type?: true
    createdAt?: true
    tag?: true
    clientBio?: true
    freelancerBio?: true
    avatarUrl?: true
    tolinerId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    username: string
    type: string
    createdAt: Date
    tag: string
    clientBio: string | null
    freelancerBio: string | null
    avatarUrl: string | null
    tolinerId: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    type?: boolean
    createdAt?: boolean
    tag?: boolean
    clientBio?: boolean
    freelancerBio?: boolean
    avatarUrl?: boolean
    tolinerId?: boolean
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    skills?: boolean | User$skillsArgs<ExtArgs>
    TestAttempt?: boolean | User$TestAttemptArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    type?: boolean
    createdAt?: boolean
    tag?: boolean
    clientBio?: boolean
    freelancerBio?: boolean
    avatarUrl?: boolean
    tolinerId?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    type?: boolean
    createdAt?: boolean
    tag?: boolean
    clientBio?: boolean
    freelancerBio?: boolean
    avatarUrl?: boolean
    tolinerId?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    type?: boolean
    createdAt?: boolean
    tag?: boolean
    clientBio?: boolean
    freelancerBio?: boolean
    avatarUrl?: boolean
    tolinerId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "username" | "type" | "createdAt" | "tag" | "clientBio" | "freelancerBio" | "avatarUrl" | "tolinerId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    skills?: boolean | User$skillsArgs<ExtArgs>
    TestAttempt?: boolean | User$TestAttemptArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      toliner: Prisma.$TolinerPayload<ExtArgs>
      skills: Prisma.$SkillPayload<ExtArgs>[]
      TestAttempt: Prisma.$TestAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      username: string
      type: string
      createdAt: Date
      tag: string
      clientBio: string | null
      freelancerBio: string | null
      avatarUrl: string | null
      tolinerId: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toliner<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skills<T extends User$skillsArgs<ExtArgs> = {}>(args?: Subset<T, User$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TestAttempt<T extends User$TestAttemptArgs<ExtArgs> = {}>(args?: Subset<T, User$TestAttemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly type: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly tag: FieldRef<"User", 'String'>
    readonly clientBio: FieldRef<"User", 'String'>
    readonly freelancerBio: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly tolinerId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.skills
   */
  export type User$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * User.TestAttempt
   */
  export type User$TestAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    where?: TestAttemptWhereInput
    orderBy?: TestAttemptOrderByWithRelationInput | TestAttemptOrderByWithRelationInput[]
    cursor?: TestAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestAttemptScalarFieldEnum | TestAttemptScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    freelancerId: string | null
    status: $Enums.ProjectStatus | null
    categoryId: string | null
    subcategoryId: string | null
    dueDate: Date | null
    concludedAt: Date | null
    isAproved: boolean | null
    isActive: boolean | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
    freelancerId: string | null
    status: $Enums.ProjectStatus | null
    categoryId: string | null
    subcategoryId: string | null
    dueDate: Date | null
    concludedAt: Date | null
    isAproved: boolean | null
    isActive: boolean | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    ownerId: number
    freelancerId: number
    status: number
    categoryId: number
    subcategoryId: number
    dueDate: number
    concludedAt: number
    isAproved: number
    isActive: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    freelancerId?: true
    status?: true
    categoryId?: true
    subcategoryId?: true
    dueDate?: true
    concludedAt?: true
    isAproved?: true
    isActive?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    freelancerId?: true
    status?: true
    categoryId?: true
    subcategoryId?: true
    dueDate?: true
    concludedAt?: true
    isAproved?: true
    isActive?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    freelancerId?: true
    status?: true
    categoryId?: true
    subcategoryId?: true
    dueDate?: true
    concludedAt?: true
    isAproved?: true
    isActive?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    ownerId: string
    freelancerId: string | null
    status: $Enums.ProjectStatus
    categoryId: string | null
    subcategoryId: string | null
    dueDate: Date | null
    concludedAt: Date | null
    isAproved: boolean
    isActive: boolean
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    freelancerId?: boolean
    status?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    dueDate?: boolean
    concludedAt?: boolean
    isAproved?: boolean
    isActive?: boolean
    owner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | Project$freelancerArgs<ExtArgs>
    subscriptions?: boolean | Project$subscriptionsArgs<ExtArgs>
    category?: boolean | Project$categoryArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    quotation?: boolean | Project$quotationArgs<ExtArgs>
    conversations?: boolean | Project$conversationsArgs<ExtArgs>
    payment?: boolean | Project$paymentArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    freelancerId?: boolean
    status?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    dueDate?: boolean
    concludedAt?: boolean
    isAproved?: boolean
    isActive?: boolean
    owner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | Project$freelancerArgs<ExtArgs>
    category?: boolean | Project$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    freelancerId?: boolean
    status?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    dueDate?: boolean
    concludedAt?: boolean
    isAproved?: boolean
    isActive?: boolean
    owner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | Project$freelancerArgs<ExtArgs>
    category?: boolean | Project$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    freelancerId?: boolean
    status?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    dueDate?: boolean
    concludedAt?: boolean
    isAproved?: boolean
    isActive?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "ownerId" | "freelancerId" | "status" | "categoryId" | "subcategoryId" | "dueDate" | "concludedAt" | "isAproved" | "isActive", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | Project$freelancerArgs<ExtArgs>
    subscriptions?: boolean | Project$subscriptionsArgs<ExtArgs>
    category?: boolean | Project$categoryArgs<ExtArgs>
    skills?: boolean | Project$skillsArgs<ExtArgs>
    quotation?: boolean | Project$quotationArgs<ExtArgs>
    conversations?: boolean | Project$conversationsArgs<ExtArgs>
    payment?: boolean | Project$paymentArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | Project$freelancerArgs<ExtArgs>
    category?: boolean | Project$categoryArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | Project$freelancerArgs<ExtArgs>
    category?: boolean | Project$categoryArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      owner: Prisma.$TolinerPayload<ExtArgs>
      freelancer: Prisma.$TolinerPayload<ExtArgs> | null
      subscriptions: Prisma.$ProjectSubscriptionPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      skills: Prisma.$SkillPayload<ExtArgs>[]
      quotation: Prisma.$QuotationPayload<ExtArgs> | null
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
      ownerId: string
      freelancerId: string | null
      status: $Enums.ProjectStatus
      categoryId: string | null
      subcategoryId: string | null
      dueDate: Date | null
      concludedAt: Date | null
      isAproved: boolean
      isActive: boolean
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    freelancer<T extends Project$freelancerArgs<ExtArgs> = {}>(args?: Subset<T, Project$freelancerArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends Project$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Project$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Project$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    skills<T extends Project$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Project$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotation<T extends Project$quotationArgs<ExtArgs> = {}>(args?: Subset<T, Project$quotationArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conversations<T extends Project$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends Project$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Project$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly ownerId: FieldRef<"Project", 'String'>
    readonly freelancerId: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly categoryId: FieldRef<"Project", 'String'>
    readonly subcategoryId: FieldRef<"Project", 'String'>
    readonly dueDate: FieldRef<"Project", 'DateTime'>
    readonly concludedAt: FieldRef<"Project", 'DateTime'>
    readonly isAproved: FieldRef<"Project", 'Boolean'>
    readonly isActive: FieldRef<"Project", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.freelancer
   */
  export type Project$freelancerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    where?: TolinerWhereInput
  }

  /**
   * Project.subscriptions
   */
  export type Project$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    where?: ProjectSubscriptionWhereInput
    orderBy?: ProjectSubscriptionOrderByWithRelationInput | ProjectSubscriptionOrderByWithRelationInput[]
    cursor?: ProjectSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectSubscriptionScalarFieldEnum | ProjectSubscriptionScalarFieldEnum[]
  }

  /**
   * Project.category
   */
  export type Project$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Project.skills
   */
  export type Project$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Project.quotation
   */
  export type Project$quotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    where?: QuotationWhereInput
  }

  /**
   * Project.conversations
   */
  export type Project$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Project.payment
   */
  export type Project$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectSubscription
   */

  export type AggregateProjectSubscription = {
    _count: ProjectSubscriptionCountAggregateOutputType | null
    _avg: ProjectSubscriptionAvgAggregateOutputType | null
    _sum: ProjectSubscriptionSumAggregateOutputType | null
    _min: ProjectSubscriptionMinAggregateOutputType | null
    _max: ProjectSubscriptionMaxAggregateOutputType | null
  }

  export type ProjectSubscriptionAvgAggregateOutputType = {
    quotation: number | null
  }

  export type ProjectSubscriptionSumAggregateOutputType = {
    quotation: number | null
  }

  export type ProjectSubscriptionMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    tolinerId: string | null
    estimatedTime: string | null
    requiredInformations: string | null
    similarExperiences: string | null
    proposal: string | null
    quotation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectSubscriptionMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    tolinerId: string | null
    estimatedTime: string | null
    requiredInformations: string | null
    similarExperiences: string | null
    proposal: string | null
    quotation: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectSubscriptionCountAggregateOutputType = {
    id: number
    projectId: number
    tolinerId: number
    estimatedTime: number
    requiredInformations: number
    similarExperiences: number
    proposal: number
    quotation: number
    createdAt: number
    updatedAt: number
    invitation: number
    _all: number
  }


  export type ProjectSubscriptionAvgAggregateInputType = {
    quotation?: true
  }

  export type ProjectSubscriptionSumAggregateInputType = {
    quotation?: true
  }

  export type ProjectSubscriptionMinAggregateInputType = {
    id?: true
    projectId?: true
    tolinerId?: true
    estimatedTime?: true
    requiredInformations?: true
    similarExperiences?: true
    proposal?: true
    quotation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectSubscriptionMaxAggregateInputType = {
    id?: true
    projectId?: true
    tolinerId?: true
    estimatedTime?: true
    requiredInformations?: true
    similarExperiences?: true
    proposal?: true
    quotation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectSubscriptionCountAggregateInputType = {
    id?: true
    projectId?: true
    tolinerId?: true
    estimatedTime?: true
    requiredInformations?: true
    similarExperiences?: true
    proposal?: true
    quotation?: true
    createdAt?: true
    updatedAt?: true
    invitation?: true
    _all?: true
  }

  export type ProjectSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSubscription to aggregate.
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSubscriptions to fetch.
     */
    orderBy?: ProjectSubscriptionOrderByWithRelationInput | ProjectSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectSubscriptions
    **/
    _count?: true | ProjectSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectSubscriptionMaxAggregateInputType
  }

  export type GetProjectSubscriptionAggregateType<T extends ProjectSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectSubscription[P]>
      : GetScalarType<T[P], AggregateProjectSubscription[P]>
  }




  export type ProjectSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectSubscriptionWhereInput
    orderBy?: ProjectSubscriptionOrderByWithAggregationInput | ProjectSubscriptionOrderByWithAggregationInput[]
    by: ProjectSubscriptionScalarFieldEnum[] | ProjectSubscriptionScalarFieldEnum
    having?: ProjectSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectSubscriptionCountAggregateInputType | true
    _avg?: ProjectSubscriptionAvgAggregateInputType
    _sum?: ProjectSubscriptionSumAggregateInputType
    _min?: ProjectSubscriptionMinAggregateInputType
    _max?: ProjectSubscriptionMaxAggregateInputType
  }

  export type ProjectSubscriptionGroupByOutputType = {
    id: string
    projectId: string
    tolinerId: string
    estimatedTime: string | null
    requiredInformations: string | null
    similarExperiences: string | null
    proposal: string
    quotation: number | null
    createdAt: Date
    updatedAt: Date
    invitation: JsonValue | null
    _count: ProjectSubscriptionCountAggregateOutputType | null
    _avg: ProjectSubscriptionAvgAggregateOutputType | null
    _sum: ProjectSubscriptionSumAggregateOutputType | null
    _min: ProjectSubscriptionMinAggregateOutputType | null
    _max: ProjectSubscriptionMaxAggregateOutputType | null
  }

  type GetProjectSubscriptionGroupByPayload<T extends ProjectSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    tolinerId?: boolean
    estimatedTime?: boolean
    requiredInformations?: boolean
    similarExperiences?: boolean
    proposal?: boolean
    quotation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitation?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSubscription"]>

  export type ProjectSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    tolinerId?: boolean
    estimatedTime?: boolean
    requiredInformations?: boolean
    similarExperiences?: boolean
    proposal?: boolean
    quotation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitation?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSubscription"]>

  export type ProjectSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    tolinerId?: boolean
    estimatedTime?: boolean
    requiredInformations?: boolean
    similarExperiences?: boolean
    proposal?: boolean
    quotation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitation?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectSubscription"]>

  export type ProjectSubscriptionSelectScalar = {
    id?: boolean
    projectId?: boolean
    tolinerId?: boolean
    estimatedTime?: boolean
    requiredInformations?: boolean
    similarExperiences?: boolean
    proposal?: boolean
    quotation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitation?: boolean
  }

  export type ProjectSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "tolinerId" | "estimatedTime" | "requiredInformations" | "similarExperiences" | "proposal" | "quotation" | "createdAt" | "updatedAt" | "invitation", ExtArgs["result"]["projectSubscription"]>
  export type ProjectSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectSubscription"
    objects: {
      toliner: Prisma.$TolinerPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      tolinerId: string
      estimatedTime: string | null
      requiredInformations: string | null
      similarExperiences: string | null
      proposal: string
      quotation: number | null
      createdAt: Date
      updatedAt: Date
      invitation: Prisma.JsonValue | null
    }, ExtArgs["result"]["projectSubscription"]>
    composites: {}
  }

  type ProjectSubscriptionGetPayload<S extends boolean | null | undefined | ProjectSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$ProjectSubscriptionPayload, S>

  type ProjectSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectSubscriptionCountAggregateInputType | true
    }

  export interface ProjectSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectSubscription'], meta: { name: 'ProjectSubscription' } }
    /**
     * Find zero or one ProjectSubscription that matches the filter.
     * @param {ProjectSubscriptionFindUniqueArgs} args - Arguments to find a ProjectSubscription
     * @example
     * // Get one ProjectSubscription
     * const projectSubscription = await prisma.projectSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectSubscriptionFindUniqueArgs>(args: SelectSubset<T, ProjectSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a ProjectSubscription
     * @example
     * // Get one ProjectSubscription
     * const projectSubscription = await prisma.projectSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionFindFirstArgs} args - Arguments to find a ProjectSubscription
     * @example
     * // Get one ProjectSubscription
     * const projectSubscription = await prisma.projectSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectSubscriptionFindFirstArgs>(args?: SelectSubset<T, ProjectSubscriptionFindFirstArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionFindFirstOrThrowArgs} args - Arguments to find a ProjectSubscription
     * @example
     * // Get one ProjectSubscription
     * const projectSubscription = await prisma.projectSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectSubscriptions
     * const projectSubscriptions = await prisma.projectSubscription.findMany()
     * 
     * // Get first 10 ProjectSubscriptions
     * const projectSubscriptions = await prisma.projectSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectSubscriptionWithIdOnly = await prisma.projectSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectSubscriptionFindManyArgs>(args?: SelectSubset<T, ProjectSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectSubscription.
     * @param {ProjectSubscriptionCreateArgs} args - Arguments to create a ProjectSubscription.
     * @example
     * // Create one ProjectSubscription
     * const ProjectSubscription = await prisma.projectSubscription.create({
     *   data: {
     *     // ... data to create a ProjectSubscription
     *   }
     * })
     * 
     */
    create<T extends ProjectSubscriptionCreateArgs>(args: SelectSubset<T, ProjectSubscriptionCreateArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectSubscriptions.
     * @param {ProjectSubscriptionCreateManyArgs} args - Arguments to create many ProjectSubscriptions.
     * @example
     * // Create many ProjectSubscriptions
     * const projectSubscription = await prisma.projectSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectSubscriptionCreateManyArgs>(args?: SelectSubset<T, ProjectSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectSubscriptions and returns the data saved in the database.
     * @param {ProjectSubscriptionCreateManyAndReturnArgs} args - Arguments to create many ProjectSubscriptions.
     * @example
     * // Create many ProjectSubscriptions
     * const projectSubscription = await prisma.projectSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectSubscriptions and only return the `id`
     * const projectSubscriptionWithIdOnly = await prisma.projectSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectSubscription.
     * @param {ProjectSubscriptionDeleteArgs} args - Arguments to delete one ProjectSubscription.
     * @example
     * // Delete one ProjectSubscription
     * const ProjectSubscription = await prisma.projectSubscription.delete({
     *   where: {
     *     // ... filter to delete one ProjectSubscription
     *   }
     * })
     * 
     */
    delete<T extends ProjectSubscriptionDeleteArgs>(args: SelectSubset<T, ProjectSubscriptionDeleteArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectSubscription.
     * @param {ProjectSubscriptionUpdateArgs} args - Arguments to update one ProjectSubscription.
     * @example
     * // Update one ProjectSubscription
     * const projectSubscription = await prisma.projectSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectSubscriptionUpdateArgs>(args: SelectSubset<T, ProjectSubscriptionUpdateArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectSubscriptions.
     * @param {ProjectSubscriptionDeleteManyArgs} args - Arguments to filter ProjectSubscriptions to delete.
     * @example
     * // Delete a few ProjectSubscriptions
     * const { count } = await prisma.projectSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectSubscriptionDeleteManyArgs>(args?: SelectSubset<T, ProjectSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectSubscriptions
     * const projectSubscription = await prisma.projectSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectSubscriptionUpdateManyArgs>(args: SelectSubset<T, ProjectSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectSubscriptions and returns the data updated in the database.
     * @param {ProjectSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many ProjectSubscriptions.
     * @example
     * // Update many ProjectSubscriptions
     * const projectSubscription = await prisma.projectSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectSubscriptions and only return the `id`
     * const projectSubscriptionWithIdOnly = await prisma.projectSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectSubscription.
     * @param {ProjectSubscriptionUpsertArgs} args - Arguments to update or create a ProjectSubscription.
     * @example
     * // Update or create a ProjectSubscription
     * const projectSubscription = await prisma.projectSubscription.upsert({
     *   create: {
     *     // ... data to create a ProjectSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectSubscription we want to update
     *   }
     * })
     */
    upsert<T extends ProjectSubscriptionUpsertArgs>(args: SelectSubset<T, ProjectSubscriptionUpsertArgs<ExtArgs>>): Prisma__ProjectSubscriptionClient<$Result.GetResult<Prisma.$ProjectSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionCountArgs} args - Arguments to filter ProjectSubscriptions to count.
     * @example
     * // Count the number of ProjectSubscriptions
     * const count = await prisma.projectSubscription.count({
     *   where: {
     *     // ... the filter for the ProjectSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends ProjectSubscriptionCountArgs>(
      args?: Subset<T, ProjectSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectSubscriptionAggregateArgs>(args: Subset<T, ProjectSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetProjectSubscriptionAggregateType<T>>

    /**
     * Group by ProjectSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: ProjectSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectSubscription model
   */
  readonly fields: ProjectSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toliner<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectSubscription model
   */
  interface ProjectSubscriptionFieldRefs {
    readonly id: FieldRef<"ProjectSubscription", 'String'>
    readonly projectId: FieldRef<"ProjectSubscription", 'String'>
    readonly tolinerId: FieldRef<"ProjectSubscription", 'String'>
    readonly estimatedTime: FieldRef<"ProjectSubscription", 'String'>
    readonly requiredInformations: FieldRef<"ProjectSubscription", 'String'>
    readonly similarExperiences: FieldRef<"ProjectSubscription", 'String'>
    readonly proposal: FieldRef<"ProjectSubscription", 'String'>
    readonly quotation: FieldRef<"ProjectSubscription", 'Float'>
    readonly createdAt: FieldRef<"ProjectSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectSubscription", 'DateTime'>
    readonly invitation: FieldRef<"ProjectSubscription", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ProjectSubscription findUnique
   */
  export type ProjectSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSubscription to fetch.
     */
    where: ProjectSubscriptionWhereUniqueInput
  }

  /**
   * ProjectSubscription findUniqueOrThrow
   */
  export type ProjectSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSubscription to fetch.
     */
    where: ProjectSubscriptionWhereUniqueInput
  }

  /**
   * ProjectSubscription findFirst
   */
  export type ProjectSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSubscription to fetch.
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSubscriptions to fetch.
     */
    orderBy?: ProjectSubscriptionOrderByWithRelationInput | ProjectSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSubscriptions.
     */
    cursor?: ProjectSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSubscriptions.
     */
    distinct?: ProjectSubscriptionScalarFieldEnum | ProjectSubscriptionScalarFieldEnum[]
  }

  /**
   * ProjectSubscription findFirstOrThrow
   */
  export type ProjectSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSubscription to fetch.
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSubscriptions to fetch.
     */
    orderBy?: ProjectSubscriptionOrderByWithRelationInput | ProjectSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectSubscriptions.
     */
    cursor?: ProjectSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectSubscriptions.
     */
    distinct?: ProjectSubscriptionScalarFieldEnum | ProjectSubscriptionScalarFieldEnum[]
  }

  /**
   * ProjectSubscription findMany
   */
  export type ProjectSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ProjectSubscriptions to fetch.
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectSubscriptions to fetch.
     */
    orderBy?: ProjectSubscriptionOrderByWithRelationInput | ProjectSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectSubscriptions.
     */
    cursor?: ProjectSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectSubscriptions.
     */
    skip?: number
    distinct?: ProjectSubscriptionScalarFieldEnum | ProjectSubscriptionScalarFieldEnum[]
  }

  /**
   * ProjectSubscription create
   */
  export type ProjectSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectSubscription.
     */
    data: XOR<ProjectSubscriptionCreateInput, ProjectSubscriptionUncheckedCreateInput>
  }

  /**
   * ProjectSubscription createMany
   */
  export type ProjectSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectSubscriptions.
     */
    data: ProjectSubscriptionCreateManyInput | ProjectSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectSubscription createManyAndReturn
   */
  export type ProjectSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectSubscriptions.
     */
    data: ProjectSubscriptionCreateManyInput | ProjectSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectSubscription update
   */
  export type ProjectSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectSubscription.
     */
    data: XOR<ProjectSubscriptionUpdateInput, ProjectSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which ProjectSubscription to update.
     */
    where: ProjectSubscriptionWhereUniqueInput
  }

  /**
   * ProjectSubscription updateMany
   */
  export type ProjectSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectSubscriptions.
     */
    data: XOR<ProjectSubscriptionUpdateManyMutationInput, ProjectSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSubscriptions to update
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * Limit how many ProjectSubscriptions to update.
     */
    limit?: number
  }

  /**
   * ProjectSubscription updateManyAndReturn
   */
  export type ProjectSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update ProjectSubscriptions.
     */
    data: XOR<ProjectSubscriptionUpdateManyMutationInput, ProjectSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ProjectSubscriptions to update
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * Limit how many ProjectSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectSubscription upsert
   */
  export type ProjectSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectSubscription to update in case it exists.
     */
    where: ProjectSubscriptionWhereUniqueInput
    /**
     * In case the ProjectSubscription found by the `where` argument doesn't exist, create a new ProjectSubscription with this data.
     */
    create: XOR<ProjectSubscriptionCreateInput, ProjectSubscriptionUncheckedCreateInput>
    /**
     * In case the ProjectSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectSubscriptionUpdateInput, ProjectSubscriptionUncheckedUpdateInput>
  }

  /**
   * ProjectSubscription delete
   */
  export type ProjectSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which ProjectSubscription to delete.
     */
    where: ProjectSubscriptionWhereUniqueInput
  }

  /**
   * ProjectSubscription deleteMany
   */
  export type ProjectSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectSubscriptions to delete
     */
    where?: ProjectSubscriptionWhereInput
    /**
     * Limit how many ProjectSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * ProjectSubscription without action
   */
  export type ProjectSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectSubscription
     */
    select?: ProjectSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectSubscription
     */
    omit?: ProjectSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    slug: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    skills?: boolean | Category$skillsArgs<ExtArgs>
    toliners?: boolean | Category$tolinersArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    projects?: boolean | Category$projectsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | Category$skillsArgs<ExtArgs>
    toliners?: boolean | Category$tolinersArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    projects?: boolean | Category$projectsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      skills: Prisma.$SkillPayload<ExtArgs>[]
      toliners: Prisma.$TolinerPayload<ExtArgs>[]
      subcategories: Prisma.$SubcategoryPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      slug: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends Category$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Category$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toliners<T extends Category$tolinersArgs<ExtArgs> = {}>(args?: Subset<T, Category$tolinersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Category$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Category$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Category$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.skills
   */
  export type Category$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Category.toliners
   */
  export type Category$tolinersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    where?: TolinerWhereInput
    orderBy?: TolinerOrderByWithRelationInput | TolinerOrderByWithRelationInput[]
    cursor?: TolinerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TolinerScalarFieldEnum | TolinerScalarFieldEnum[]
  }

  /**
   * Category.subcategories
   */
  export type Category$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    cursor?: SubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Category.projects
   */
  export type Category$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Subcategory
   */

  export type AggregateSubcategory = {
    _count: SubcategoryCountAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  export type SubcategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    categoryId: string | null
  }

  export type SubcategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    slug: string | null
    categoryId: string | null
  }

  export type SubcategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    slug: number
    categoryId: number
    _all: number
  }


  export type SubcategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    categoryId?: true
  }

  export type SubcategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    categoryId?: true
  }

  export type SubcategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    slug?: true
    categoryId?: true
    _all?: true
  }

  export type SubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategory to aggregate.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subcategories
    **/
    _count?: true | SubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubcategoryMaxAggregateInputType
  }

  export type GetSubcategoryAggregateType<T extends SubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubcategory[P]>
      : GetScalarType<T[P], AggregateSubcategory[P]>
  }




  export type SubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithAggregationInput | SubcategoryOrderByWithAggregationInput[]
    by: SubcategoryScalarFieldEnum[] | SubcategoryScalarFieldEnum
    having?: SubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubcategoryCountAggregateInputType | true
    _min?: SubcategoryMinAggregateInputType
    _max?: SubcategoryMaxAggregateInputType
  }

  export type SubcategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    slug: string
    categoryId: string | null
    _count: SubcategoryCountAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  type GetSubcategoryGroupByPayload<T extends SubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    categoryId?: boolean
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    categoryId?: boolean
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    categoryId?: boolean
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    slug?: boolean
    categoryId?: boolean
  }

  export type SubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "slug" | "categoryId", ExtArgs["result"]["subcategory"]>
  export type SubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }
  export type SubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }
  export type SubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Subcategory$categoryArgs<ExtArgs>
  }

  export type $SubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subcategory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      slug: string
      categoryId: string | null
    }, ExtArgs["result"]["subcategory"]>
    composites: {}
  }

  type SubcategoryGetPayload<S extends boolean | null | undefined | SubcategoryDefaultArgs> = $Result.GetResult<Prisma.$SubcategoryPayload, S>

  type SubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubcategoryCountAggregateInputType | true
    }

  export interface SubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subcategory'], meta: { name: 'Subcategory' } }
    /**
     * Find zero or one Subcategory that matches the filter.
     * @param {SubcategoryFindUniqueArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubcategoryFindUniqueArgs>(args: SelectSubset<T, SubcategoryFindUniqueArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubcategoryFindUniqueOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubcategoryFindFirstArgs>(args?: SelectSubset<T, SubcategoryFindFirstArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subcategories
     * const subcategories = await prisma.subcategory.findMany()
     * 
     * // Get first 10 Subcategories
     * const subcategories = await prisma.subcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubcategoryFindManyArgs>(args?: SelectSubset<T, SubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subcategory.
     * @param {SubcategoryCreateArgs} args - Arguments to create a Subcategory.
     * @example
     * // Create one Subcategory
     * const Subcategory = await prisma.subcategory.create({
     *   data: {
     *     // ... data to create a Subcategory
     *   }
     * })
     * 
     */
    create<T extends SubcategoryCreateArgs>(args: SelectSubset<T, SubcategoryCreateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subcategories.
     * @param {SubcategoryCreateManyArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubcategoryCreateManyArgs>(args?: SelectSubset<T, SubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subcategories and returns the data saved in the database.
     * @param {SubcategoryCreateManyAndReturnArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subcategory.
     * @param {SubcategoryDeleteArgs} args - Arguments to delete one Subcategory.
     * @example
     * // Delete one Subcategory
     * const Subcategory = await prisma.subcategory.delete({
     *   where: {
     *     // ... filter to delete one Subcategory
     *   }
     * })
     * 
     */
    delete<T extends SubcategoryDeleteArgs>(args: SelectSubset<T, SubcategoryDeleteArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subcategory.
     * @param {SubcategoryUpdateArgs} args - Arguments to update one Subcategory.
     * @example
     * // Update one Subcategory
     * const subcategory = await prisma.subcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubcategoryUpdateArgs>(args: SelectSubset<T, SubcategoryUpdateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subcategories.
     * @param {SubcategoryDeleteManyArgs} args - Arguments to filter Subcategories to delete.
     * @example
     * // Delete a few Subcategories
     * const { count } = await prisma.subcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubcategoryDeleteManyArgs>(args?: SelectSubset<T, SubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubcategoryUpdateManyArgs>(args: SelectSubset<T, SubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories and returns the data updated in the database.
     * @param {SubcategoryUpdateManyAndReturnArgs} args - Arguments to update many Subcategories.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subcategory.
     * @param {SubcategoryUpsertArgs} args - Arguments to update or create a Subcategory.
     * @example
     * // Update or create a Subcategory
     * const subcategory = await prisma.subcategory.upsert({
     *   create: {
     *     // ... data to create a Subcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subcategory we want to update
     *   }
     * })
     */
    upsert<T extends SubcategoryUpsertArgs>(args: SelectSubset<T, SubcategoryUpsertArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryCountArgs} args - Arguments to filter Subcategories to count.
     * @example
     * // Count the number of Subcategories
     * const count = await prisma.subcategory.count({
     *   where: {
     *     // ... the filter for the Subcategories we want to count
     *   }
     * })
    **/
    count<T extends SubcategoryCountArgs>(
      args?: Subset<T, SubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubcategoryAggregateArgs>(args: Subset<T, SubcategoryAggregateArgs>): Prisma.PrismaPromise<GetSubcategoryAggregateType<T>>

    /**
     * Group by Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subcategory model
   */
  readonly fields: SubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Subcategory$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subcategory model
   */
  interface SubcategoryFieldRefs {
    readonly id: FieldRef<"Subcategory", 'String'>
    readonly name: FieldRef<"Subcategory", 'String'>
    readonly description: FieldRef<"Subcategory", 'String'>
    readonly slug: FieldRef<"Subcategory", 'String'>
    readonly categoryId: FieldRef<"Subcategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subcategory findUnique
   */
  export type SubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findUniqueOrThrow
   */
  export type SubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findFirst
   */
  export type SubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findFirstOrThrow
   */
  export type SubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findMany
   */
  export type SubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategories to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory create
   */
  export type SubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Subcategory.
     */
    data: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
  }

  /**
   * Subcategory createMany
   */
  export type SubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subcategory createManyAndReturn
   */
  export type SubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory update
   */
  export type SubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Subcategory.
     */
    data: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
    /**
     * Choose, which Subcategory to update.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory updateMany
   */
  export type SubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
  }

  /**
   * Subcategory updateManyAndReturn
   */
  export type SubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory upsert
   */
  export type SubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Subcategory to update in case it exists.
     */
    where: SubcategoryWhereUniqueInput
    /**
     * In case the Subcategory found by the `where` argument doesn't exist, create a new Subcategory with this data.
     */
    create: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
    /**
     * In case the Subcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
  }

  /**
   * Subcategory delete
   */
  export type SubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter which Subcategory to delete.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory deleteMany
   */
  export type SubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategories to delete
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to delete.
     */
    limit?: number
  }

  /**
   * Subcategory.category
   */
  export type Subcategory$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Subcategory without action
   */
  export type SubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model FreelancerEvaluation
   */

  export type AggregateFreelancerEvaluation = {
    _count: FreelancerEvaluationCountAggregateOutputType | null
    _min: FreelancerEvaluationMinAggregateOutputType | null
    _max: FreelancerEvaluationMaxAggregateOutputType | null
  }

  export type FreelancerEvaluationMinAggregateOutputType = {
    id: string | null
    rate: string | null
    tolinerId: string | null
    evaluatorId: string | null
    comment: string | null
  }

  export type FreelancerEvaluationMaxAggregateOutputType = {
    id: string | null
    rate: string | null
    tolinerId: string | null
    evaluatorId: string | null
    comment: string | null
  }

  export type FreelancerEvaluationCountAggregateOutputType = {
    id: number
    rate: number
    tolinerId: number
    evaluatorId: number
    comment: number
    _all: number
  }


  export type FreelancerEvaluationMinAggregateInputType = {
    id?: true
    rate?: true
    tolinerId?: true
    evaluatorId?: true
    comment?: true
  }

  export type FreelancerEvaluationMaxAggregateInputType = {
    id?: true
    rate?: true
    tolinerId?: true
    evaluatorId?: true
    comment?: true
  }

  export type FreelancerEvaluationCountAggregateInputType = {
    id?: true
    rate?: true
    tolinerId?: true
    evaluatorId?: true
    comment?: true
    _all?: true
  }

  export type FreelancerEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelancerEvaluation to aggregate.
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerEvaluations to fetch.
     */
    orderBy?: FreelancerEvaluationOrderByWithRelationInput | FreelancerEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelancerEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelancerEvaluations
    **/
    _count?: true | FreelancerEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelancerEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelancerEvaluationMaxAggregateInputType
  }

  export type GetFreelancerEvaluationAggregateType<T extends FreelancerEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelancerEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelancerEvaluation[P]>
      : GetScalarType<T[P], AggregateFreelancerEvaluation[P]>
  }




  export type FreelancerEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelancerEvaluationWhereInput
    orderBy?: FreelancerEvaluationOrderByWithAggregationInput | FreelancerEvaluationOrderByWithAggregationInput[]
    by: FreelancerEvaluationScalarFieldEnum[] | FreelancerEvaluationScalarFieldEnum
    having?: FreelancerEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelancerEvaluationCountAggregateInputType | true
    _min?: FreelancerEvaluationMinAggregateInputType
    _max?: FreelancerEvaluationMaxAggregateInputType
  }

  export type FreelancerEvaluationGroupByOutputType = {
    id: string
    rate: string
    tolinerId: string
    evaluatorId: string
    comment: string
    _count: FreelancerEvaluationCountAggregateOutputType | null
    _min: FreelancerEvaluationMinAggregateOutputType | null
    _max: FreelancerEvaluationMaxAggregateOutputType | null
  }

  type GetFreelancerEvaluationGroupByPayload<T extends FreelancerEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelancerEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelancerEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelancerEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], FreelancerEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type FreelancerEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rate?: boolean
    tolinerId?: boolean
    evaluatorId?: boolean
    comment?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerEvaluation"]>

  export type FreelancerEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rate?: boolean
    tolinerId?: boolean
    evaluatorId?: boolean
    comment?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerEvaluation"]>

  export type FreelancerEvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rate?: boolean
    tolinerId?: boolean
    evaluatorId?: boolean
    comment?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelancerEvaluation"]>

  export type FreelancerEvaluationSelectScalar = {
    id?: boolean
    rate?: boolean
    tolinerId?: boolean
    evaluatorId?: boolean
    comment?: boolean
  }

  export type FreelancerEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rate" | "tolinerId" | "evaluatorId" | "comment", ExtArgs["result"]["freelancerEvaluation"]>
  export type FreelancerEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type FreelancerEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type FreelancerEvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }

  export type $FreelancerEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelancerEvaluation"
    objects: {
      toliner: Prisma.$TolinerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rate: string
      tolinerId: string
      evaluatorId: string
      comment: string
    }, ExtArgs["result"]["freelancerEvaluation"]>
    composites: {}
  }

  type FreelancerEvaluationGetPayload<S extends boolean | null | undefined | FreelancerEvaluationDefaultArgs> = $Result.GetResult<Prisma.$FreelancerEvaluationPayload, S>

  type FreelancerEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreelancerEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelancerEvaluationCountAggregateInputType | true
    }

  export interface FreelancerEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelancerEvaluation'], meta: { name: 'FreelancerEvaluation' } }
    /**
     * Find zero or one FreelancerEvaluation that matches the filter.
     * @param {FreelancerEvaluationFindUniqueArgs} args - Arguments to find a FreelancerEvaluation
     * @example
     * // Get one FreelancerEvaluation
     * const freelancerEvaluation = await prisma.freelancerEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelancerEvaluationFindUniqueArgs>(args: SelectSubset<T, FreelancerEvaluationFindUniqueArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreelancerEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreelancerEvaluationFindUniqueOrThrowArgs} args - Arguments to find a FreelancerEvaluation
     * @example
     * // Get one FreelancerEvaluation
     * const freelancerEvaluation = await prisma.freelancerEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelancerEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelancerEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelancerEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationFindFirstArgs} args - Arguments to find a FreelancerEvaluation
     * @example
     * // Get one FreelancerEvaluation
     * const freelancerEvaluation = await prisma.freelancerEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelancerEvaluationFindFirstArgs>(args?: SelectSubset<T, FreelancerEvaluationFindFirstArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelancerEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationFindFirstOrThrowArgs} args - Arguments to find a FreelancerEvaluation
     * @example
     * // Get one FreelancerEvaluation
     * const freelancerEvaluation = await prisma.freelancerEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelancerEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelancerEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreelancerEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelancerEvaluations
     * const freelancerEvaluations = await prisma.freelancerEvaluation.findMany()
     * 
     * // Get first 10 FreelancerEvaluations
     * const freelancerEvaluations = await prisma.freelancerEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelancerEvaluationWithIdOnly = await prisma.freelancerEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelancerEvaluationFindManyArgs>(args?: SelectSubset<T, FreelancerEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreelancerEvaluation.
     * @param {FreelancerEvaluationCreateArgs} args - Arguments to create a FreelancerEvaluation.
     * @example
     * // Create one FreelancerEvaluation
     * const FreelancerEvaluation = await prisma.freelancerEvaluation.create({
     *   data: {
     *     // ... data to create a FreelancerEvaluation
     *   }
     * })
     * 
     */
    create<T extends FreelancerEvaluationCreateArgs>(args: SelectSubset<T, FreelancerEvaluationCreateArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreelancerEvaluations.
     * @param {FreelancerEvaluationCreateManyArgs} args - Arguments to create many FreelancerEvaluations.
     * @example
     * // Create many FreelancerEvaluations
     * const freelancerEvaluation = await prisma.freelancerEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelancerEvaluationCreateManyArgs>(args?: SelectSubset<T, FreelancerEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelancerEvaluations and returns the data saved in the database.
     * @param {FreelancerEvaluationCreateManyAndReturnArgs} args - Arguments to create many FreelancerEvaluations.
     * @example
     * // Create many FreelancerEvaluations
     * const freelancerEvaluation = await prisma.freelancerEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelancerEvaluations and only return the `id`
     * const freelancerEvaluationWithIdOnly = await prisma.freelancerEvaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelancerEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelancerEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreelancerEvaluation.
     * @param {FreelancerEvaluationDeleteArgs} args - Arguments to delete one FreelancerEvaluation.
     * @example
     * // Delete one FreelancerEvaluation
     * const FreelancerEvaluation = await prisma.freelancerEvaluation.delete({
     *   where: {
     *     // ... filter to delete one FreelancerEvaluation
     *   }
     * })
     * 
     */
    delete<T extends FreelancerEvaluationDeleteArgs>(args: SelectSubset<T, FreelancerEvaluationDeleteArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreelancerEvaluation.
     * @param {FreelancerEvaluationUpdateArgs} args - Arguments to update one FreelancerEvaluation.
     * @example
     * // Update one FreelancerEvaluation
     * const freelancerEvaluation = await prisma.freelancerEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelancerEvaluationUpdateArgs>(args: SelectSubset<T, FreelancerEvaluationUpdateArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreelancerEvaluations.
     * @param {FreelancerEvaluationDeleteManyArgs} args - Arguments to filter FreelancerEvaluations to delete.
     * @example
     * // Delete a few FreelancerEvaluations
     * const { count } = await prisma.freelancerEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelancerEvaluationDeleteManyArgs>(args?: SelectSubset<T, FreelancerEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelancerEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelancerEvaluations
     * const freelancerEvaluation = await prisma.freelancerEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelancerEvaluationUpdateManyArgs>(args: SelectSubset<T, FreelancerEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelancerEvaluations and returns the data updated in the database.
     * @param {FreelancerEvaluationUpdateManyAndReturnArgs} args - Arguments to update many FreelancerEvaluations.
     * @example
     * // Update many FreelancerEvaluations
     * const freelancerEvaluation = await prisma.freelancerEvaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreelancerEvaluations and only return the `id`
     * const freelancerEvaluationWithIdOnly = await prisma.freelancerEvaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreelancerEvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, FreelancerEvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreelancerEvaluation.
     * @param {FreelancerEvaluationUpsertArgs} args - Arguments to update or create a FreelancerEvaluation.
     * @example
     * // Update or create a FreelancerEvaluation
     * const freelancerEvaluation = await prisma.freelancerEvaluation.upsert({
     *   create: {
     *     // ... data to create a FreelancerEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelancerEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends FreelancerEvaluationUpsertArgs>(args: SelectSubset<T, FreelancerEvaluationUpsertArgs<ExtArgs>>): Prisma__FreelancerEvaluationClient<$Result.GetResult<Prisma.$FreelancerEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreelancerEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationCountArgs} args - Arguments to filter FreelancerEvaluations to count.
     * @example
     * // Count the number of FreelancerEvaluations
     * const count = await prisma.freelancerEvaluation.count({
     *   where: {
     *     // ... the filter for the FreelancerEvaluations we want to count
     *   }
     * })
    **/
    count<T extends FreelancerEvaluationCountArgs>(
      args?: Subset<T, FreelancerEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelancerEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelancerEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelancerEvaluationAggregateArgs>(args: Subset<T, FreelancerEvaluationAggregateArgs>): Prisma.PrismaPromise<GetFreelancerEvaluationAggregateType<T>>

    /**
     * Group by FreelancerEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelancerEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelancerEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelancerEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: FreelancerEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelancerEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelancerEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelancerEvaluation model
   */
  readonly fields: FreelancerEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelancerEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelancerEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toliner<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelancerEvaluation model
   */
  interface FreelancerEvaluationFieldRefs {
    readonly id: FieldRef<"FreelancerEvaluation", 'String'>
    readonly rate: FieldRef<"FreelancerEvaluation", 'String'>
    readonly tolinerId: FieldRef<"FreelancerEvaluation", 'String'>
    readonly evaluatorId: FieldRef<"FreelancerEvaluation", 'String'>
    readonly comment: FieldRef<"FreelancerEvaluation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FreelancerEvaluation findUnique
   */
  export type FreelancerEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerEvaluation to fetch.
     */
    where: FreelancerEvaluationWhereUniqueInput
  }

  /**
   * FreelancerEvaluation findUniqueOrThrow
   */
  export type FreelancerEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerEvaluation to fetch.
     */
    where: FreelancerEvaluationWhereUniqueInput
  }

  /**
   * FreelancerEvaluation findFirst
   */
  export type FreelancerEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerEvaluation to fetch.
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerEvaluations to fetch.
     */
    orderBy?: FreelancerEvaluationOrderByWithRelationInput | FreelancerEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelancerEvaluations.
     */
    cursor?: FreelancerEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelancerEvaluations.
     */
    distinct?: FreelancerEvaluationScalarFieldEnum | FreelancerEvaluationScalarFieldEnum[]
  }

  /**
   * FreelancerEvaluation findFirstOrThrow
   */
  export type FreelancerEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerEvaluation to fetch.
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerEvaluations to fetch.
     */
    orderBy?: FreelancerEvaluationOrderByWithRelationInput | FreelancerEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelancerEvaluations.
     */
    cursor?: FreelancerEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelancerEvaluations.
     */
    distinct?: FreelancerEvaluationScalarFieldEnum | FreelancerEvaluationScalarFieldEnum[]
  }

  /**
   * FreelancerEvaluation findMany
   */
  export type FreelancerEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FreelancerEvaluations to fetch.
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelancerEvaluations to fetch.
     */
    orderBy?: FreelancerEvaluationOrderByWithRelationInput | FreelancerEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelancerEvaluations.
     */
    cursor?: FreelancerEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelancerEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelancerEvaluations.
     */
    skip?: number
    distinct?: FreelancerEvaluationScalarFieldEnum | FreelancerEvaluationScalarFieldEnum[]
  }

  /**
   * FreelancerEvaluation create
   */
  export type FreelancerEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelancerEvaluation.
     */
    data: XOR<FreelancerEvaluationCreateInput, FreelancerEvaluationUncheckedCreateInput>
  }

  /**
   * FreelancerEvaluation createMany
   */
  export type FreelancerEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelancerEvaluations.
     */
    data: FreelancerEvaluationCreateManyInput | FreelancerEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelancerEvaluation createManyAndReturn
   */
  export type FreelancerEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many FreelancerEvaluations.
     */
    data: FreelancerEvaluationCreateManyInput | FreelancerEvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelancerEvaluation update
   */
  export type FreelancerEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelancerEvaluation.
     */
    data: XOR<FreelancerEvaluationUpdateInput, FreelancerEvaluationUncheckedUpdateInput>
    /**
     * Choose, which FreelancerEvaluation to update.
     */
    where: FreelancerEvaluationWhereUniqueInput
  }

  /**
   * FreelancerEvaluation updateMany
   */
  export type FreelancerEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelancerEvaluations.
     */
    data: XOR<FreelancerEvaluationUpdateManyMutationInput, FreelancerEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which FreelancerEvaluations to update
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * Limit how many FreelancerEvaluations to update.
     */
    limit?: number
  }

  /**
   * FreelancerEvaluation updateManyAndReturn
   */
  export type FreelancerEvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * The data used to update FreelancerEvaluations.
     */
    data: XOR<FreelancerEvaluationUpdateManyMutationInput, FreelancerEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which FreelancerEvaluations to update
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * Limit how many FreelancerEvaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelancerEvaluation upsert
   */
  export type FreelancerEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelancerEvaluation to update in case it exists.
     */
    where: FreelancerEvaluationWhereUniqueInput
    /**
     * In case the FreelancerEvaluation found by the `where` argument doesn't exist, create a new FreelancerEvaluation with this data.
     */
    create: XOR<FreelancerEvaluationCreateInput, FreelancerEvaluationUncheckedCreateInput>
    /**
     * In case the FreelancerEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelancerEvaluationUpdateInput, FreelancerEvaluationUncheckedUpdateInput>
  }

  /**
   * FreelancerEvaluation delete
   */
  export type FreelancerEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
    /**
     * Filter which FreelancerEvaluation to delete.
     */
    where: FreelancerEvaluationWhereUniqueInput
  }

  /**
   * FreelancerEvaluation deleteMany
   */
  export type FreelancerEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelancerEvaluations to delete
     */
    where?: FreelancerEvaluationWhereInput
    /**
     * Limit how many FreelancerEvaluations to delete.
     */
    limit?: number
  }

  /**
   * FreelancerEvaluation without action
   */
  export type FreelancerEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelancerEvaluation
     */
    select?: FreelancerEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelancerEvaluation
     */
    omit?: FreelancerEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelancerEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Quotation
   */

  export type AggregateQuotation = {
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  export type QuotationAvgAggregateOutputType = {
    ammount: number | null
  }

  export type QuotationSumAggregateOutputType = {
    ammount: number | null
  }

  export type QuotationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    ammount: number | null
    description: string | null
    createdAt: Date | null
  }

  export type QuotationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    ammount: number | null
    description: string | null
    createdAt: Date | null
  }

  export type QuotationCountAggregateOutputType = {
    id: number
    projectId: number
    ammount: number
    description: number
    createdAt: number
    _all: number
  }


  export type QuotationAvgAggregateInputType = {
    ammount?: true
  }

  export type QuotationSumAggregateInputType = {
    ammount?: true
  }

  export type QuotationMinAggregateInputType = {
    id?: true
    projectId?: true
    ammount?: true
    description?: true
    createdAt?: true
  }

  export type QuotationMaxAggregateInputType = {
    id?: true
    projectId?: true
    ammount?: true
    description?: true
    createdAt?: true
  }

  export type QuotationCountAggregateInputType = {
    id?: true
    projectId?: true
    ammount?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type QuotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotation to aggregate.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotations
    **/
    _count?: true | QuotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotationMaxAggregateInputType
  }

  export type GetQuotationAggregateType<T extends QuotationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotation[P]>
      : GetScalarType<T[P], AggregateQuotation[P]>
  }




  export type QuotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotationWhereInput
    orderBy?: QuotationOrderByWithAggregationInput | QuotationOrderByWithAggregationInput[]
    by: QuotationScalarFieldEnum[] | QuotationScalarFieldEnum
    having?: QuotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotationCountAggregateInputType | true
    _avg?: QuotationAvgAggregateInputType
    _sum?: QuotationSumAggregateInputType
    _min?: QuotationMinAggregateInputType
    _max?: QuotationMaxAggregateInputType
  }

  export type QuotationGroupByOutputType = {
    id: string
    projectId: string
    ammount: number
    description: string | null
    createdAt: Date
    _count: QuotationCountAggregateOutputType | null
    _avg: QuotationAvgAggregateOutputType | null
    _sum: QuotationSumAggregateOutputType | null
    _min: QuotationMinAggregateOutputType | null
    _max: QuotationMaxAggregateOutputType | null
  }

  type GetQuotationGroupByPayload<T extends QuotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotationGroupByOutputType[P]>
            : GetScalarType<T[P], QuotationGroupByOutputType[P]>
        }
      >
    >


  export type QuotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    ammount?: boolean
    description?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    ammount?: boolean
    description?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    ammount?: boolean
    description?: boolean
    createdAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotation"]>

  export type QuotationSelectScalar = {
    id?: boolean
    projectId?: boolean
    ammount?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type QuotationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "ammount" | "description" | "createdAt", ExtArgs["result"]["quotation"]>
  export type QuotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type QuotationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $QuotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quotation"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      ammount: number
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["quotation"]>
    composites: {}
  }

  type QuotationGetPayload<S extends boolean | null | undefined | QuotationDefaultArgs> = $Result.GetResult<Prisma.$QuotationPayload, S>

  type QuotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotationCountAggregateInputType | true
    }

  export interface QuotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quotation'], meta: { name: 'Quotation' } }
    /**
     * Find zero or one Quotation that matches the filter.
     * @param {QuotationFindUniqueArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotationFindUniqueArgs>(args: SelectSubset<T, QuotationFindUniqueArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotationFindUniqueOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotationFindFirstArgs>(args?: SelectSubset<T, QuotationFindFirstArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindFirstOrThrowArgs} args - Arguments to find a Quotation
     * @example
     * // Get one Quotation
     * const quotation = await prisma.quotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotations
     * const quotations = await prisma.quotation.findMany()
     * 
     * // Get first 10 Quotations
     * const quotations = await prisma.quotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotationWithIdOnly = await prisma.quotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotationFindManyArgs>(args?: SelectSubset<T, QuotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotation.
     * @param {QuotationCreateArgs} args - Arguments to create a Quotation.
     * @example
     * // Create one Quotation
     * const Quotation = await prisma.quotation.create({
     *   data: {
     *     // ... data to create a Quotation
     *   }
     * })
     * 
     */
    create<T extends QuotationCreateArgs>(args: SelectSubset<T, QuotationCreateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotations.
     * @param {QuotationCreateManyArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotationCreateManyArgs>(args?: SelectSubset<T, QuotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotations and returns the data saved in the database.
     * @param {QuotationCreateManyAndReturnArgs} args - Arguments to create many Quotations.
     * @example
     * // Create many Quotations
     * const quotation = await prisma.quotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quotation.
     * @param {QuotationDeleteArgs} args - Arguments to delete one Quotation.
     * @example
     * // Delete one Quotation
     * const Quotation = await prisma.quotation.delete({
     *   where: {
     *     // ... filter to delete one Quotation
     *   }
     * })
     * 
     */
    delete<T extends QuotationDeleteArgs>(args: SelectSubset<T, QuotationDeleteArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotation.
     * @param {QuotationUpdateArgs} args - Arguments to update one Quotation.
     * @example
     * // Update one Quotation
     * const quotation = await prisma.quotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotationUpdateArgs>(args: SelectSubset<T, QuotationUpdateArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotations.
     * @param {QuotationDeleteManyArgs} args - Arguments to filter Quotations to delete.
     * @example
     * // Delete a few Quotations
     * const { count } = await prisma.quotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotationDeleteManyArgs>(args?: SelectSubset<T, QuotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotationUpdateManyArgs>(args: SelectSubset<T, QuotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotations and returns the data updated in the database.
     * @param {QuotationUpdateManyAndReturnArgs} args - Arguments to update many Quotations.
     * @example
     * // Update many Quotations
     * const quotation = await prisma.quotation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotations and only return the `id`
     * const quotationWithIdOnly = await prisma.quotation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotationUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quotation.
     * @param {QuotationUpsertArgs} args - Arguments to update or create a Quotation.
     * @example
     * // Update or create a Quotation
     * const quotation = await prisma.quotation.upsert({
     *   create: {
     *     // ... data to create a Quotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotation we want to update
     *   }
     * })
     */
    upsert<T extends QuotationUpsertArgs>(args: SelectSubset<T, QuotationUpsertArgs<ExtArgs>>): Prisma__QuotationClient<$Result.GetResult<Prisma.$QuotationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationCountArgs} args - Arguments to filter Quotations to count.
     * @example
     * // Count the number of Quotations
     * const count = await prisma.quotation.count({
     *   where: {
     *     // ... the filter for the Quotations we want to count
     *   }
     * })
    **/
    count<T extends QuotationCountArgs>(
      args?: Subset<T, QuotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotationAggregateArgs>(args: Subset<T, QuotationAggregateArgs>): Prisma.PrismaPromise<GetQuotationAggregateType<T>>

    /**
     * Group by Quotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotationGroupByArgs['orderBy'] }
        : { orderBy?: QuotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quotation model
   */
  readonly fields: QuotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quotation model
   */
  interface QuotationFieldRefs {
    readonly id: FieldRef<"Quotation", 'String'>
    readonly projectId: FieldRef<"Quotation", 'String'>
    readonly ammount: FieldRef<"Quotation", 'Int'>
    readonly description: FieldRef<"Quotation", 'String'>
    readonly createdAt: FieldRef<"Quotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quotation findUnique
   */
  export type QuotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findUniqueOrThrow
   */
  export type QuotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation findFirst
   */
  export type QuotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findFirstOrThrow
   */
  export type QuotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotation to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotations.
     */
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation findMany
   */
  export type QuotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter, which Quotations to fetch.
     */
    where?: QuotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotations to fetch.
     */
    orderBy?: QuotationOrderByWithRelationInput | QuotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotations.
     */
    cursor?: QuotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotations.
     */
    skip?: number
    distinct?: QuotationScalarFieldEnum | QuotationScalarFieldEnum[]
  }

  /**
   * Quotation create
   */
  export type QuotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to create a Quotation.
     */
    data: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
  }

  /**
   * Quotation createMany
   */
  export type QuotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quotation createManyAndReturn
   */
  export type QuotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to create many Quotations.
     */
    data: QuotationCreateManyInput | QuotationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation update
   */
  export type QuotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The data needed to update a Quotation.
     */
    data: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
    /**
     * Choose, which Quotation to update.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation updateMany
   */
  export type QuotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
  }

  /**
   * Quotation updateManyAndReturn
   */
  export type QuotationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * The data used to update Quotations.
     */
    data: XOR<QuotationUpdateManyMutationInput, QuotationUncheckedUpdateManyInput>
    /**
     * Filter which Quotations to update
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quotation upsert
   */
  export type QuotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * The filter to search for the Quotation to update in case it exists.
     */
    where: QuotationWhereUniqueInput
    /**
     * In case the Quotation found by the `where` argument doesn't exist, create a new Quotation with this data.
     */
    create: XOR<QuotationCreateInput, QuotationUncheckedCreateInput>
    /**
     * In case the Quotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotationUpdateInput, QuotationUncheckedUpdateInput>
  }

  /**
   * Quotation delete
   */
  export type QuotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
    /**
     * Filter which Quotation to delete.
     */
    where: QuotationWhereUniqueInput
  }

  /**
   * Quotation deleteMany
   */
  export type QuotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotations to delete
     */
    where?: QuotationWhereInput
    /**
     * Limit how many Quotations to delete.
     */
    limit?: number
  }

  /**
   * Quotation without action
   */
  export type QuotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quotation
     */
    select?: QuotationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quotation
     */
    omit?: QuotationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotationInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    projectId: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    projectId?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    projectId: string | null
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    members?: boolean | Conversation$membersArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    project?: boolean | Conversation$projectArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    project?: boolean | Conversation$projectArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    project?: boolean | Conversation$projectArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    projectId?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Conversation$membersArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    project?: boolean | Conversation$projectArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Conversation$projectArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | Conversation$projectArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      members: Prisma.$UserPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string | null
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Conversation$membersArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project<T extends Conversation$projectArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly projectId: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data?: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.members
   */
  export type Conversation$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation.project
   */
  export type Conversation$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
    conversationId: string | null
    saw: boolean | null
    hasFile: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
    conversationId: string | null
    saw: boolean | null
    hasFile: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    content: number
    createdAt: number
    conversationId: number
    saw: number
    hasFile: number
    fileInfo: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    content?: true
    createdAt?: true
    conversationId?: true
    saw?: true
    hasFile?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    content?: true
    createdAt?: true
    conversationId?: true
    saw?: true
    hasFile?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    content?: true
    createdAt?: true
    conversationId?: true
    saw?: true
    hasFile?: true
    fileInfo?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    content: string
    createdAt: Date
    conversationId: string
    saw: boolean
    hasFile: boolean
    fileInfo: JsonValue | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    conversationId?: boolean
    saw?: boolean
    hasFile?: boolean
    fileInfo?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    conversationId?: boolean
    saw?: boolean
    hasFile?: boolean
    fileInfo?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    conversationId?: boolean
    saw?: boolean
    hasFile?: boolean
    fileInfo?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    conversationId?: boolean
    saw?: boolean
    hasFile?: boolean
    fileInfo?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "senderId" | "content" | "createdAt" | "conversationId" | "saw" | "hasFile" | "fileInfo", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      content: string
      createdAt: Date
      conversationId: string
      saw: boolean
      hasFile: boolean
      fileInfo: Prisma.JsonValue | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly saw: FieldRef<"Message", 'Boolean'>
    readonly hasFile: FieldRef<"Message", 'Boolean'>
    readonly fileInfo: FieldRef<"Message", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Portifolio
   */

  export type AggregatePortifolio = {
    _count: PortifolioCountAggregateOutputType | null
    _min: PortifolioMinAggregateOutputType | null
    _max: PortifolioMaxAggregateOutputType | null
  }

  export type PortifolioMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    cover: string | null
    completedAt: string | null
    tolinerId: string | null
  }

  export type PortifolioMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    cover: string | null
    completedAt: string | null
    tolinerId: string | null
  }

  export type PortifolioCountAggregateOutputType = {
    id: number
    title: number
    description: number
    cover: number
    completedAt: number
    assets: number
    tolinerId: number
    _all: number
  }


  export type PortifolioMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    cover?: true
    completedAt?: true
    tolinerId?: true
  }

  export type PortifolioMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    cover?: true
    completedAt?: true
    tolinerId?: true
  }

  export type PortifolioCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    cover?: true
    completedAt?: true
    assets?: true
    tolinerId?: true
    _all?: true
  }

  export type PortifolioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portifolio to aggregate.
     */
    where?: PortifolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portifolios to fetch.
     */
    orderBy?: PortifolioOrderByWithRelationInput | PortifolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortifolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portifolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portifolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Portifolios
    **/
    _count?: true | PortifolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortifolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortifolioMaxAggregateInputType
  }

  export type GetPortifolioAggregateType<T extends PortifolioAggregateArgs> = {
        [P in keyof T & keyof AggregatePortifolio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortifolio[P]>
      : GetScalarType<T[P], AggregatePortifolio[P]>
  }




  export type PortifolioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortifolioWhereInput
    orderBy?: PortifolioOrderByWithAggregationInput | PortifolioOrderByWithAggregationInput[]
    by: PortifolioScalarFieldEnum[] | PortifolioScalarFieldEnum
    having?: PortifolioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortifolioCountAggregateInputType | true
    _min?: PortifolioMinAggregateInputType
    _max?: PortifolioMaxAggregateInputType
  }

  export type PortifolioGroupByOutputType = {
    id: string
    title: string
    description: string
    cover: string
    completedAt: string | null
    assets: JsonValue
    tolinerId: string | null
    _count: PortifolioCountAggregateOutputType | null
    _min: PortifolioMinAggregateOutputType | null
    _max: PortifolioMaxAggregateOutputType | null
  }

  type GetPortifolioGroupByPayload<T extends PortifolioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortifolioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortifolioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortifolioGroupByOutputType[P]>
            : GetScalarType<T[P], PortifolioGroupByOutputType[P]>
        }
      >
    >


  export type PortifolioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    cover?: boolean
    completedAt?: boolean
    assets?: boolean
    tolinerId?: boolean
    skills?: boolean | Portifolio$skillsArgs<ExtArgs>
    toliner?: boolean | Portifolio$tolinerArgs<ExtArgs>
    _count?: boolean | PortifolioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portifolio"]>

  export type PortifolioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    cover?: boolean
    completedAt?: boolean
    assets?: boolean
    tolinerId?: boolean
    toliner?: boolean | Portifolio$tolinerArgs<ExtArgs>
  }, ExtArgs["result"]["portifolio"]>

  export type PortifolioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    cover?: boolean
    completedAt?: boolean
    assets?: boolean
    tolinerId?: boolean
    toliner?: boolean | Portifolio$tolinerArgs<ExtArgs>
  }, ExtArgs["result"]["portifolio"]>

  export type PortifolioSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    cover?: boolean
    completedAt?: boolean
    assets?: boolean
    tolinerId?: boolean
  }

  export type PortifolioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "cover" | "completedAt" | "assets" | "tolinerId", ExtArgs["result"]["portifolio"]>
  export type PortifolioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | Portifolio$skillsArgs<ExtArgs>
    toliner?: boolean | Portifolio$tolinerArgs<ExtArgs>
    _count?: boolean | PortifolioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortifolioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | Portifolio$tolinerArgs<ExtArgs>
  }
  export type PortifolioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | Portifolio$tolinerArgs<ExtArgs>
  }

  export type $PortifolioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Portifolio"
    objects: {
      skills: Prisma.$SkillPayload<ExtArgs>[]
      toliner: Prisma.$TolinerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      cover: string
      completedAt: string | null
      assets: Prisma.JsonValue
      tolinerId: string | null
    }, ExtArgs["result"]["portifolio"]>
    composites: {}
  }

  type PortifolioGetPayload<S extends boolean | null | undefined | PortifolioDefaultArgs> = $Result.GetResult<Prisma.$PortifolioPayload, S>

  type PortifolioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortifolioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortifolioCountAggregateInputType | true
    }

  export interface PortifolioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Portifolio'], meta: { name: 'Portifolio' } }
    /**
     * Find zero or one Portifolio that matches the filter.
     * @param {PortifolioFindUniqueArgs} args - Arguments to find a Portifolio
     * @example
     * // Get one Portifolio
     * const portifolio = await prisma.portifolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortifolioFindUniqueArgs>(args: SelectSubset<T, PortifolioFindUniqueArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Portifolio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortifolioFindUniqueOrThrowArgs} args - Arguments to find a Portifolio
     * @example
     * // Get one Portifolio
     * const portifolio = await prisma.portifolio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortifolioFindUniqueOrThrowArgs>(args: SelectSubset<T, PortifolioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portifolio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioFindFirstArgs} args - Arguments to find a Portifolio
     * @example
     * // Get one Portifolio
     * const portifolio = await prisma.portifolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortifolioFindFirstArgs>(args?: SelectSubset<T, PortifolioFindFirstArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Portifolio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioFindFirstOrThrowArgs} args - Arguments to find a Portifolio
     * @example
     * // Get one Portifolio
     * const portifolio = await prisma.portifolio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortifolioFindFirstOrThrowArgs>(args?: SelectSubset<T, PortifolioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Portifolios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Portifolios
     * const portifolios = await prisma.portifolio.findMany()
     * 
     * // Get first 10 Portifolios
     * const portifolios = await prisma.portifolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portifolioWithIdOnly = await prisma.portifolio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortifolioFindManyArgs>(args?: SelectSubset<T, PortifolioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Portifolio.
     * @param {PortifolioCreateArgs} args - Arguments to create a Portifolio.
     * @example
     * // Create one Portifolio
     * const Portifolio = await prisma.portifolio.create({
     *   data: {
     *     // ... data to create a Portifolio
     *   }
     * })
     * 
     */
    create<T extends PortifolioCreateArgs>(args: SelectSubset<T, PortifolioCreateArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Portifolios.
     * @param {PortifolioCreateManyArgs} args - Arguments to create many Portifolios.
     * @example
     * // Create many Portifolios
     * const portifolio = await prisma.portifolio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortifolioCreateManyArgs>(args?: SelectSubset<T, PortifolioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Portifolios and returns the data saved in the database.
     * @param {PortifolioCreateManyAndReturnArgs} args - Arguments to create many Portifolios.
     * @example
     * // Create many Portifolios
     * const portifolio = await prisma.portifolio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Portifolios and only return the `id`
     * const portifolioWithIdOnly = await prisma.portifolio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortifolioCreateManyAndReturnArgs>(args?: SelectSubset<T, PortifolioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Portifolio.
     * @param {PortifolioDeleteArgs} args - Arguments to delete one Portifolio.
     * @example
     * // Delete one Portifolio
     * const Portifolio = await prisma.portifolio.delete({
     *   where: {
     *     // ... filter to delete one Portifolio
     *   }
     * })
     * 
     */
    delete<T extends PortifolioDeleteArgs>(args: SelectSubset<T, PortifolioDeleteArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Portifolio.
     * @param {PortifolioUpdateArgs} args - Arguments to update one Portifolio.
     * @example
     * // Update one Portifolio
     * const portifolio = await prisma.portifolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortifolioUpdateArgs>(args: SelectSubset<T, PortifolioUpdateArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Portifolios.
     * @param {PortifolioDeleteManyArgs} args - Arguments to filter Portifolios to delete.
     * @example
     * // Delete a few Portifolios
     * const { count } = await prisma.portifolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortifolioDeleteManyArgs>(args?: SelectSubset<T, PortifolioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portifolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Portifolios
     * const portifolio = await prisma.portifolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortifolioUpdateManyArgs>(args: SelectSubset<T, PortifolioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Portifolios and returns the data updated in the database.
     * @param {PortifolioUpdateManyAndReturnArgs} args - Arguments to update many Portifolios.
     * @example
     * // Update many Portifolios
     * const portifolio = await prisma.portifolio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Portifolios and only return the `id`
     * const portifolioWithIdOnly = await prisma.portifolio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortifolioUpdateManyAndReturnArgs>(args: SelectSubset<T, PortifolioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Portifolio.
     * @param {PortifolioUpsertArgs} args - Arguments to update or create a Portifolio.
     * @example
     * // Update or create a Portifolio
     * const portifolio = await prisma.portifolio.upsert({
     *   create: {
     *     // ... data to create a Portifolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Portifolio we want to update
     *   }
     * })
     */
    upsert<T extends PortifolioUpsertArgs>(args: SelectSubset<T, PortifolioUpsertArgs<ExtArgs>>): Prisma__PortifolioClient<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Portifolios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioCountArgs} args - Arguments to filter Portifolios to count.
     * @example
     * // Count the number of Portifolios
     * const count = await prisma.portifolio.count({
     *   where: {
     *     // ... the filter for the Portifolios we want to count
     *   }
     * })
    **/
    count<T extends PortifolioCountArgs>(
      args?: Subset<T, PortifolioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortifolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Portifolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortifolioAggregateArgs>(args: Subset<T, PortifolioAggregateArgs>): Prisma.PrismaPromise<GetPortifolioAggregateType<T>>

    /**
     * Group by Portifolio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortifolioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortifolioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortifolioGroupByArgs['orderBy'] }
        : { orderBy?: PortifolioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortifolioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortifolioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Portifolio model
   */
  readonly fields: PortifolioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Portifolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortifolioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends Portifolio$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Portifolio$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    toliner<T extends Portifolio$tolinerArgs<ExtArgs> = {}>(args?: Subset<T, Portifolio$tolinerArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Portifolio model
   */
  interface PortifolioFieldRefs {
    readonly id: FieldRef<"Portifolio", 'String'>
    readonly title: FieldRef<"Portifolio", 'String'>
    readonly description: FieldRef<"Portifolio", 'String'>
    readonly cover: FieldRef<"Portifolio", 'String'>
    readonly completedAt: FieldRef<"Portifolio", 'String'>
    readonly assets: FieldRef<"Portifolio", 'Json'>
    readonly tolinerId: FieldRef<"Portifolio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Portifolio findUnique
   */
  export type PortifolioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * Filter, which Portifolio to fetch.
     */
    where: PortifolioWhereUniqueInput
  }

  /**
   * Portifolio findUniqueOrThrow
   */
  export type PortifolioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * Filter, which Portifolio to fetch.
     */
    where: PortifolioWhereUniqueInput
  }

  /**
   * Portifolio findFirst
   */
  export type PortifolioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * Filter, which Portifolio to fetch.
     */
    where?: PortifolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portifolios to fetch.
     */
    orderBy?: PortifolioOrderByWithRelationInput | PortifolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portifolios.
     */
    cursor?: PortifolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portifolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portifolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portifolios.
     */
    distinct?: PortifolioScalarFieldEnum | PortifolioScalarFieldEnum[]
  }

  /**
   * Portifolio findFirstOrThrow
   */
  export type PortifolioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * Filter, which Portifolio to fetch.
     */
    where?: PortifolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portifolios to fetch.
     */
    orderBy?: PortifolioOrderByWithRelationInput | PortifolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Portifolios.
     */
    cursor?: PortifolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portifolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portifolios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Portifolios.
     */
    distinct?: PortifolioScalarFieldEnum | PortifolioScalarFieldEnum[]
  }

  /**
   * Portifolio findMany
   */
  export type PortifolioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * Filter, which Portifolios to fetch.
     */
    where?: PortifolioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Portifolios to fetch.
     */
    orderBy?: PortifolioOrderByWithRelationInput | PortifolioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Portifolios.
     */
    cursor?: PortifolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Portifolios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Portifolios.
     */
    skip?: number
    distinct?: PortifolioScalarFieldEnum | PortifolioScalarFieldEnum[]
  }

  /**
   * Portifolio create
   */
  export type PortifolioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * The data needed to create a Portifolio.
     */
    data: XOR<PortifolioCreateInput, PortifolioUncheckedCreateInput>
  }

  /**
   * Portifolio createMany
   */
  export type PortifolioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Portifolios.
     */
    data: PortifolioCreateManyInput | PortifolioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Portifolio createManyAndReturn
   */
  export type PortifolioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * The data used to create many Portifolios.
     */
    data: PortifolioCreateManyInput | PortifolioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portifolio update
   */
  export type PortifolioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * The data needed to update a Portifolio.
     */
    data: XOR<PortifolioUpdateInput, PortifolioUncheckedUpdateInput>
    /**
     * Choose, which Portifolio to update.
     */
    where: PortifolioWhereUniqueInput
  }

  /**
   * Portifolio updateMany
   */
  export type PortifolioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Portifolios.
     */
    data: XOR<PortifolioUpdateManyMutationInput, PortifolioUncheckedUpdateManyInput>
    /**
     * Filter which Portifolios to update
     */
    where?: PortifolioWhereInput
    /**
     * Limit how many Portifolios to update.
     */
    limit?: number
  }

  /**
   * Portifolio updateManyAndReturn
   */
  export type PortifolioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * The data used to update Portifolios.
     */
    data: XOR<PortifolioUpdateManyMutationInput, PortifolioUncheckedUpdateManyInput>
    /**
     * Filter which Portifolios to update
     */
    where?: PortifolioWhereInput
    /**
     * Limit how many Portifolios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Portifolio upsert
   */
  export type PortifolioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * The filter to search for the Portifolio to update in case it exists.
     */
    where: PortifolioWhereUniqueInput
    /**
     * In case the Portifolio found by the `where` argument doesn't exist, create a new Portifolio with this data.
     */
    create: XOR<PortifolioCreateInput, PortifolioUncheckedCreateInput>
    /**
     * In case the Portifolio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortifolioUpdateInput, PortifolioUncheckedUpdateInput>
  }

  /**
   * Portifolio delete
   */
  export type PortifolioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    /**
     * Filter which Portifolio to delete.
     */
    where: PortifolioWhereUniqueInput
  }

  /**
   * Portifolio deleteMany
   */
  export type PortifolioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Portifolios to delete
     */
    where?: PortifolioWhereInput
    /**
     * Limit how many Portifolios to delete.
     */
    limit?: number
  }

  /**
   * Portifolio.skills
   */
  export type Portifolio$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Portifolio.toliner
   */
  export type Portifolio$tolinerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    where?: TolinerWhereInput
  }

  /**
   * Portifolio without action
   */
  export type PortifolioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    ammount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    ammount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    ammount: number | null
    createdAt: Date | null
    clientInvoice: string | null
    systemInvoice: string | null
    isVerified: boolean | null
    projectId: string | null
    completedAt: Date | null
    tolinerId: string | null
    status: $Enums.PaymentStatus | null
    freelancerId: string | null
    paymentMethod: string | null
    referenceNumber: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    ammount: number | null
    createdAt: Date | null
    clientInvoice: string | null
    systemInvoice: string | null
    isVerified: boolean | null
    projectId: string | null
    completedAt: Date | null
    tolinerId: string | null
    status: $Enums.PaymentStatus | null
    freelancerId: string | null
    paymentMethod: string | null
    referenceNumber: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    ammount: number
    createdAt: number
    clientInvoice: number
    systemInvoice: number
    isVerified: number
    projectId: number
    completedAt: number
    tolinerId: number
    status: number
    freelancerId: number
    paymentMethod: number
    referenceNumber: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    ammount?: true
  }

  export type PaymentSumAggregateInputType = {
    ammount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    ammount?: true
    createdAt?: true
    clientInvoice?: true
    systemInvoice?: true
    isVerified?: true
    projectId?: true
    completedAt?: true
    tolinerId?: true
    status?: true
    freelancerId?: true
    paymentMethod?: true
    referenceNumber?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    ammount?: true
    createdAt?: true
    clientInvoice?: true
    systemInvoice?: true
    isVerified?: true
    projectId?: true
    completedAt?: true
    tolinerId?: true
    status?: true
    freelancerId?: true
    paymentMethod?: true
    referenceNumber?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    ammount?: true
    createdAt?: true
    clientInvoice?: true
    systemInvoice?: true
    isVerified?: true
    projectId?: true
    completedAt?: true
    tolinerId?: true
    status?: true
    freelancerId?: true
    paymentMethod?: true
    referenceNumber?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    ammount: number
    createdAt: Date
    clientInvoice: string | null
    systemInvoice: string | null
    isVerified: boolean
    projectId: string
    completedAt: Date | null
    tolinerId: string
    status: $Enums.PaymentStatus
    freelancerId: string
    paymentMethod: string | null
    referenceNumber: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    clientInvoice?: boolean
    systemInvoice?: boolean
    isVerified?: boolean
    projectId?: boolean
    completedAt?: boolean
    tolinerId?: boolean
    status?: boolean
    freelancerId?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    clientInvoice?: boolean
    systemInvoice?: boolean
    isVerified?: boolean
    projectId?: boolean
    completedAt?: boolean
    tolinerId?: boolean
    status?: boolean
    freelancerId?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    clientInvoice?: boolean
    systemInvoice?: boolean
    isVerified?: boolean
    projectId?: boolean
    completedAt?: boolean
    tolinerId?: boolean
    status?: boolean
    freelancerId?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    clientInvoice?: boolean
    systemInvoice?: boolean
    isVerified?: boolean
    projectId?: boolean
    completedAt?: boolean
    tolinerId?: boolean
    status?: boolean
    freelancerId?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ammount" | "createdAt" | "clientInvoice" | "systemInvoice" | "isVerified" | "projectId" | "completedAt" | "tolinerId" | "status" | "freelancerId" | "paymentMethod" | "referenceNumber", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
    freelancer?: boolean | TolinerDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      toliner: Prisma.$TolinerPayload<ExtArgs>
      freelancer: Prisma.$TolinerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ammount: number
      createdAt: Date
      clientInvoice: string | null
      systemInvoice: string | null
      isVerified: boolean
      projectId: string
      completedAt: Date | null
      tolinerId: string
      status: $Enums.PaymentStatus
      freelancerId: string
      paymentMethod: string | null
      referenceNumber: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toliner<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    freelancer<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly ammount: FieldRef<"Payment", 'Float'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly clientInvoice: FieldRef<"Payment", 'String'>
    readonly systemInvoice: FieldRef<"Payment", 'String'>
    readonly isVerified: FieldRef<"Payment", 'Boolean'>
    readonly projectId: FieldRef<"Payment", 'String'>
    readonly completedAt: FieldRef<"Payment", 'DateTime'>
    readonly tolinerId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly freelancerId: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly referenceNumber: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Charge
   */

  export type AggregateCharge = {
    _count: ChargeCountAggregateOutputType | null
    _avg: ChargeAvgAggregateOutputType | null
    _sum: ChargeSumAggregateOutputType | null
    _min: ChargeMinAggregateOutputType | null
    _max: ChargeMaxAggregateOutputType | null
  }

  export type ChargeAvgAggregateOutputType = {
    ammount: number | null
  }

  export type ChargeSumAggregateOutputType = {
    ammount: number | null
  }

  export type ChargeMinAggregateOutputType = {
    id: string | null
    ammount: number | null
    createdAt: Date | null
    isVerified: boolean | null
    invoice: string | null
    updatedAt: Date | null
    referenceNumber: string | null
    status: $Enums.ChargeStatus | null
    tolinerId: string | null
  }

  export type ChargeMaxAggregateOutputType = {
    id: string | null
    ammount: number | null
    createdAt: Date | null
    isVerified: boolean | null
    invoice: string | null
    updatedAt: Date | null
    referenceNumber: string | null
    status: $Enums.ChargeStatus | null
    tolinerId: string | null
  }

  export type ChargeCountAggregateOutputType = {
    id: number
    ammount: number
    createdAt: number
    isVerified: number
    invoice: number
    updatedAt: number
    referenceNumber: number
    status: number
    tolinerId: number
    _all: number
  }


  export type ChargeAvgAggregateInputType = {
    ammount?: true
  }

  export type ChargeSumAggregateInputType = {
    ammount?: true
  }

  export type ChargeMinAggregateInputType = {
    id?: true
    ammount?: true
    createdAt?: true
    isVerified?: true
    invoice?: true
    updatedAt?: true
    referenceNumber?: true
    status?: true
    tolinerId?: true
  }

  export type ChargeMaxAggregateInputType = {
    id?: true
    ammount?: true
    createdAt?: true
    isVerified?: true
    invoice?: true
    updatedAt?: true
    referenceNumber?: true
    status?: true
    tolinerId?: true
  }

  export type ChargeCountAggregateInputType = {
    id?: true
    ammount?: true
    createdAt?: true
    isVerified?: true
    invoice?: true
    updatedAt?: true
    referenceNumber?: true
    status?: true
    tolinerId?: true
    _all?: true
  }

  export type ChargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charge to aggregate.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Charges
    **/
    _count?: true | ChargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChargeMaxAggregateInputType
  }

  export type GetChargeAggregateType<T extends ChargeAggregateArgs> = {
        [P in keyof T & keyof AggregateCharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharge[P]>
      : GetScalarType<T[P], AggregateCharge[P]>
  }




  export type ChargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChargeWhereInput
    orderBy?: ChargeOrderByWithAggregationInput | ChargeOrderByWithAggregationInput[]
    by: ChargeScalarFieldEnum[] | ChargeScalarFieldEnum
    having?: ChargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChargeCountAggregateInputType | true
    _avg?: ChargeAvgAggregateInputType
    _sum?: ChargeSumAggregateInputType
    _min?: ChargeMinAggregateInputType
    _max?: ChargeMaxAggregateInputType
  }

  export type ChargeGroupByOutputType = {
    id: string
    ammount: number
    createdAt: Date
    isVerified: boolean
    invoice: string
    updatedAt: Date
    referenceNumber: string | null
    status: $Enums.ChargeStatus
    tolinerId: string
    _count: ChargeCountAggregateOutputType | null
    _avg: ChargeAvgAggregateOutputType | null
    _sum: ChargeSumAggregateOutputType | null
    _min: ChargeMinAggregateOutputType | null
    _max: ChargeMaxAggregateOutputType | null
  }

  type GetChargeGroupByPayload<T extends ChargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChargeGroupByOutputType[P]>
            : GetScalarType<T[P], ChargeGroupByOutputType[P]>
        }
      >
    >


  export type ChargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    isVerified?: boolean
    invoice?: boolean
    updatedAt?: boolean
    referenceNumber?: boolean
    status?: boolean
    tolinerId?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charge"]>

  export type ChargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    isVerified?: boolean
    invoice?: boolean
    updatedAt?: boolean
    referenceNumber?: boolean
    status?: boolean
    tolinerId?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charge"]>

  export type ChargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    isVerified?: boolean
    invoice?: boolean
    updatedAt?: boolean
    referenceNumber?: boolean
    status?: boolean
    tolinerId?: boolean
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charge"]>

  export type ChargeSelectScalar = {
    id?: boolean
    ammount?: boolean
    createdAt?: boolean
    isVerified?: boolean
    invoice?: boolean
    updatedAt?: boolean
    referenceNumber?: boolean
    status?: boolean
    tolinerId?: boolean
  }

  export type ChargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ammount" | "createdAt" | "isVerified" | "invoice" | "updatedAt" | "referenceNumber" | "status" | "tolinerId", ExtArgs["result"]["charge"]>
  export type ChargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type ChargeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }
  export type ChargeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | TolinerDefaultArgs<ExtArgs>
  }

  export type $ChargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Charge"
    objects: {
      toliner: Prisma.$TolinerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ammount: number
      createdAt: Date
      isVerified: boolean
      invoice: string
      updatedAt: Date
      referenceNumber: string | null
      status: $Enums.ChargeStatus
      tolinerId: string
    }, ExtArgs["result"]["charge"]>
    composites: {}
  }

  type ChargeGetPayload<S extends boolean | null | undefined | ChargeDefaultArgs> = $Result.GetResult<Prisma.$ChargePayload, S>

  type ChargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChargeCountAggregateInputType | true
    }

  export interface ChargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Charge'], meta: { name: 'Charge' } }
    /**
     * Find zero or one Charge that matches the filter.
     * @param {ChargeFindUniqueArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChargeFindUniqueArgs>(args: SelectSubset<T, ChargeFindUniqueArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Charge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChargeFindUniqueOrThrowArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChargeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Charge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeFindFirstArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChargeFindFirstArgs>(args?: SelectSubset<T, ChargeFindFirstArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Charge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeFindFirstOrThrowArgs} args - Arguments to find a Charge
     * @example
     * // Get one Charge
     * const charge = await prisma.charge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChargeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Charges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Charges
     * const charges = await prisma.charge.findMany()
     * 
     * // Get first 10 Charges
     * const charges = await prisma.charge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chargeWithIdOnly = await prisma.charge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChargeFindManyArgs>(args?: SelectSubset<T, ChargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Charge.
     * @param {ChargeCreateArgs} args - Arguments to create a Charge.
     * @example
     * // Create one Charge
     * const Charge = await prisma.charge.create({
     *   data: {
     *     // ... data to create a Charge
     *   }
     * })
     * 
     */
    create<T extends ChargeCreateArgs>(args: SelectSubset<T, ChargeCreateArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Charges.
     * @param {ChargeCreateManyArgs} args - Arguments to create many Charges.
     * @example
     * // Create many Charges
     * const charge = await prisma.charge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChargeCreateManyArgs>(args?: SelectSubset<T, ChargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Charges and returns the data saved in the database.
     * @param {ChargeCreateManyAndReturnArgs} args - Arguments to create many Charges.
     * @example
     * // Create many Charges
     * const charge = await prisma.charge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Charges and only return the `id`
     * const chargeWithIdOnly = await prisma.charge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChargeCreateManyAndReturnArgs>(args?: SelectSubset<T, ChargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Charge.
     * @param {ChargeDeleteArgs} args - Arguments to delete one Charge.
     * @example
     * // Delete one Charge
     * const Charge = await prisma.charge.delete({
     *   where: {
     *     // ... filter to delete one Charge
     *   }
     * })
     * 
     */
    delete<T extends ChargeDeleteArgs>(args: SelectSubset<T, ChargeDeleteArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Charge.
     * @param {ChargeUpdateArgs} args - Arguments to update one Charge.
     * @example
     * // Update one Charge
     * const charge = await prisma.charge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChargeUpdateArgs>(args: SelectSubset<T, ChargeUpdateArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Charges.
     * @param {ChargeDeleteManyArgs} args - Arguments to filter Charges to delete.
     * @example
     * // Delete a few Charges
     * const { count } = await prisma.charge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChargeDeleteManyArgs>(args?: SelectSubset<T, ChargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Charges
     * const charge = await prisma.charge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChargeUpdateManyArgs>(args: SelectSubset<T, ChargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charges and returns the data updated in the database.
     * @param {ChargeUpdateManyAndReturnArgs} args - Arguments to update many Charges.
     * @example
     * // Update many Charges
     * const charge = await prisma.charge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Charges and only return the `id`
     * const chargeWithIdOnly = await prisma.charge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChargeUpdateManyAndReturnArgs>(args: SelectSubset<T, ChargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Charge.
     * @param {ChargeUpsertArgs} args - Arguments to update or create a Charge.
     * @example
     * // Update or create a Charge
     * const charge = await prisma.charge.upsert({
     *   create: {
     *     // ... data to create a Charge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Charge we want to update
     *   }
     * })
     */
    upsert<T extends ChargeUpsertArgs>(args: SelectSubset<T, ChargeUpsertArgs<ExtArgs>>): Prisma__ChargeClient<$Result.GetResult<Prisma.$ChargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Charges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeCountArgs} args - Arguments to filter Charges to count.
     * @example
     * // Count the number of Charges
     * const count = await prisma.charge.count({
     *   where: {
     *     // ... the filter for the Charges we want to count
     *   }
     * })
    **/
    count<T extends ChargeCountArgs>(
      args?: Subset<T, ChargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Charge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChargeAggregateArgs>(args: Subset<T, ChargeAggregateArgs>): Prisma.PrismaPromise<GetChargeAggregateType<T>>

    /**
     * Group by Charge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChargeGroupByArgs['orderBy'] }
        : { orderBy?: ChargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Charge model
   */
  readonly fields: ChargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Charge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toliner<T extends TolinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TolinerDefaultArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Charge model
   */
  interface ChargeFieldRefs {
    readonly id: FieldRef<"Charge", 'String'>
    readonly ammount: FieldRef<"Charge", 'Float'>
    readonly createdAt: FieldRef<"Charge", 'DateTime'>
    readonly isVerified: FieldRef<"Charge", 'Boolean'>
    readonly invoice: FieldRef<"Charge", 'String'>
    readonly updatedAt: FieldRef<"Charge", 'DateTime'>
    readonly referenceNumber: FieldRef<"Charge", 'String'>
    readonly status: FieldRef<"Charge", 'ChargeStatus'>
    readonly tolinerId: FieldRef<"Charge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Charge findUnique
   */
  export type ChargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge findUniqueOrThrow
   */
  export type ChargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge findFirst
   */
  export type ChargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charges.
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charges.
     */
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Charge findFirstOrThrow
   */
  export type ChargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * Filter, which Charge to fetch.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charges.
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charges.
     */
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Charge findMany
   */
  export type ChargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * Filter, which Charges to fetch.
     */
    where?: ChargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charges to fetch.
     */
    orderBy?: ChargeOrderByWithRelationInput | ChargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Charges.
     */
    cursor?: ChargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charges.
     */
    skip?: number
    distinct?: ChargeScalarFieldEnum | ChargeScalarFieldEnum[]
  }

  /**
   * Charge create
   */
  export type ChargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * The data needed to create a Charge.
     */
    data: XOR<ChargeCreateInput, ChargeUncheckedCreateInput>
  }

  /**
   * Charge createMany
   */
  export type ChargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Charges.
     */
    data: ChargeCreateManyInput | ChargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Charge createManyAndReturn
   */
  export type ChargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The data used to create many Charges.
     */
    data: ChargeCreateManyInput | ChargeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Charge update
   */
  export type ChargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * The data needed to update a Charge.
     */
    data: XOR<ChargeUpdateInput, ChargeUncheckedUpdateInput>
    /**
     * Choose, which Charge to update.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge updateMany
   */
  export type ChargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Charges.
     */
    data: XOR<ChargeUpdateManyMutationInput, ChargeUncheckedUpdateManyInput>
    /**
     * Filter which Charges to update
     */
    where?: ChargeWhereInput
    /**
     * Limit how many Charges to update.
     */
    limit?: number
  }

  /**
   * Charge updateManyAndReturn
   */
  export type ChargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * The data used to update Charges.
     */
    data: XOR<ChargeUpdateManyMutationInput, ChargeUncheckedUpdateManyInput>
    /**
     * Filter which Charges to update
     */
    where?: ChargeWhereInput
    /**
     * Limit how many Charges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Charge upsert
   */
  export type ChargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * The filter to search for the Charge to update in case it exists.
     */
    where: ChargeWhereUniqueInput
    /**
     * In case the Charge found by the `where` argument doesn't exist, create a new Charge with this data.
     */
    create: XOR<ChargeCreateInput, ChargeUncheckedCreateInput>
    /**
     * In case the Charge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChargeUpdateInput, ChargeUncheckedUpdateInput>
  }

  /**
   * Charge delete
   */
  export type ChargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
    /**
     * Filter which Charge to delete.
     */
    where: ChargeWhereUniqueInput
  }

  /**
   * Charge deleteMany
   */
  export type ChargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charges to delete
     */
    where?: ChargeWhereInput
    /**
     * Limit how many Charges to delete.
     */
    limit?: number
  }

  /**
   * Charge without action
   */
  export type ChargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charge
     */
    select?: ChargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charge
     */
    omit?: ChargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChargeInclude<ExtArgs> | null
  }


  /**
   * Model Balance
   */

  export type AggregateBalance = {
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  export type BalanceAvgAggregateOutputType = {
    ammount: number | null
  }

  export type BalanceSumAggregateOutputType = {
    ammount: number | null
  }

  export type BalanceMinAggregateOutputType = {
    id: string | null
    ammount: number | null
    updatedAt: Date | null
    tolinerId: string | null
  }

  export type BalanceMaxAggregateOutputType = {
    id: string | null
    ammount: number | null
    updatedAt: Date | null
    tolinerId: string | null
  }

  export type BalanceCountAggregateOutputType = {
    id: number
    ammount: number
    updatedAt: number
    tolinerId: number
    _all: number
  }


  export type BalanceAvgAggregateInputType = {
    ammount?: true
  }

  export type BalanceSumAggregateInputType = {
    ammount?: true
  }

  export type BalanceMinAggregateInputType = {
    id?: true
    ammount?: true
    updatedAt?: true
    tolinerId?: true
  }

  export type BalanceMaxAggregateInputType = {
    id?: true
    ammount?: true
    updatedAt?: true
    tolinerId?: true
  }

  export type BalanceCountAggregateInputType = {
    id?: true
    ammount?: true
    updatedAt?: true
    tolinerId?: true
    _all?: true
  }

  export type BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balance to aggregate.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Balances
    **/
    _count?: true | BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalanceMaxAggregateInputType
  }

  export type GetBalanceAggregateType<T extends BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalance[P]>
      : GetScalarType<T[P], AggregateBalance[P]>
  }




  export type BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BalanceWhereInput
    orderBy?: BalanceOrderByWithAggregationInput | BalanceOrderByWithAggregationInput[]
    by: BalanceScalarFieldEnum[] | BalanceScalarFieldEnum
    having?: BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalanceCountAggregateInputType | true
    _avg?: BalanceAvgAggregateInputType
    _sum?: BalanceSumAggregateInputType
    _min?: BalanceMinAggregateInputType
    _max?: BalanceMaxAggregateInputType
  }

  export type BalanceGroupByOutputType = {
    id: string
    ammount: number
    updatedAt: Date
    tolinerId: string | null
    _count: BalanceCountAggregateOutputType | null
    _avg: BalanceAvgAggregateOutputType | null
    _sum: BalanceSumAggregateOutputType | null
    _min: BalanceMinAggregateOutputType | null
    _max: BalanceMaxAggregateOutputType | null
  }

  type GetBalanceGroupByPayload<T extends BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BalanceGroupByOutputType[P]>
        }
      >
    >


  export type BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    updatedAt?: boolean
    tolinerId?: boolean
    toliner?: boolean | Balance$tolinerArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    updatedAt?: boolean
    tolinerId?: boolean
    toliner?: boolean | Balance$tolinerArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ammount?: boolean
    updatedAt?: boolean
    tolinerId?: boolean
    toliner?: boolean | Balance$tolinerArgs<ExtArgs>
  }, ExtArgs["result"]["balance"]>

  export type BalanceSelectScalar = {
    id?: boolean
    ammount?: boolean
    updatedAt?: boolean
    tolinerId?: boolean
  }

  export type BalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ammount" | "updatedAt" | "tolinerId", ExtArgs["result"]["balance"]>
  export type BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | Balance$tolinerArgs<ExtArgs>
  }
  export type BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | Balance$tolinerArgs<ExtArgs>
  }
  export type BalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    toliner?: boolean | Balance$tolinerArgs<ExtArgs>
  }

  export type $BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Balance"
    objects: {
      toliner: Prisma.$TolinerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ammount: number
      updatedAt: Date
      tolinerId: string | null
    }, ExtArgs["result"]["balance"]>
    composites: {}
  }

  type BalanceGetPayload<S extends boolean | null | undefined | BalanceDefaultArgs> = $Result.GetResult<Prisma.$BalancePayload, S>

  type BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalanceCountAggregateInputType | true
    }

  export interface BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Balance'], meta: { name: 'Balance' } }
    /**
     * Find zero or one Balance that matches the filter.
     * @param {BalanceFindUniqueArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BalanceFindUniqueArgs>(args: SelectSubset<T, BalanceFindUniqueArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BalanceFindUniqueOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BalanceFindFirstArgs>(args?: SelectSubset<T, BalanceFindFirstArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindFirstOrThrowArgs} args - Arguments to find a Balance
     * @example
     * // Get one Balance
     * const balance = await prisma.balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balance.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balanceWithIdOnly = await prisma.balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BalanceFindManyArgs>(args?: SelectSubset<T, BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balance.
     * @param {BalanceCreateArgs} args - Arguments to create a Balance.
     * @example
     * // Create one Balance
     * const Balance = await prisma.balance.create({
     *   data: {
     *     // ... data to create a Balance
     *   }
     * })
     * 
     */
    create<T extends BalanceCreateArgs>(args: SelectSubset<T, BalanceCreateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {BalanceCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BalanceCreateManyArgs>(args?: SelectSubset<T, BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {BalanceCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balance = await prisma.balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balance.
     * @param {BalanceDeleteArgs} args - Arguments to delete one Balance.
     * @example
     * // Delete one Balance
     * const Balance = await prisma.balance.delete({
     *   where: {
     *     // ... filter to delete one Balance
     *   }
     * })
     * 
     */
    delete<T extends BalanceDeleteArgs>(args: SelectSubset<T, BalanceDeleteArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balance.
     * @param {BalanceUpdateArgs} args - Arguments to update one Balance.
     * @example
     * // Update one Balance
     * const balance = await prisma.balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BalanceUpdateArgs>(args: SelectSubset<T, BalanceUpdateArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {BalanceDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BalanceDeleteManyArgs>(args?: SelectSubset<T, BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BalanceUpdateManyArgs>(args: SelectSubset<T, BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances and returns the data updated in the database.
     * @param {BalanceUpdateManyAndReturnArgs} args - Arguments to update many Balances.
     * @example
     * // Update many Balances
     * const balance = await prisma.balance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balances and only return the `id`
     * const balanceWithIdOnly = await prisma.balance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, BalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balance.
     * @param {BalanceUpsertArgs} args - Arguments to update or create a Balance.
     * @example
     * // Update or create a Balance
     * const balance = await prisma.balance.upsert({
     *   create: {
     *     // ... data to create a Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balance we want to update
     *   }
     * })
     */
    upsert<T extends BalanceUpsertArgs>(args: SelectSubset<T, BalanceUpsertArgs<ExtArgs>>): Prisma__BalanceClient<$Result.GetResult<Prisma.$BalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balance.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends BalanceCountArgs>(
      args?: Subset<T, BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalanceAggregateArgs>(args: Subset<T, BalanceAggregateArgs>): Prisma.PrismaPromise<GetBalanceAggregateType<T>>

    /**
     * Group by Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BalanceGroupByArgs['orderBy'] }
        : { orderBy?: BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Balance model
   */
  readonly fields: BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    toliner<T extends Balance$tolinerArgs<ExtArgs> = {}>(args?: Subset<T, Balance$tolinerArgs<ExtArgs>>): Prisma__TolinerClient<$Result.GetResult<Prisma.$TolinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Balance model
   */
  interface BalanceFieldRefs {
    readonly id: FieldRef<"Balance", 'String'>
    readonly ammount: FieldRef<"Balance", 'Float'>
    readonly updatedAt: FieldRef<"Balance", 'DateTime'>
    readonly tolinerId: FieldRef<"Balance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Balance findUnique
   */
  export type BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findUniqueOrThrow
   */
  export type BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance findFirst
   */
  export type BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findFirstOrThrow
   */
  export type BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balance to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Balances.
     */
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance findMany
   */
  export type BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Balances to fetch.
     */
    where?: BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Balances to fetch.
     */
    orderBy?: BalanceOrderByWithRelationInput | BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Balances.
     */
    cursor?: BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Balances.
     */
    skip?: number
    distinct?: BalanceScalarFieldEnum | BalanceScalarFieldEnum[]
  }

  /**
   * Balance create
   */
  export type BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Balance.
     */
    data: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
  }

  /**
   * Balance createMany
   */
  export type BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Balance createManyAndReturn
   */
  export type BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to create many Balances.
     */
    data: BalanceCreateManyInput | BalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance update
   */
  export type BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Balance.
     */
    data: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
    /**
     * Choose, which Balance to update.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance updateMany
   */
  export type BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
  }

  /**
   * Balance updateManyAndReturn
   */
  export type BalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * The data used to update Balances.
     */
    data: XOR<BalanceUpdateManyMutationInput, BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Balances to update
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Balance upsert
   */
  export type BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Balance to update in case it exists.
     */
    where: BalanceWhereUniqueInput
    /**
     * In case the Balance found by the `where` argument doesn't exist, create a new Balance with this data.
     */
    create: XOR<BalanceCreateInput, BalanceUncheckedCreateInput>
    /**
     * In case the Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BalanceUpdateInput, BalanceUncheckedUpdateInput>
  }

  /**
   * Balance delete
   */
  export type BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
    /**
     * Filter which Balance to delete.
     */
    where: BalanceWhereUniqueInput
  }

  /**
   * Balance deleteMany
   */
  export type BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Balances to delete
     */
    where?: BalanceWhereInput
    /**
     * Limit how many Balances to delete.
     */
    limit?: number
  }

  /**
   * Balance.toliner
   */
  export type Balance$tolinerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Toliner
     */
    select?: TolinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Toliner
     */
    omit?: TolinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TolinerInclude<ExtArgs> | null
    where?: TolinerWhereInput
  }

  /**
   * Balance without action
   */
  export type BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Balance
     */
    select?: BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Balance
     */
    omit?: BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BalanceInclude<ExtArgs> | null
  }


  /**
   * Model VerificationCode
   */

  export type AggregateVerificationCode = {
    _count: VerificationCodeCountAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  export type VerificationCodeMinAggregateOutputType = {
    id: string | null
    userEmail: string | null
    code: string | null
    expires: Date | null
    type: string | null
  }

  export type VerificationCodeMaxAggregateOutputType = {
    id: string | null
    userEmail: string | null
    code: string | null
    expires: Date | null
    type: string | null
  }

  export type VerificationCodeCountAggregateOutputType = {
    id: number
    userEmail: number
    code: number
    expires: number
    type: number
    _all: number
  }


  export type VerificationCodeMinAggregateInputType = {
    id?: true
    userEmail?: true
    code?: true
    expires?: true
    type?: true
  }

  export type VerificationCodeMaxAggregateInputType = {
    id?: true
    userEmail?: true
    code?: true
    expires?: true
    type?: true
  }

  export type VerificationCodeCountAggregateInputType = {
    id?: true
    userEmail?: true
    code?: true
    expires?: true
    type?: true
    _all?: true
  }

  export type VerificationCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCode to aggregate.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationCodes
    **/
    _count?: true | VerificationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type GetVerificationCodeAggregateType<T extends VerificationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationCode[P]>
      : GetScalarType<T[P], AggregateVerificationCode[P]>
  }




  export type VerificationCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationCodeWhereInput
    orderBy?: VerificationCodeOrderByWithAggregationInput | VerificationCodeOrderByWithAggregationInput[]
    by: VerificationCodeScalarFieldEnum[] | VerificationCodeScalarFieldEnum
    having?: VerificationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCodeCountAggregateInputType | true
    _min?: VerificationCodeMinAggregateInputType
    _max?: VerificationCodeMaxAggregateInputType
  }

  export type VerificationCodeGroupByOutputType = {
    id: string
    userEmail: string
    code: string
    expires: Date
    type: string
    _count: VerificationCodeCountAggregateOutputType | null
    _min: VerificationCodeMinAggregateOutputType | null
    _max: VerificationCodeMaxAggregateOutputType | null
  }

  type GetVerificationCodeGroupByPayload<T extends VerificationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationCodeGroupByOutputType[P]>
        }
      >
    >


  export type VerificationCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userEmail?: boolean
    code?: boolean
    expires?: boolean
    type?: boolean
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userEmail?: boolean
    code?: boolean
    expires?: boolean
    type?: boolean
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userEmail?: boolean
    code?: boolean
    expires?: boolean
    type?: boolean
  }, ExtArgs["result"]["verificationCode"]>

  export type VerificationCodeSelectScalar = {
    id?: boolean
    userEmail?: boolean
    code?: boolean
    expires?: boolean
    type?: boolean
  }

  export type VerificationCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userEmail" | "code" | "expires" | "type", ExtArgs["result"]["verificationCode"]>

  export type $VerificationCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userEmail: string
      code: string
      expires: Date
      type: string
    }, ExtArgs["result"]["verificationCode"]>
    composites: {}
  }

  type VerificationCodeGetPayload<S extends boolean | null | undefined | VerificationCodeDefaultArgs> = $Result.GetResult<Prisma.$VerificationCodePayload, S>

  type VerificationCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCodeCountAggregateInputType | true
    }

  export interface VerificationCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationCode'], meta: { name: 'VerificationCode' } }
    /**
     * Find zero or one VerificationCode that matches the filter.
     * @param {VerificationCodeFindUniqueArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationCodeFindUniqueArgs>(args: SelectSubset<T, VerificationCodeFindUniqueArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationCodeFindUniqueOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationCodeFindFirstArgs>(args?: SelectSubset<T, VerificationCodeFindFirstArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindFirstOrThrowArgs} args - Arguments to find a VerificationCode
     * @example
     * // Get one VerificationCode
     * const verificationCode = await prisma.verificationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany()
     * 
     * // Get first 10 VerificationCodes
     * const verificationCodes = await prisma.verificationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationCodeFindManyArgs>(args?: SelectSubset<T, VerificationCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationCode.
     * @param {VerificationCodeCreateArgs} args - Arguments to create a VerificationCode.
     * @example
     * // Create one VerificationCode
     * const VerificationCode = await prisma.verificationCode.create({
     *   data: {
     *     // ... data to create a VerificationCode
     *   }
     * })
     * 
     */
    create<T extends VerificationCodeCreateArgs>(args: SelectSubset<T, VerificationCodeCreateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationCodes.
     * @param {VerificationCodeCreateManyArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCodeCreateManyArgs>(args?: SelectSubset<T, VerificationCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationCodes and returns the data saved in the database.
     * @param {VerificationCodeCreateManyAndReturnArgs} args - Arguments to create many VerificationCodes.
     * @example
     * // Create many VerificationCodes
     * const verificationCode = await prisma.verificationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationCode.
     * @param {VerificationCodeDeleteArgs} args - Arguments to delete one VerificationCode.
     * @example
     * // Delete one VerificationCode
     * const VerificationCode = await prisma.verificationCode.delete({
     *   where: {
     *     // ... filter to delete one VerificationCode
     *   }
     * })
     * 
     */
    delete<T extends VerificationCodeDeleteArgs>(args: SelectSubset<T, VerificationCodeDeleteArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationCode.
     * @param {VerificationCodeUpdateArgs} args - Arguments to update one VerificationCode.
     * @example
     * // Update one VerificationCode
     * const verificationCode = await prisma.verificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationCodeUpdateArgs>(args: SelectSubset<T, VerificationCodeUpdateArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationCodes.
     * @param {VerificationCodeDeleteManyArgs} args - Arguments to filter VerificationCodes to delete.
     * @example
     * // Delete a few VerificationCodes
     * const { count } = await prisma.verificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationCodeDeleteManyArgs>(args?: SelectSubset<T, VerificationCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationCodeUpdateManyArgs>(args: SelectSubset<T, VerificationCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationCodes and returns the data updated in the database.
     * @param {VerificationCodeUpdateManyAndReturnArgs} args - Arguments to update many VerificationCodes.
     * @example
     * // Update many VerificationCodes
     * const verificationCode = await prisma.verificationCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationCodes and only return the `id`
     * const verificationCodeWithIdOnly = await prisma.verificationCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationCode.
     * @param {VerificationCodeUpsertArgs} args - Arguments to update or create a VerificationCode.
     * @example
     * // Update or create a VerificationCode
     * const verificationCode = await prisma.verificationCode.upsert({
     *   create: {
     *     // ... data to create a VerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationCode we want to update
     *   }
     * })
     */
    upsert<T extends VerificationCodeUpsertArgs>(args: SelectSubset<T, VerificationCodeUpsertArgs<ExtArgs>>): Prisma__VerificationCodeClient<$Result.GetResult<Prisma.$VerificationCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeCountArgs} args - Arguments to filter VerificationCodes to count.
     * @example
     * // Count the number of VerificationCodes
     * const count = await prisma.verificationCode.count({
     *   where: {
     *     // ... the filter for the VerificationCodes we want to count
     *   }
     * })
    **/
    count<T extends VerificationCodeCountArgs>(
      args?: Subset<T, VerificationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationCodeAggregateArgs>(args: Subset<T, VerificationCodeAggregateArgs>): Prisma.PrismaPromise<GetVerificationCodeAggregateType<T>>

    /**
     * Group by VerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: VerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationCode model
   */
  readonly fields: VerificationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationCode model
   */
  interface VerificationCodeFieldRefs {
    readonly id: FieldRef<"VerificationCode", 'String'>
    readonly userEmail: FieldRef<"VerificationCode", 'String'>
    readonly code: FieldRef<"VerificationCode", 'String'>
    readonly expires: FieldRef<"VerificationCode", 'DateTime'>
    readonly type: FieldRef<"VerificationCode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VerificationCode findUnique
   */
  export type VerificationCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findUniqueOrThrow
   */
  export type VerificationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode findFirst
   */
  export type VerificationCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findFirstOrThrow
   */
  export type VerificationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCode to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationCodes.
     */
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode findMany
   */
  export type VerificationCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter, which VerificationCodes to fetch.
     */
    where?: VerificationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationCodes to fetch.
     */
    orderBy?: VerificationCodeOrderByWithRelationInput | VerificationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationCodes.
     */
    cursor?: VerificationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationCodes.
     */
    skip?: number
    distinct?: VerificationCodeScalarFieldEnum | VerificationCodeScalarFieldEnum[]
  }

  /**
   * VerificationCode create
   */
  export type VerificationCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationCode.
     */
    data: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
  }

  /**
   * VerificationCode createMany
   */
  export type VerificationCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode createManyAndReturn
   */
  export type VerificationCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationCodes.
     */
    data: VerificationCodeCreateManyInput | VerificationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationCode update
   */
  export type VerificationCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationCode.
     */
    data: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
    /**
     * Choose, which VerificationCode to update.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode updateMany
   */
  export type VerificationCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode updateManyAndReturn
   */
  export type VerificationCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The data used to update VerificationCodes.
     */
    data: XOR<VerificationCodeUpdateManyMutationInput, VerificationCodeUncheckedUpdateManyInput>
    /**
     * Filter which VerificationCodes to update
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to update.
     */
    limit?: number
  }

  /**
   * VerificationCode upsert
   */
  export type VerificationCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationCode to update in case it exists.
     */
    where: VerificationCodeWhereUniqueInput
    /**
     * In case the VerificationCode found by the `where` argument doesn't exist, create a new VerificationCode with this data.
     */
    create: XOR<VerificationCodeCreateInput, VerificationCodeUncheckedCreateInput>
    /**
     * In case the VerificationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationCodeUpdateInput, VerificationCodeUncheckedUpdateInput>
  }

  /**
   * VerificationCode delete
   */
  export type VerificationCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
    /**
     * Filter which VerificationCode to delete.
     */
    where: VerificationCodeWhereUniqueInput
  }

  /**
   * VerificationCode deleteMany
   */
  export type VerificationCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationCodes to delete
     */
    where?: VerificationCodeWhereInput
    /**
     * Limit how many VerificationCodes to delete.
     */
    limit?: number
  }

  /**
   * VerificationCode without action
   */
  export type VerificationCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationCode
     */
    select?: VerificationCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationCode
     */
    omit?: VerificationCodeOmit<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
    subcategoryId: string | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: string | null
    subcategoryId: string | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    categoryId: number
    subcategoryId: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    subcategoryId?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    subcategoryId?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    subcategoryId?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    categoryId: string | null
    subcategoryId: string | null
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    category?: boolean | Skill$categoryArgs<ExtArgs>
    users?: boolean | Skill$usersArgs<ExtArgs>
    portifolios?: boolean | Skill$portifoliosArgs<ExtArgs>
    projects?: boolean | Skill$projectsArgs<ExtArgs>
    certificationTest?: boolean | Skill$certificationTestArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    category?: boolean | Skill$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    category?: boolean | Skill$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "createdAt" | "updatedAt" | "categoryId" | "subcategoryId", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Skill$categoryArgs<ExtArgs>
    users?: boolean | Skill$usersArgs<ExtArgs>
    portifolios?: boolean | Skill$portifoliosArgs<ExtArgs>
    projects?: boolean | Skill$projectsArgs<ExtArgs>
    certificationTest?: boolean | Skill$certificationTestArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Skill$categoryArgs<ExtArgs>
  }
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Skill$categoryArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      portifolios: Prisma.$PortifolioPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      certificationTest: Prisma.$CertificationTestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      categoryId: string | null
      subcategoryId: string | null
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Skill$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Skill$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Skill$usersArgs<ExtArgs> = {}>(args?: Subset<T, Skill$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    portifolios<T extends Skill$portifoliosArgs<ExtArgs> = {}>(args?: Subset<T, Skill$portifoliosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortifolioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Skill$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificationTest<T extends Skill$certificationTestArgs<ExtArgs> = {}>(args?: Subset<T, Skill$certificationTestArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly slug: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
    readonly categoryId: FieldRef<"Skill", 'String'>
    readonly subcategoryId: FieldRef<"Skill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.category
   */
  export type Skill$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Skill.users
   */
  export type Skill$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Skill.portifolios
   */
  export type Skill$portifoliosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Portifolio
     */
    select?: PortifolioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Portifolio
     */
    omit?: PortifolioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortifolioInclude<ExtArgs> | null
    where?: PortifolioWhereInput
    orderBy?: PortifolioOrderByWithRelationInput | PortifolioOrderByWithRelationInput[]
    cursor?: PortifolioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortifolioScalarFieldEnum | PortifolioScalarFieldEnum[]
  }

  /**
   * Skill.projects
   */
  export type Skill$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Skill.certificationTest
   */
  export type Skill$certificationTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    where?: CertificationTestWhereInput
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model CertificationTest
   */

  export type AggregateCertificationTest = {
    _count: CertificationTestCountAggregateOutputType | null
    _avg: CertificationTestAvgAggregateOutputType | null
    _sum: CertificationTestSumAggregateOutputType | null
    _min: CertificationTestMinAggregateOutputType | null
    _max: CertificationTestMaxAggregateOutputType | null
  }

  export type CertificationTestAvgAggregateOutputType = {
    timeLimit: number | null
    passingScore: number | null
  }

  export type CertificationTestSumAggregateOutputType = {
    timeLimit: number | null
    passingScore: number | null
  }

  export type CertificationTestMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    timeLimit: number | null
    passingScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
    skillId: string | null
  }

  export type CertificationTestMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    timeLimit: number | null
    passingScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
    skillId: string | null
  }

  export type CertificationTestCountAggregateOutputType = {
    id: number
    title: number
    description: number
    timeLimit: number
    passingScore: number
    createdAt: number
    updatedAt: number
    skillId: number
    _all: number
  }


  export type CertificationTestAvgAggregateInputType = {
    timeLimit?: true
    passingScore?: true
  }

  export type CertificationTestSumAggregateInputType = {
    timeLimit?: true
    passingScore?: true
  }

  export type CertificationTestMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    timeLimit?: true
    passingScore?: true
    createdAt?: true
    updatedAt?: true
    skillId?: true
  }

  export type CertificationTestMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    timeLimit?: true
    passingScore?: true
    createdAt?: true
    updatedAt?: true
    skillId?: true
  }

  export type CertificationTestCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    timeLimit?: true
    passingScore?: true
    createdAt?: true
    updatedAt?: true
    skillId?: true
    _all?: true
  }

  export type CertificationTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificationTest to aggregate.
     */
    where?: CertificationTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationTests to fetch.
     */
    orderBy?: CertificationTestOrderByWithRelationInput | CertificationTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CertificationTests
    **/
    _count?: true | CertificationTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificationTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificationTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationTestMaxAggregateInputType
  }

  export type GetCertificationTestAggregateType<T extends CertificationTestAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificationTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificationTest[P]>
      : GetScalarType<T[P], AggregateCertificationTest[P]>
  }




  export type CertificationTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationTestWhereInput
    orderBy?: CertificationTestOrderByWithAggregationInput | CertificationTestOrderByWithAggregationInput[]
    by: CertificationTestScalarFieldEnum[] | CertificationTestScalarFieldEnum
    having?: CertificationTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationTestCountAggregateInputType | true
    _avg?: CertificationTestAvgAggregateInputType
    _sum?: CertificationTestSumAggregateInputType
    _min?: CertificationTestMinAggregateInputType
    _max?: CertificationTestMaxAggregateInputType
  }

  export type CertificationTestGroupByOutputType = {
    id: string
    title: string
    description: string | null
    timeLimit: number | null
    passingScore: number
    createdAt: Date
    updatedAt: Date
    skillId: string
    _count: CertificationTestCountAggregateOutputType | null
    _avg: CertificationTestAvgAggregateOutputType | null
    _sum: CertificationTestSumAggregateOutputType | null
    _min: CertificationTestMinAggregateOutputType | null
    _max: CertificationTestMaxAggregateOutputType | null
  }

  type GetCertificationTestGroupByPayload<T extends CertificationTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationTestGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationTestGroupByOutputType[P]>
        }
      >
    >


  export type CertificationTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillId?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    questions?: boolean | CertificationTest$questionsArgs<ExtArgs>
    attempts?: boolean | CertificationTest$attemptsArgs<ExtArgs>
    _count?: boolean | CertificationTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificationTest"]>

  export type CertificationTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillId?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificationTest"]>

  export type CertificationTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillId?: boolean
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificationTest"]>

  export type CertificationTestSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    skillId?: boolean
  }

  export type CertificationTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "timeLimit" | "passingScore" | "createdAt" | "updatedAt" | "skillId", ExtArgs["result"]["certificationTest"]>
  export type CertificationTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
    questions?: boolean | CertificationTest$questionsArgs<ExtArgs>
    attempts?: boolean | CertificationTest$attemptsArgs<ExtArgs>
    _count?: boolean | CertificationTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CertificationTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type CertificationTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $CertificationTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CertificationTest"
    objects: {
      skill: Prisma.$SkillPayload<ExtArgs>
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      attempts: Prisma.$TestAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      timeLimit: number | null
      passingScore: number
      createdAt: Date
      updatedAt: Date
      skillId: string
    }, ExtArgs["result"]["certificationTest"]>
    composites: {}
  }

  type CertificationTestGetPayload<S extends boolean | null | undefined | CertificationTestDefaultArgs> = $Result.GetResult<Prisma.$CertificationTestPayload, S>

  type CertificationTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificationTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificationTestCountAggregateInputType | true
    }

  export interface CertificationTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CertificationTest'], meta: { name: 'CertificationTest' } }
    /**
     * Find zero or one CertificationTest that matches the filter.
     * @param {CertificationTestFindUniqueArgs} args - Arguments to find a CertificationTest
     * @example
     * // Get one CertificationTest
     * const certificationTest = await prisma.certificationTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationTestFindUniqueArgs>(args: SelectSubset<T, CertificationTestFindUniqueArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CertificationTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificationTestFindUniqueOrThrowArgs} args - Arguments to find a CertificationTest
     * @example
     * // Get one CertificationTest
     * const certificationTest = await prisma.certificationTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationTestFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificationTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestFindFirstArgs} args - Arguments to find a CertificationTest
     * @example
     * // Get one CertificationTest
     * const certificationTest = await prisma.certificationTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationTestFindFirstArgs>(args?: SelectSubset<T, CertificationTestFindFirstArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CertificationTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestFindFirstOrThrowArgs} args - Arguments to find a CertificationTest
     * @example
     * // Get one CertificationTest
     * const certificationTest = await prisma.certificationTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationTestFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CertificationTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CertificationTests
     * const certificationTests = await prisma.certificationTest.findMany()
     * 
     * // Get first 10 CertificationTests
     * const certificationTests = await prisma.certificationTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationTestWithIdOnly = await prisma.certificationTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationTestFindManyArgs>(args?: SelectSubset<T, CertificationTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CertificationTest.
     * @param {CertificationTestCreateArgs} args - Arguments to create a CertificationTest.
     * @example
     * // Create one CertificationTest
     * const CertificationTest = await prisma.certificationTest.create({
     *   data: {
     *     // ... data to create a CertificationTest
     *   }
     * })
     * 
     */
    create<T extends CertificationTestCreateArgs>(args: SelectSubset<T, CertificationTestCreateArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CertificationTests.
     * @param {CertificationTestCreateManyArgs} args - Arguments to create many CertificationTests.
     * @example
     * // Create many CertificationTests
     * const certificationTest = await prisma.certificationTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationTestCreateManyArgs>(args?: SelectSubset<T, CertificationTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CertificationTests and returns the data saved in the database.
     * @param {CertificationTestCreateManyAndReturnArgs} args - Arguments to create many CertificationTests.
     * @example
     * // Create many CertificationTests
     * const certificationTest = await prisma.certificationTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CertificationTests and only return the `id`
     * const certificationTestWithIdOnly = await prisma.certificationTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationTestCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CertificationTest.
     * @param {CertificationTestDeleteArgs} args - Arguments to delete one CertificationTest.
     * @example
     * // Delete one CertificationTest
     * const CertificationTest = await prisma.certificationTest.delete({
     *   where: {
     *     // ... filter to delete one CertificationTest
     *   }
     * })
     * 
     */
    delete<T extends CertificationTestDeleteArgs>(args: SelectSubset<T, CertificationTestDeleteArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CertificationTest.
     * @param {CertificationTestUpdateArgs} args - Arguments to update one CertificationTest.
     * @example
     * // Update one CertificationTest
     * const certificationTest = await prisma.certificationTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationTestUpdateArgs>(args: SelectSubset<T, CertificationTestUpdateArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CertificationTests.
     * @param {CertificationTestDeleteManyArgs} args - Arguments to filter CertificationTests to delete.
     * @example
     * // Delete a few CertificationTests
     * const { count } = await prisma.certificationTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationTestDeleteManyArgs>(args?: SelectSubset<T, CertificationTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificationTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CertificationTests
     * const certificationTest = await prisma.certificationTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationTestUpdateManyArgs>(args: SelectSubset<T, CertificationTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CertificationTests and returns the data updated in the database.
     * @param {CertificationTestUpdateManyAndReturnArgs} args - Arguments to update many CertificationTests.
     * @example
     * // Update many CertificationTests
     * const certificationTest = await prisma.certificationTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CertificationTests and only return the `id`
     * const certificationTestWithIdOnly = await prisma.certificationTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificationTestUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificationTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CertificationTest.
     * @param {CertificationTestUpsertArgs} args - Arguments to update or create a CertificationTest.
     * @example
     * // Update or create a CertificationTest
     * const certificationTest = await prisma.certificationTest.upsert({
     *   create: {
     *     // ... data to create a CertificationTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CertificationTest we want to update
     *   }
     * })
     */
    upsert<T extends CertificationTestUpsertArgs>(args: SelectSubset<T, CertificationTestUpsertArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CertificationTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestCountArgs} args - Arguments to filter CertificationTests to count.
     * @example
     * // Count the number of CertificationTests
     * const count = await prisma.certificationTest.count({
     *   where: {
     *     // ... the filter for the CertificationTests we want to count
     *   }
     * })
    **/
    count<T extends CertificationTestCountArgs>(
      args?: Subset<T, CertificationTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CertificationTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationTestAggregateArgs>(args: Subset<T, CertificationTestAggregateArgs>): Prisma.PrismaPromise<GetCertificationTestAggregateType<T>>

    /**
     * Group by CertificationTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationTestGroupByArgs['orderBy'] }
        : { orderBy?: CertificationTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CertificationTest model
   */
  readonly fields: CertificationTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CertificationTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends CertificationTest$questionsArgs<ExtArgs> = {}>(args?: Subset<T, CertificationTest$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends CertificationTest$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, CertificationTest$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CertificationTest model
   */
  interface CertificationTestFieldRefs {
    readonly id: FieldRef<"CertificationTest", 'String'>
    readonly title: FieldRef<"CertificationTest", 'String'>
    readonly description: FieldRef<"CertificationTest", 'String'>
    readonly timeLimit: FieldRef<"CertificationTest", 'Int'>
    readonly passingScore: FieldRef<"CertificationTest", 'Float'>
    readonly createdAt: FieldRef<"CertificationTest", 'DateTime'>
    readonly updatedAt: FieldRef<"CertificationTest", 'DateTime'>
    readonly skillId: FieldRef<"CertificationTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CertificationTest findUnique
   */
  export type CertificationTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * Filter, which CertificationTest to fetch.
     */
    where: CertificationTestWhereUniqueInput
  }

  /**
   * CertificationTest findUniqueOrThrow
   */
  export type CertificationTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * Filter, which CertificationTest to fetch.
     */
    where: CertificationTestWhereUniqueInput
  }

  /**
   * CertificationTest findFirst
   */
  export type CertificationTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * Filter, which CertificationTest to fetch.
     */
    where?: CertificationTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationTests to fetch.
     */
    orderBy?: CertificationTestOrderByWithRelationInput | CertificationTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificationTests.
     */
    cursor?: CertificationTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificationTests.
     */
    distinct?: CertificationTestScalarFieldEnum | CertificationTestScalarFieldEnum[]
  }

  /**
   * CertificationTest findFirstOrThrow
   */
  export type CertificationTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * Filter, which CertificationTest to fetch.
     */
    where?: CertificationTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationTests to fetch.
     */
    orderBy?: CertificationTestOrderByWithRelationInput | CertificationTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CertificationTests.
     */
    cursor?: CertificationTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CertificationTests.
     */
    distinct?: CertificationTestScalarFieldEnum | CertificationTestScalarFieldEnum[]
  }

  /**
   * CertificationTest findMany
   */
  export type CertificationTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * Filter, which CertificationTests to fetch.
     */
    where?: CertificationTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CertificationTests to fetch.
     */
    orderBy?: CertificationTestOrderByWithRelationInput | CertificationTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CertificationTests.
     */
    cursor?: CertificationTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CertificationTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CertificationTests.
     */
    skip?: number
    distinct?: CertificationTestScalarFieldEnum | CertificationTestScalarFieldEnum[]
  }

  /**
   * CertificationTest create
   */
  export type CertificationTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * The data needed to create a CertificationTest.
     */
    data: XOR<CertificationTestCreateInput, CertificationTestUncheckedCreateInput>
  }

  /**
   * CertificationTest createMany
   */
  export type CertificationTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CertificationTests.
     */
    data: CertificationTestCreateManyInput | CertificationTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CertificationTest createManyAndReturn
   */
  export type CertificationTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * The data used to create many CertificationTests.
     */
    data: CertificationTestCreateManyInput | CertificationTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CertificationTest update
   */
  export type CertificationTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * The data needed to update a CertificationTest.
     */
    data: XOR<CertificationTestUpdateInput, CertificationTestUncheckedUpdateInput>
    /**
     * Choose, which CertificationTest to update.
     */
    where: CertificationTestWhereUniqueInput
  }

  /**
   * CertificationTest updateMany
   */
  export type CertificationTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CertificationTests.
     */
    data: XOR<CertificationTestUpdateManyMutationInput, CertificationTestUncheckedUpdateManyInput>
    /**
     * Filter which CertificationTests to update
     */
    where?: CertificationTestWhereInput
    /**
     * Limit how many CertificationTests to update.
     */
    limit?: number
  }

  /**
   * CertificationTest updateManyAndReturn
   */
  export type CertificationTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * The data used to update CertificationTests.
     */
    data: XOR<CertificationTestUpdateManyMutationInput, CertificationTestUncheckedUpdateManyInput>
    /**
     * Filter which CertificationTests to update
     */
    where?: CertificationTestWhereInput
    /**
     * Limit how many CertificationTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CertificationTest upsert
   */
  export type CertificationTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * The filter to search for the CertificationTest to update in case it exists.
     */
    where: CertificationTestWhereUniqueInput
    /**
     * In case the CertificationTest found by the `where` argument doesn't exist, create a new CertificationTest with this data.
     */
    create: XOR<CertificationTestCreateInput, CertificationTestUncheckedCreateInput>
    /**
     * In case the CertificationTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationTestUpdateInput, CertificationTestUncheckedUpdateInput>
  }

  /**
   * CertificationTest delete
   */
  export type CertificationTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
    /**
     * Filter which CertificationTest to delete.
     */
    where: CertificationTestWhereUniqueInput
  }

  /**
   * CertificationTest deleteMany
   */
  export type CertificationTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CertificationTests to delete
     */
    where?: CertificationTestWhereInput
    /**
     * Limit how many CertificationTests to delete.
     */
    limit?: number
  }

  /**
   * CertificationTest.questions
   */
  export type CertificationTest$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * CertificationTest.attempts
   */
  export type CertificationTest$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    where?: TestAttemptWhereInput
    orderBy?: TestAttemptOrderByWithRelationInput | TestAttemptOrderByWithRelationInput[]
    cursor?: TestAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestAttemptScalarFieldEnum | TestAttemptScalarFieldEnum[]
  }

  /**
   * CertificationTest without action
   */
  export type CertificationTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CertificationTest
     */
    select?: CertificationTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CertificationTest
     */
    omit?: CertificationTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationTestInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    score: number | null
  }

  export type QuestionSumAggregateOutputType = {
    score: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    text: string | null
    score: number | null
    explanation: string | null
    createdAt: Date | null
    updatedAt: Date | null
    certificationTestId: string | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    score: number | null
    explanation: string | null
    createdAt: Date | null
    updatedAt: Date | null
    certificationTestId: string | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    text: number
    score: number
    explanation: number
    createdAt: number
    updatedAt: number
    certificationTestId: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    score?: true
  }

  export type QuestionSumAggregateInputType = {
    score?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    text?: true
    score?: true
    explanation?: true
    createdAt?: true
    updatedAt?: true
    certificationTestId?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    text?: true
    score?: true
    explanation?: true
    createdAt?: true
    updatedAt?: true
    certificationTestId?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    text?: true
    score?: true
    explanation?: true
    createdAt?: true
    updatedAt?: true
    certificationTestId?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    text: string
    score: number
    explanation: string | null
    createdAt: Date
    updatedAt: Date
    certificationTestId: string
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    score?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    alternatives?: boolean | Question$alternativesArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    score?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    score?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    text?: boolean
    score?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "score" | "explanation" | "createdAt" | "updatedAt" | "certificationTestId", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    alternatives?: boolean | Question$alternativesArgs<ExtArgs>
    answers?: boolean | Question$answersArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      certificationTest: Prisma.$CertificationTestPayload<ExtArgs>
      alternatives: Prisma.$AlternativePayload<ExtArgs>[]
      answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      score: number
      explanation: string | null
      createdAt: Date
      updatedAt: Date
      certificationTestId: string
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificationTest<T extends CertificationTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CertificationTestDefaultArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    alternatives<T extends Question$alternativesArgs<ExtArgs> = {}>(args?: Subset<T, Question$alternativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    answers<T extends Question$answersArgs<ExtArgs> = {}>(args?: Subset<T, Question$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly text: FieldRef<"Question", 'String'>
    readonly score: FieldRef<"Question", 'Float'>
    readonly explanation: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
    readonly certificationTestId: FieldRef<"Question", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.alternatives
   */
  export type Question$alternativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    where?: AlternativeWhereInput
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    cursor?: AlternativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Question.answers
   */
  export type Question$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Alternative
   */

  export type AggregateAlternative = {
    _count: AlternativeCountAggregateOutputType | null
    _min: AlternativeMinAggregateOutputType | null
    _max: AlternativeMaxAggregateOutputType | null
  }

  export type AlternativeMinAggregateOutputType = {
    id: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    questionId: string | null
  }

  export type AlternativeMaxAggregateOutputType = {
    id: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    questionId: string | null
  }

  export type AlternativeCountAggregateOutputType = {
    id: number
    text: number
    isCorrect: number
    createdAt: number
    updatedAt: number
    questionId: number
    _all: number
  }


  export type AlternativeMinAggregateInputType = {
    id?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    questionId?: true
  }

  export type AlternativeMaxAggregateInputType = {
    id?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    questionId?: true
  }

  export type AlternativeCountAggregateInputType = {
    id?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    questionId?: true
    _all?: true
  }

  export type AlternativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alternative to aggregate.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alternatives
    **/
    _count?: true | AlternativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlternativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlternativeMaxAggregateInputType
  }

  export type GetAlternativeAggregateType<T extends AlternativeAggregateArgs> = {
        [P in keyof T & keyof AggregateAlternative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlternative[P]>
      : GetScalarType<T[P], AggregateAlternative[P]>
  }




  export type AlternativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlternativeWhereInput
    orderBy?: AlternativeOrderByWithAggregationInput | AlternativeOrderByWithAggregationInput[]
    by: AlternativeScalarFieldEnum[] | AlternativeScalarFieldEnum
    having?: AlternativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlternativeCountAggregateInputType | true
    _min?: AlternativeMinAggregateInputType
    _max?: AlternativeMaxAggregateInputType
  }

  export type AlternativeGroupByOutputType = {
    id: string
    text: string
    isCorrect: boolean
    createdAt: Date
    updatedAt: Date
    questionId: string
    _count: AlternativeCountAggregateOutputType | null
    _min: AlternativeMinAggregateOutputType | null
    _max: AlternativeMaxAggregateOutputType | null
  }

  type GetAlternativeGroupByPayload<T extends AlternativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlternativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlternativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlternativeGroupByOutputType[P]>
            : GetScalarType<T[P], AlternativeGroupByOutputType[P]>
        }
      >
    >


  export type AlternativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionId?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answers?: boolean | Alternative$answersArgs<ExtArgs>
    _count?: boolean | AlternativeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternative"]>

  export type AlternativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionId?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternative"]>

  export type AlternativeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionId?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alternative"]>

  export type AlternativeSelectScalar = {
    id?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questionId?: boolean
  }

  export type AlternativeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "isCorrect" | "createdAt" | "updatedAt" | "questionId", ExtArgs["result"]["alternative"]>
  export type AlternativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    answers?: boolean | Alternative$answersArgs<ExtArgs>
    _count?: boolean | AlternativeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlternativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type AlternativeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $AlternativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alternative"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
      answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      isCorrect: boolean
      createdAt: Date
      updatedAt: Date
      questionId: string
    }, ExtArgs["result"]["alternative"]>
    composites: {}
  }

  type AlternativeGetPayload<S extends boolean | null | undefined | AlternativeDefaultArgs> = $Result.GetResult<Prisma.$AlternativePayload, S>

  type AlternativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlternativeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlternativeCountAggregateInputType | true
    }

  export interface AlternativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alternative'], meta: { name: 'Alternative' } }
    /**
     * Find zero or one Alternative that matches the filter.
     * @param {AlternativeFindUniqueArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlternativeFindUniqueArgs>(args: SelectSubset<T, AlternativeFindUniqueArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alternative that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlternativeFindUniqueOrThrowArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlternativeFindUniqueOrThrowArgs>(args: SelectSubset<T, AlternativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alternative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeFindFirstArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlternativeFindFirstArgs>(args?: SelectSubset<T, AlternativeFindFirstArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alternative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeFindFirstOrThrowArgs} args - Arguments to find a Alternative
     * @example
     * // Get one Alternative
     * const alternative = await prisma.alternative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlternativeFindFirstOrThrowArgs>(args?: SelectSubset<T, AlternativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alternatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alternatives
     * const alternatives = await prisma.alternative.findMany()
     * 
     * // Get first 10 Alternatives
     * const alternatives = await prisma.alternative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alternativeWithIdOnly = await prisma.alternative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlternativeFindManyArgs>(args?: SelectSubset<T, AlternativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alternative.
     * @param {AlternativeCreateArgs} args - Arguments to create a Alternative.
     * @example
     * // Create one Alternative
     * const Alternative = await prisma.alternative.create({
     *   data: {
     *     // ... data to create a Alternative
     *   }
     * })
     * 
     */
    create<T extends AlternativeCreateArgs>(args: SelectSubset<T, AlternativeCreateArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alternatives.
     * @param {AlternativeCreateManyArgs} args - Arguments to create many Alternatives.
     * @example
     * // Create many Alternatives
     * const alternative = await prisma.alternative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlternativeCreateManyArgs>(args?: SelectSubset<T, AlternativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alternatives and returns the data saved in the database.
     * @param {AlternativeCreateManyAndReturnArgs} args - Arguments to create many Alternatives.
     * @example
     * // Create many Alternatives
     * const alternative = await prisma.alternative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alternatives and only return the `id`
     * const alternativeWithIdOnly = await prisma.alternative.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlternativeCreateManyAndReturnArgs>(args?: SelectSubset<T, AlternativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alternative.
     * @param {AlternativeDeleteArgs} args - Arguments to delete one Alternative.
     * @example
     * // Delete one Alternative
     * const Alternative = await prisma.alternative.delete({
     *   where: {
     *     // ... filter to delete one Alternative
     *   }
     * })
     * 
     */
    delete<T extends AlternativeDeleteArgs>(args: SelectSubset<T, AlternativeDeleteArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alternative.
     * @param {AlternativeUpdateArgs} args - Arguments to update one Alternative.
     * @example
     * // Update one Alternative
     * const alternative = await prisma.alternative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlternativeUpdateArgs>(args: SelectSubset<T, AlternativeUpdateArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alternatives.
     * @param {AlternativeDeleteManyArgs} args - Arguments to filter Alternatives to delete.
     * @example
     * // Delete a few Alternatives
     * const { count } = await prisma.alternative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlternativeDeleteManyArgs>(args?: SelectSubset<T, AlternativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alternatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alternatives
     * const alternative = await prisma.alternative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlternativeUpdateManyArgs>(args: SelectSubset<T, AlternativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alternatives and returns the data updated in the database.
     * @param {AlternativeUpdateManyAndReturnArgs} args - Arguments to update many Alternatives.
     * @example
     * // Update many Alternatives
     * const alternative = await prisma.alternative.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alternatives and only return the `id`
     * const alternativeWithIdOnly = await prisma.alternative.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlternativeUpdateManyAndReturnArgs>(args: SelectSubset<T, AlternativeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alternative.
     * @param {AlternativeUpsertArgs} args - Arguments to update or create a Alternative.
     * @example
     * // Update or create a Alternative
     * const alternative = await prisma.alternative.upsert({
     *   create: {
     *     // ... data to create a Alternative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alternative we want to update
     *   }
     * })
     */
    upsert<T extends AlternativeUpsertArgs>(args: SelectSubset<T, AlternativeUpsertArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alternatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeCountArgs} args - Arguments to filter Alternatives to count.
     * @example
     * // Count the number of Alternatives
     * const count = await prisma.alternative.count({
     *   where: {
     *     // ... the filter for the Alternatives we want to count
     *   }
     * })
    **/
    count<T extends AlternativeCountArgs>(
      args?: Subset<T, AlternativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlternativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alternative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlternativeAggregateArgs>(args: Subset<T, AlternativeAggregateArgs>): Prisma.PrismaPromise<GetAlternativeAggregateType<T>>

    /**
     * Group by Alternative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlternativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlternativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlternativeGroupByArgs['orderBy'] }
        : { orderBy?: AlternativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlternativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlternativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alternative model
   */
  readonly fields: AlternativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alternative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlternativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends Alternative$answersArgs<ExtArgs> = {}>(args?: Subset<T, Alternative$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alternative model
   */
  interface AlternativeFieldRefs {
    readonly id: FieldRef<"Alternative", 'String'>
    readonly text: FieldRef<"Alternative", 'String'>
    readonly isCorrect: FieldRef<"Alternative", 'Boolean'>
    readonly createdAt: FieldRef<"Alternative", 'DateTime'>
    readonly updatedAt: FieldRef<"Alternative", 'DateTime'>
    readonly questionId: FieldRef<"Alternative", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alternative findUnique
   */
  export type AlternativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative findUniqueOrThrow
   */
  export type AlternativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative findFirst
   */
  export type AlternativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alternatives.
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alternatives.
     */
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Alternative findFirstOrThrow
   */
  export type AlternativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternative to fetch.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alternatives.
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alternatives.
     */
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Alternative findMany
   */
  export type AlternativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter, which Alternatives to fetch.
     */
    where?: AlternativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alternatives to fetch.
     */
    orderBy?: AlternativeOrderByWithRelationInput | AlternativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alternatives.
     */
    cursor?: AlternativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alternatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alternatives.
     */
    skip?: number
    distinct?: AlternativeScalarFieldEnum | AlternativeScalarFieldEnum[]
  }

  /**
   * Alternative create
   */
  export type AlternativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Alternative.
     */
    data: XOR<AlternativeCreateInput, AlternativeUncheckedCreateInput>
  }

  /**
   * Alternative createMany
   */
  export type AlternativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alternatives.
     */
    data: AlternativeCreateManyInput | AlternativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alternative createManyAndReturn
   */
  export type AlternativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * The data used to create many Alternatives.
     */
    data: AlternativeCreateManyInput | AlternativeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alternative update
   */
  export type AlternativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Alternative.
     */
    data: XOR<AlternativeUpdateInput, AlternativeUncheckedUpdateInput>
    /**
     * Choose, which Alternative to update.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative updateMany
   */
  export type AlternativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alternatives.
     */
    data: XOR<AlternativeUpdateManyMutationInput, AlternativeUncheckedUpdateManyInput>
    /**
     * Filter which Alternatives to update
     */
    where?: AlternativeWhereInput
    /**
     * Limit how many Alternatives to update.
     */
    limit?: number
  }

  /**
   * Alternative updateManyAndReturn
   */
  export type AlternativeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * The data used to update Alternatives.
     */
    data: XOR<AlternativeUpdateManyMutationInput, AlternativeUncheckedUpdateManyInput>
    /**
     * Filter which Alternatives to update
     */
    where?: AlternativeWhereInput
    /**
     * Limit how many Alternatives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alternative upsert
   */
  export type AlternativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Alternative to update in case it exists.
     */
    where: AlternativeWhereUniqueInput
    /**
     * In case the Alternative found by the `where` argument doesn't exist, create a new Alternative with this data.
     */
    create: XOR<AlternativeCreateInput, AlternativeUncheckedCreateInput>
    /**
     * In case the Alternative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlternativeUpdateInput, AlternativeUncheckedUpdateInput>
  }

  /**
   * Alternative delete
   */
  export type AlternativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    /**
     * Filter which Alternative to delete.
     */
    where: AlternativeWhereUniqueInput
  }

  /**
   * Alternative deleteMany
   */
  export type AlternativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alternatives to delete
     */
    where?: AlternativeWhereInput
    /**
     * Limit how many Alternatives to delete.
     */
    limit?: number
  }

  /**
   * Alternative.answers
   */
  export type Alternative$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Alternative without action
   */
  export type AlternativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
  }


  /**
   * Model TestAttempt
   */

  export type AggregateTestAttempt = {
    _count: TestAttemptCountAggregateOutputType | null
    _avg: TestAttemptAvgAggregateOutputType | null
    _sum: TestAttemptSumAggregateOutputType | null
    _min: TestAttemptMinAggregateOutputType | null
    _max: TestAttemptMaxAggregateOutputType | null
  }

  export type TestAttemptAvgAggregateOutputType = {
    score: number | null
    completionTime: number | null
  }

  export type TestAttemptSumAggregateOutputType = {
    score: number | null
    completionTime: number | null
  }

  export type TestAttemptMinAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    score: number | null
    passed: boolean | null
    completionTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    certificationTestId: string | null
    userId: string | null
  }

  export type TestAttemptMaxAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    score: number | null
    passed: boolean | null
    completionTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    certificationTestId: string | null
    userId: string | null
  }

  export type TestAttemptCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    score: number
    passed: number
    completionTime: number
    createdAt: number
    updatedAt: number
    certificationTestId: number
    userId: number
    _all: number
  }


  export type TestAttemptAvgAggregateInputType = {
    score?: true
    completionTime?: true
  }

  export type TestAttemptSumAggregateInputType = {
    score?: true
    completionTime?: true
  }

  export type TestAttemptMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    score?: true
    passed?: true
    completionTime?: true
    createdAt?: true
    updatedAt?: true
    certificationTestId?: true
    userId?: true
  }

  export type TestAttemptMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    score?: true
    passed?: true
    completionTime?: true
    createdAt?: true
    updatedAt?: true
    certificationTestId?: true
    userId?: true
  }

  export type TestAttemptCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    score?: true
    passed?: true
    completionTime?: true
    createdAt?: true
    updatedAt?: true
    certificationTestId?: true
    userId?: true
    _all?: true
  }

  export type TestAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestAttempt to aggregate.
     */
    where?: TestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAttempts to fetch.
     */
    orderBy?: TestAttemptOrderByWithRelationInput | TestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestAttempts
    **/
    _count?: true | TestAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestAttemptMaxAggregateInputType
  }

  export type GetTestAttemptAggregateType<T extends TestAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateTestAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestAttempt[P]>
      : GetScalarType<T[P], AggregateTestAttempt[P]>
  }




  export type TestAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestAttemptWhereInput
    orderBy?: TestAttemptOrderByWithAggregationInput | TestAttemptOrderByWithAggregationInput[]
    by: TestAttemptScalarFieldEnum[] | TestAttemptScalarFieldEnum
    having?: TestAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestAttemptCountAggregateInputType | true
    _avg?: TestAttemptAvgAggregateInputType
    _sum?: TestAttemptSumAggregateInputType
    _min?: TestAttemptMinAggregateInputType
    _max?: TestAttemptMaxAggregateInputType
  }

  export type TestAttemptGroupByOutputType = {
    id: string
    startTime: Date
    endTime: Date | null
    score: number | null
    passed: boolean | null
    completionTime: number | null
    createdAt: Date
    updatedAt: Date
    certificationTestId: string
    userId: string
    _count: TestAttemptCountAggregateOutputType | null
    _avg: TestAttemptAvgAggregateOutputType | null
    _sum: TestAttemptSumAggregateOutputType | null
    _min: TestAttemptMinAggregateOutputType | null
    _max: TestAttemptMaxAggregateOutputType | null
  }

  type GetTestAttemptGroupByPayload<T extends TestAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], TestAttemptGroupByOutputType[P]>
        }
      >
    >


  export type TestAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    score?: boolean
    passed?: boolean
    completionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    userId?: boolean
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | TestAttempt$answersArgs<ExtArgs>
    _count?: boolean | TestAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testAttempt"]>

  export type TestAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    score?: boolean
    passed?: boolean
    completionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    userId?: boolean
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testAttempt"]>

  export type TestAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    score?: boolean
    passed?: boolean
    completionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    userId?: boolean
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testAttempt"]>

  export type TestAttemptSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    score?: boolean
    passed?: boolean
    completionTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificationTestId?: boolean
    userId?: boolean
  }

  export type TestAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "score" | "passed" | "completionTime" | "createdAt" | "updatedAt" | "certificationTestId" | "userId", ExtArgs["result"]["testAttempt"]>
  export type TestAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | TestAttempt$answersArgs<ExtArgs>
    _count?: boolean | TestAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TestAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificationTest?: boolean | CertificationTestDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TestAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestAttempt"
    objects: {
      certificationTest: Prisma.$CertificationTestPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      answers: Prisma.$AnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: Date
      endTime: Date | null
      score: number | null
      passed: boolean | null
      completionTime: number | null
      createdAt: Date
      updatedAt: Date
      certificationTestId: string
      userId: string
    }, ExtArgs["result"]["testAttempt"]>
    composites: {}
  }

  type TestAttemptGetPayload<S extends boolean | null | undefined | TestAttemptDefaultArgs> = $Result.GetResult<Prisma.$TestAttemptPayload, S>

  type TestAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestAttemptCountAggregateInputType | true
    }

  export interface TestAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestAttempt'], meta: { name: 'TestAttempt' } }
    /**
     * Find zero or one TestAttempt that matches the filter.
     * @param {TestAttemptFindUniqueArgs} args - Arguments to find a TestAttempt
     * @example
     * // Get one TestAttempt
     * const testAttempt = await prisma.testAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestAttemptFindUniqueArgs>(args: SelectSubset<T, TestAttemptFindUniqueArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestAttemptFindUniqueOrThrowArgs} args - Arguments to find a TestAttempt
     * @example
     * // Get one TestAttempt
     * const testAttempt = await prisma.testAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, TestAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptFindFirstArgs} args - Arguments to find a TestAttempt
     * @example
     * // Get one TestAttempt
     * const testAttempt = await prisma.testAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestAttemptFindFirstArgs>(args?: SelectSubset<T, TestAttemptFindFirstArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptFindFirstOrThrowArgs} args - Arguments to find a TestAttempt
     * @example
     * // Get one TestAttempt
     * const testAttempt = await prisma.testAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, TestAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestAttempts
     * const testAttempts = await prisma.testAttempt.findMany()
     * 
     * // Get first 10 TestAttempts
     * const testAttempts = await prisma.testAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testAttemptWithIdOnly = await prisma.testAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestAttemptFindManyArgs>(args?: SelectSubset<T, TestAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestAttempt.
     * @param {TestAttemptCreateArgs} args - Arguments to create a TestAttempt.
     * @example
     * // Create one TestAttempt
     * const TestAttempt = await prisma.testAttempt.create({
     *   data: {
     *     // ... data to create a TestAttempt
     *   }
     * })
     * 
     */
    create<T extends TestAttemptCreateArgs>(args: SelectSubset<T, TestAttemptCreateArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestAttempts.
     * @param {TestAttemptCreateManyArgs} args - Arguments to create many TestAttempts.
     * @example
     * // Create many TestAttempts
     * const testAttempt = await prisma.testAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestAttemptCreateManyArgs>(args?: SelectSubset<T, TestAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestAttempts and returns the data saved in the database.
     * @param {TestAttemptCreateManyAndReturnArgs} args - Arguments to create many TestAttempts.
     * @example
     * // Create many TestAttempts
     * const testAttempt = await prisma.testAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestAttempts and only return the `id`
     * const testAttemptWithIdOnly = await prisma.testAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, TestAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestAttempt.
     * @param {TestAttemptDeleteArgs} args - Arguments to delete one TestAttempt.
     * @example
     * // Delete one TestAttempt
     * const TestAttempt = await prisma.testAttempt.delete({
     *   where: {
     *     // ... filter to delete one TestAttempt
     *   }
     * })
     * 
     */
    delete<T extends TestAttemptDeleteArgs>(args: SelectSubset<T, TestAttemptDeleteArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestAttempt.
     * @param {TestAttemptUpdateArgs} args - Arguments to update one TestAttempt.
     * @example
     * // Update one TestAttempt
     * const testAttempt = await prisma.testAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestAttemptUpdateArgs>(args: SelectSubset<T, TestAttemptUpdateArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestAttempts.
     * @param {TestAttemptDeleteManyArgs} args - Arguments to filter TestAttempts to delete.
     * @example
     * // Delete a few TestAttempts
     * const { count } = await prisma.testAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestAttemptDeleteManyArgs>(args?: SelectSubset<T, TestAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestAttempts
     * const testAttempt = await prisma.testAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestAttemptUpdateManyArgs>(args: SelectSubset<T, TestAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestAttempts and returns the data updated in the database.
     * @param {TestAttemptUpdateManyAndReturnArgs} args - Arguments to update many TestAttempts.
     * @example
     * // Update many TestAttempts
     * const testAttempt = await prisma.testAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestAttempts and only return the `id`
     * const testAttemptWithIdOnly = await prisma.testAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, TestAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestAttempt.
     * @param {TestAttemptUpsertArgs} args - Arguments to update or create a TestAttempt.
     * @example
     * // Update or create a TestAttempt
     * const testAttempt = await prisma.testAttempt.upsert({
     *   create: {
     *     // ... data to create a TestAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestAttempt we want to update
     *   }
     * })
     */
    upsert<T extends TestAttemptUpsertArgs>(args: SelectSubset<T, TestAttemptUpsertArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptCountArgs} args - Arguments to filter TestAttempts to count.
     * @example
     * // Count the number of TestAttempts
     * const count = await prisma.testAttempt.count({
     *   where: {
     *     // ... the filter for the TestAttempts we want to count
     *   }
     * })
    **/
    count<T extends TestAttemptCountArgs>(
      args?: Subset<T, TestAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestAttemptAggregateArgs>(args: Subset<T, TestAttemptAggregateArgs>): Prisma.PrismaPromise<GetTestAttemptAggregateType<T>>

    /**
     * Group by TestAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestAttemptGroupByArgs['orderBy'] }
        : { orderBy?: TestAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestAttempt model
   */
  readonly fields: TestAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificationTest<T extends CertificationTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CertificationTestDefaultArgs<ExtArgs>>): Prisma__CertificationTestClient<$Result.GetResult<Prisma.$CertificationTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends TestAttempt$answersArgs<ExtArgs> = {}>(args?: Subset<T, TestAttempt$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestAttempt model
   */
  interface TestAttemptFieldRefs {
    readonly id: FieldRef<"TestAttempt", 'String'>
    readonly startTime: FieldRef<"TestAttempt", 'DateTime'>
    readonly endTime: FieldRef<"TestAttempt", 'DateTime'>
    readonly score: FieldRef<"TestAttempt", 'Float'>
    readonly passed: FieldRef<"TestAttempt", 'Boolean'>
    readonly completionTime: FieldRef<"TestAttempt", 'Int'>
    readonly createdAt: FieldRef<"TestAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"TestAttempt", 'DateTime'>
    readonly certificationTestId: FieldRef<"TestAttempt", 'String'>
    readonly userId: FieldRef<"TestAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestAttempt findUnique
   */
  export type TestAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TestAttempt to fetch.
     */
    where: TestAttemptWhereUniqueInput
  }

  /**
   * TestAttempt findUniqueOrThrow
   */
  export type TestAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TestAttempt to fetch.
     */
    where: TestAttemptWhereUniqueInput
  }

  /**
   * TestAttempt findFirst
   */
  export type TestAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TestAttempt to fetch.
     */
    where?: TestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAttempts to fetch.
     */
    orderBy?: TestAttemptOrderByWithRelationInput | TestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestAttempts.
     */
    cursor?: TestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestAttempts.
     */
    distinct?: TestAttemptScalarFieldEnum | TestAttemptScalarFieldEnum[]
  }

  /**
   * TestAttempt findFirstOrThrow
   */
  export type TestAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TestAttempt to fetch.
     */
    where?: TestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAttempts to fetch.
     */
    orderBy?: TestAttemptOrderByWithRelationInput | TestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestAttempts.
     */
    cursor?: TestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestAttempts.
     */
    distinct?: TestAttemptScalarFieldEnum | TestAttemptScalarFieldEnum[]
  }

  /**
   * TestAttempt findMany
   */
  export type TestAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * Filter, which TestAttempts to fetch.
     */
    where?: TestAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestAttempts to fetch.
     */
    orderBy?: TestAttemptOrderByWithRelationInput | TestAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestAttempts.
     */
    cursor?: TestAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestAttempts.
     */
    skip?: number
    distinct?: TestAttemptScalarFieldEnum | TestAttemptScalarFieldEnum[]
  }

  /**
   * TestAttempt create
   */
  export type TestAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a TestAttempt.
     */
    data: XOR<TestAttemptCreateInput, TestAttemptUncheckedCreateInput>
  }

  /**
   * TestAttempt createMany
   */
  export type TestAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestAttempts.
     */
    data: TestAttemptCreateManyInput | TestAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestAttempt createManyAndReturn
   */
  export type TestAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many TestAttempts.
     */
    data: TestAttemptCreateManyInput | TestAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestAttempt update
   */
  export type TestAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a TestAttempt.
     */
    data: XOR<TestAttemptUpdateInput, TestAttemptUncheckedUpdateInput>
    /**
     * Choose, which TestAttempt to update.
     */
    where: TestAttemptWhereUniqueInput
  }

  /**
   * TestAttempt updateMany
   */
  export type TestAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestAttempts.
     */
    data: XOR<TestAttemptUpdateManyMutationInput, TestAttemptUncheckedUpdateManyInput>
    /**
     * Filter which TestAttempts to update
     */
    where?: TestAttemptWhereInput
    /**
     * Limit how many TestAttempts to update.
     */
    limit?: number
  }

  /**
   * TestAttempt updateManyAndReturn
   */
  export type TestAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * The data used to update TestAttempts.
     */
    data: XOR<TestAttemptUpdateManyMutationInput, TestAttemptUncheckedUpdateManyInput>
    /**
     * Filter which TestAttempts to update
     */
    where?: TestAttemptWhereInput
    /**
     * Limit how many TestAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestAttempt upsert
   */
  export type TestAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the TestAttempt to update in case it exists.
     */
    where: TestAttemptWhereUniqueInput
    /**
     * In case the TestAttempt found by the `where` argument doesn't exist, create a new TestAttempt with this data.
     */
    create: XOR<TestAttemptCreateInput, TestAttemptUncheckedCreateInput>
    /**
     * In case the TestAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestAttemptUpdateInput, TestAttemptUncheckedUpdateInput>
  }

  /**
   * TestAttempt delete
   */
  export type TestAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
    /**
     * Filter which TestAttempt to delete.
     */
    where: TestAttemptWhereUniqueInput
  }

  /**
   * TestAttempt deleteMany
   */
  export type TestAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestAttempts to delete
     */
    where?: TestAttemptWhereInput
    /**
     * Limit how many TestAttempts to delete.
     */
    limit?: number
  }

  /**
   * TestAttempt.answers
   */
  export type TestAttempt$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    cursor?: AnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * TestAttempt without action
   */
  export type TestAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestAttempt
     */
    select?: TestAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestAttempt
     */
    omit?: TestAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestAttemptInclude<ExtArgs> | null
  }


  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    testAttemptId: string | null
    questionId: string | null
    alternativeId: string | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    testAttemptId: string | null
    questionId: string | null
    alternativeId: string | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    createdAt: number
    testAttemptId: number
    questionId: number
    alternativeId: number
    _all: number
  }


  export type AnswerMinAggregateInputType = {
    id?: true
    createdAt?: true
    testAttemptId?: true
    questionId?: true
    alternativeId?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    createdAt?: true
    testAttemptId?: true
    questionId?: true
    alternativeId?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    createdAt?: true
    testAttemptId?: true
    questionId?: true
    alternativeId?: true
    _all?: true
  }

  export type AnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithAggregationInput | AnswerOrderByWithAggregationInput[]
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }

  export type AnswerGroupByOutputType = {
    id: string
    createdAt: Date
    testAttemptId: string
    questionId: string
    alternativeId: string | null
    _count: AnswerCountAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    testAttemptId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    testAttempt?: boolean | TestAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    alternative?: boolean | Answer$alternativeArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    testAttemptId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    testAttempt?: boolean | TestAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    alternative?: boolean | Answer$alternativeArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    testAttemptId?: boolean
    questionId?: boolean
    alternativeId?: boolean
    testAttempt?: boolean | TestAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    alternative?: boolean | Answer$alternativeArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectScalar = {
    id?: boolean
    createdAt?: boolean
    testAttemptId?: boolean
    questionId?: boolean
    alternativeId?: boolean
  }

  export type AnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "testAttemptId" | "questionId" | "alternativeId", ExtArgs["result"]["answer"]>
  export type AnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testAttempt?: boolean | TestAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    alternative?: boolean | Answer$alternativeArgs<ExtArgs>
  }
  export type AnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testAttempt?: boolean | TestAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    alternative?: boolean | Answer$alternativeArgs<ExtArgs>
  }
  export type AnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testAttempt?: boolean | TestAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    alternative?: boolean | Answer$alternativeArgs<ExtArgs>
  }

  export type $AnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer"
    objects: {
      testAttempt: Prisma.$TestAttemptPayload<ExtArgs>
      question: Prisma.$QuestionPayload<ExtArgs>
      alternative: Prisma.$AlternativePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      testAttemptId: string
      questionId: string
      alternativeId: string | null
    }, ExtArgs["result"]["answer"]>
    composites: {}
  }

  type AnswerGetPayload<S extends boolean | null | undefined | AnswerDefaultArgs> = $Result.GetResult<Prisma.$AnswerPayload, S>

  type AnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnswerCountAggregateInputType | true
    }

  export interface AnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer'], meta: { name: 'Answer' } }
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnswerFindUniqueArgs>(args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnswerFindFirstArgs>(args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnswerFindManyArgs>(args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
     */
    create<T extends AnswerCreateArgs>(args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answers.
     * @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnswerCreateManyArgs>(args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {AnswerCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answer = await prisma.answer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, AnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
     */
    delete<T extends AnswerDeleteArgs>(args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnswerUpdateArgs>(args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnswerDeleteManyArgs>(args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnswerUpdateManyArgs>(args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers and returns the data updated in the database.
     * @param {AnswerUpdateManyAndReturnArgs} args - Arguments to update many Answers.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Answers and only return the `id`
     * const answerWithIdOnly = await prisma.answer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, AnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
     */
    upsert<T extends AnswerUpsertArgs>(args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): Prisma.PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testAttempt<T extends TestAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestAttemptDefaultArgs<ExtArgs>>): Prisma__TestAttemptClient<$Result.GetResult<Prisma.$TestAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    alternative<T extends Answer$alternativeArgs<ExtArgs> = {}>(args?: Subset<T, Answer$alternativeArgs<ExtArgs>>): Prisma__AlternativeClient<$Result.GetResult<Prisma.$AlternativePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Answer model
   */
  interface AnswerFieldRefs {
    readonly id: FieldRef<"Answer", 'String'>
    readonly createdAt: FieldRef<"Answer", 'DateTime'>
    readonly testAttemptId: FieldRef<"Answer", 'String'>
    readonly questionId: FieldRef<"Answer", 'String'>
    readonly alternativeId: FieldRef<"Answer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }

  /**
   * Answer create
   */
  export type AnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }

  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Answer createManyAndReturn
   */
  export type AnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer update
   */
  export type AnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
  }

  /**
   * Answer updateManyAndReturn
   */
  export type AnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }

  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput
  }

  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput
    /**
     * Limit how many Answers to delete.
     */
    limit?: number
  }

  /**
   * Answer.alternative
   */
  export type Answer$alternativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alternative
     */
    select?: AlternativeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alternative
     */
    omit?: AlternativeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlternativeInclude<ExtArgs> | null
    where?: AlternativeWhereInput
  }

  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Answer
     */
    omit?: AnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnswerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TolinerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    jobDescription: 'jobDescription',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    bankAccount: 'bankAccount',
    identification: 'identification',
    isSuspended: 'isSuspended',
    isActive: 'isActive',
    hasCompletedProfile: 'hasCompletedProfile',
    hasAprovedProfile: 'hasAprovedProfile',
    gainPerOurs: 'gainPerOurs',
    nacionality: 'nacionality'
  };

  export type TolinerScalarFieldEnum = (typeof TolinerScalarFieldEnum)[keyof typeof TolinerScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    type: 'type',
    createdAt: 'createdAt',
    tag: 'tag',
    clientBio: 'clientBio',
    freelancerBio: 'freelancerBio',
    avatarUrl: 'avatarUrl',
    tolinerId: 'tolinerId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId',
    freelancerId: 'freelancerId',
    status: 'status',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    dueDate: 'dueDate',
    concludedAt: 'concludedAt',
    isAproved: 'isAproved',
    isActive: 'isActive'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectSubscriptionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    tolinerId: 'tolinerId',
    estimatedTime: 'estimatedTime',
    requiredInformations: 'requiredInformations',
    similarExperiences: 'similarExperiences',
    proposal: 'proposal',
    quotation: 'quotation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invitation: 'invitation'
  };

  export type ProjectSubscriptionScalarFieldEnum = (typeof ProjectSubscriptionScalarFieldEnum)[keyof typeof ProjectSubscriptionScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubcategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    slug: 'slug',
    categoryId: 'categoryId'
  };

  export type SubcategoryScalarFieldEnum = (typeof SubcategoryScalarFieldEnum)[keyof typeof SubcategoryScalarFieldEnum]


  export const FreelancerEvaluationScalarFieldEnum: {
    id: 'id',
    rate: 'rate',
    tolinerId: 'tolinerId',
    evaluatorId: 'evaluatorId',
    comment: 'comment'
  };

  export type FreelancerEvaluationScalarFieldEnum = (typeof FreelancerEvaluationScalarFieldEnum)[keyof typeof FreelancerEvaluationScalarFieldEnum]


  export const QuotationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    ammount: 'ammount',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type QuotationScalarFieldEnum = (typeof QuotationScalarFieldEnum)[keyof typeof QuotationScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    content: 'content',
    createdAt: 'createdAt',
    conversationId: 'conversationId',
    saw: 'saw',
    hasFile: 'hasFile',
    fileInfo: 'fileInfo'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PortifolioScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    cover: 'cover',
    completedAt: 'completedAt',
    assets: 'assets',
    tolinerId: 'tolinerId'
  };

  export type PortifolioScalarFieldEnum = (typeof PortifolioScalarFieldEnum)[keyof typeof PortifolioScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    ammount: 'ammount',
    createdAt: 'createdAt',
    clientInvoice: 'clientInvoice',
    systemInvoice: 'systemInvoice',
    isVerified: 'isVerified',
    projectId: 'projectId',
    completedAt: 'completedAt',
    tolinerId: 'tolinerId',
    status: 'status',
    freelancerId: 'freelancerId',
    paymentMethod: 'paymentMethod',
    referenceNumber: 'referenceNumber'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ChargeScalarFieldEnum: {
    id: 'id',
    ammount: 'ammount',
    createdAt: 'createdAt',
    isVerified: 'isVerified',
    invoice: 'invoice',
    updatedAt: 'updatedAt',
    referenceNumber: 'referenceNumber',
    status: 'status',
    tolinerId: 'tolinerId'
  };

  export type ChargeScalarFieldEnum = (typeof ChargeScalarFieldEnum)[keyof typeof ChargeScalarFieldEnum]


  export const BalanceScalarFieldEnum: {
    id: 'id',
    ammount: 'ammount',
    updatedAt: 'updatedAt',
    tolinerId: 'tolinerId'
  };

  export type BalanceScalarFieldEnum = (typeof BalanceScalarFieldEnum)[keyof typeof BalanceScalarFieldEnum]


  export const VerificationCodeScalarFieldEnum: {
    id: 'id',
    userEmail: 'userEmail',
    code: 'code',
    expires: 'expires',
    type: 'type'
  };

  export type VerificationCodeScalarFieldEnum = (typeof VerificationCodeScalarFieldEnum)[keyof typeof VerificationCodeScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const CertificationTestScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    timeLimit: 'timeLimit',
    passingScore: 'passingScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    skillId: 'skillId'
  };

  export type CertificationTestScalarFieldEnum = (typeof CertificationTestScalarFieldEnum)[keyof typeof CertificationTestScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    score: 'score',
    explanation: 'explanation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    certificationTestId: 'certificationTestId'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const AlternativeScalarFieldEnum: {
    id: 'id',
    text: 'text',
    isCorrect: 'isCorrect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    questionId: 'questionId'
  };

  export type AlternativeScalarFieldEnum = (typeof AlternativeScalarFieldEnum)[keyof typeof AlternativeScalarFieldEnum]


  export const TestAttemptScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    score: 'score',
    passed: 'passed',
    completionTime: 'completionTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    certificationTestId: 'certificationTestId',
    userId: 'userId'
  };

  export type TestAttemptScalarFieldEnum = (typeof TestAttemptScalarFieldEnum)[keyof typeof TestAttemptScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    testAttemptId: 'testAttemptId',
    questionId: 'questionId',
    alternativeId: 'alternativeId'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'ChargeStatus'
   */
  export type EnumChargeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChargeStatus'>
    


  /**
   * Reference to a field of type 'ChargeStatus[]'
   */
  export type ListEnumChargeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChargeStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TolinerWhereInput = {
    AND?: TolinerWhereInput | TolinerWhereInput[]
    OR?: TolinerWhereInput[]
    NOT?: TolinerWhereInput | TolinerWhereInput[]
    id?: StringFilter<"Toliner"> | string
    name?: StringFilter<"Toliner"> | string
    email?: StringFilter<"Toliner"> | string
    jobDescription?: StringNullableFilter<"Toliner"> | string | null
    isVerified?: BoolFilter<"Toliner"> | boolean
    createdAt?: DateTimeFilter<"Toliner"> | Date | string
    bankAccount?: JsonNullableFilter<"Toliner">
    identification?: JsonNullableFilter<"Toliner">
    isSuspended?: BoolFilter<"Toliner"> | boolean
    isActive?: BoolFilter<"Toliner"> | boolean
    hasCompletedProfile?: BoolFilter<"Toliner"> | boolean
    hasAprovedProfile?: BoolFilter<"Toliner"> | boolean
    gainPerOurs?: FloatNullableFilter<"Toliner"> | number | null
    nacionality?: StringNullableFilter<"Toliner"> | string | null
    projectsOwned?: ProjectListRelationFilter
    projectsFreelanced?: ProjectListRelationFilter
    subscriptions?: ProjectSubscriptionListRelationFilter
    specialization?: CategoryListRelationFilter
    portifolio?: PortifolioListRelationFilter
    freelancerEvaluation?: FreelancerEvaluationListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    charges?: ChargeListRelationFilter
    balance?: XOR<BalanceNullableScalarRelationFilter, BalanceWhereInput> | null
    payments?: PaymentListRelationFilter
    freelancerPayments?: PaymentListRelationFilter
  }

  export type TolinerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    jobDescription?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    bankAccount?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    isSuspended?: SortOrder
    isActive?: SortOrder
    hasCompletedProfile?: SortOrder
    hasAprovedProfile?: SortOrder
    gainPerOurs?: SortOrderInput | SortOrder
    nacionality?: SortOrderInput | SortOrder
    projectsOwned?: ProjectOrderByRelationAggregateInput
    projectsFreelanced?: ProjectOrderByRelationAggregateInput
    subscriptions?: ProjectSubscriptionOrderByRelationAggregateInput
    specialization?: CategoryOrderByRelationAggregateInput
    portifolio?: PortifolioOrderByRelationAggregateInput
    freelancerEvaluation?: FreelancerEvaluationOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    charges?: ChargeOrderByRelationAggregateInput
    balance?: BalanceOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    freelancerPayments?: PaymentOrderByRelationAggregateInput
  }

  export type TolinerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: TolinerWhereInput | TolinerWhereInput[]
    OR?: TolinerWhereInput[]
    NOT?: TolinerWhereInput | TolinerWhereInput[]
    name?: StringFilter<"Toliner"> | string
    jobDescription?: StringNullableFilter<"Toliner"> | string | null
    isVerified?: BoolFilter<"Toliner"> | boolean
    createdAt?: DateTimeFilter<"Toliner"> | Date | string
    bankAccount?: JsonNullableFilter<"Toliner">
    identification?: JsonNullableFilter<"Toliner">
    isSuspended?: BoolFilter<"Toliner"> | boolean
    isActive?: BoolFilter<"Toliner"> | boolean
    hasCompletedProfile?: BoolFilter<"Toliner"> | boolean
    hasAprovedProfile?: BoolFilter<"Toliner"> | boolean
    gainPerOurs?: FloatNullableFilter<"Toliner"> | number | null
    nacionality?: StringNullableFilter<"Toliner"> | string | null
    projectsOwned?: ProjectListRelationFilter
    projectsFreelanced?: ProjectListRelationFilter
    subscriptions?: ProjectSubscriptionListRelationFilter
    specialization?: CategoryListRelationFilter
    portifolio?: PortifolioListRelationFilter
    freelancerEvaluation?: FreelancerEvaluationListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    charges?: ChargeListRelationFilter
    balance?: XOR<BalanceNullableScalarRelationFilter, BalanceWhereInput> | null
    payments?: PaymentListRelationFilter
    freelancerPayments?: PaymentListRelationFilter
  }, "id" | "email">

  export type TolinerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    jobDescription?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    bankAccount?: SortOrderInput | SortOrder
    identification?: SortOrderInput | SortOrder
    isSuspended?: SortOrder
    isActive?: SortOrder
    hasCompletedProfile?: SortOrder
    hasAprovedProfile?: SortOrder
    gainPerOurs?: SortOrderInput | SortOrder
    nacionality?: SortOrderInput | SortOrder
    _count?: TolinerCountOrderByAggregateInput
    _avg?: TolinerAvgOrderByAggregateInput
    _max?: TolinerMaxOrderByAggregateInput
    _min?: TolinerMinOrderByAggregateInput
    _sum?: TolinerSumOrderByAggregateInput
  }

  export type TolinerScalarWhereWithAggregatesInput = {
    AND?: TolinerScalarWhereWithAggregatesInput | TolinerScalarWhereWithAggregatesInput[]
    OR?: TolinerScalarWhereWithAggregatesInput[]
    NOT?: TolinerScalarWhereWithAggregatesInput | TolinerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Toliner"> | string
    name?: StringWithAggregatesFilter<"Toliner"> | string
    email?: StringWithAggregatesFilter<"Toliner"> | string
    jobDescription?: StringNullableWithAggregatesFilter<"Toliner"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Toliner"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Toliner"> | Date | string
    bankAccount?: JsonNullableWithAggregatesFilter<"Toliner">
    identification?: JsonNullableWithAggregatesFilter<"Toliner">
    isSuspended?: BoolWithAggregatesFilter<"Toliner"> | boolean
    isActive?: BoolWithAggregatesFilter<"Toliner"> | boolean
    hasCompletedProfile?: BoolWithAggregatesFilter<"Toliner"> | boolean
    hasAprovedProfile?: BoolWithAggregatesFilter<"Toliner"> | boolean
    gainPerOurs?: FloatNullableWithAggregatesFilter<"Toliner"> | number | null
    nacionality?: StringNullableWithAggregatesFilter<"Toliner"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    type?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    tag?: StringFilter<"User"> | string
    clientBio?: StringNullableFilter<"User"> | string | null
    freelancerBio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    tolinerId?: StringFilter<"User"> | string
    conversations?: ConversationListRelationFilter
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    skills?: SkillListRelationFilter
    TestAttempt?: TestAttemptListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    username?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    tag?: SortOrder
    clientBio?: SortOrderInput | SortOrder
    freelancerBio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    tolinerId?: SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    toliner?: TolinerOrderByWithRelationInput
    skills?: SkillOrderByRelationAggregateInput
    TestAttempt?: TestAttemptOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    tag?: string
    tolinerId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    type?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    clientBio?: StringNullableFilter<"User"> | string | null
    freelancerBio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    conversations?: ConversationListRelationFilter
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    skills?: SkillListRelationFilter
    TestAttempt?: TestAttemptListRelationFilter
  }, "id" | "email" | "tag" | "tolinerId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    username?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    tag?: SortOrder
    clientBio?: SortOrderInput | SortOrder
    freelancerBio?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    tolinerId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    type?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    tag?: StringWithAggregatesFilter<"User"> | string
    clientBio?: StringNullableWithAggregatesFilter<"User"> | string | null
    freelancerBio?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    tolinerId?: StringWithAggregatesFilter<"User"> | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    freelancerId?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    categoryId?: StringNullableFilter<"Project"> | string | null
    subcategoryId?: StringNullableFilter<"Project"> | string | null
    dueDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    concludedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    isAproved?: BoolFilter<"Project"> | boolean
    isActive?: BoolFilter<"Project"> | boolean
    owner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    freelancer?: XOR<TolinerNullableScalarRelationFilter, TolinerWhereInput> | null
    subscriptions?: ProjectSubscriptionListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    skills?: SkillListRelationFilter
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    conversations?: ConversationListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    freelancerId?: SortOrderInput | SortOrder
    status?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    concludedAt?: SortOrderInput | SortOrder
    isAproved?: SortOrder
    isActive?: SortOrder
    owner?: TolinerOrderByWithRelationInput
    freelancer?: TolinerOrderByWithRelationInput
    subscriptions?: ProjectSubscriptionOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    skills?: SkillOrderByRelationAggregateInput
    quotation?: QuotationOrderByWithRelationInput
    conversations?: ConversationOrderByRelationAggregateInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_categoryId_ownerId?: ProjectNameCategoryIdOwnerIdCompoundUniqueInput
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    freelancerId?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    categoryId?: StringNullableFilter<"Project"> | string | null
    subcategoryId?: StringNullableFilter<"Project"> | string | null
    dueDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    concludedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    isAproved?: BoolFilter<"Project"> | boolean
    isActive?: BoolFilter<"Project"> | boolean
    owner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    freelancer?: XOR<TolinerNullableScalarRelationFilter, TolinerWhereInput> | null
    subscriptions?: ProjectSubscriptionListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    skills?: SkillListRelationFilter
    quotation?: XOR<QuotationNullableScalarRelationFilter, QuotationWhereInput> | null
    conversations?: ConversationListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }, "id" | "name_categoryId_ownerId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    freelancerId?: SortOrderInput | SortOrder
    status?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    concludedAt?: SortOrderInput | SortOrder
    isAproved?: SortOrder
    isActive?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    ownerId?: StringWithAggregatesFilter<"Project"> | string
    freelancerId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    categoryId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    subcategoryId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    concludedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    isAproved?: BoolWithAggregatesFilter<"Project"> | boolean
    isActive?: BoolWithAggregatesFilter<"Project"> | boolean
  }

  export type ProjectSubscriptionWhereInput = {
    AND?: ProjectSubscriptionWhereInput | ProjectSubscriptionWhereInput[]
    OR?: ProjectSubscriptionWhereInput[]
    NOT?: ProjectSubscriptionWhereInput | ProjectSubscriptionWhereInput[]
    id?: StringFilter<"ProjectSubscription"> | string
    projectId?: StringFilter<"ProjectSubscription"> | string
    tolinerId?: StringFilter<"ProjectSubscription"> | string
    estimatedTime?: StringNullableFilter<"ProjectSubscription"> | string | null
    requiredInformations?: StringNullableFilter<"ProjectSubscription"> | string | null
    similarExperiences?: StringNullableFilter<"ProjectSubscription"> | string | null
    proposal?: StringFilter<"ProjectSubscription"> | string
    quotation?: FloatNullableFilter<"ProjectSubscription"> | number | null
    createdAt?: DateTimeFilter<"ProjectSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectSubscription"> | Date | string
    invitation?: JsonNullableFilter<"ProjectSubscription">
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    tolinerId?: SortOrder
    estimatedTime?: SortOrderInput | SortOrder
    requiredInformations?: SortOrderInput | SortOrder
    similarExperiences?: SortOrderInput | SortOrder
    proposal?: SortOrder
    quotation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitation?: SortOrderInput | SortOrder
    toliner?: TolinerOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_tolinerId?: ProjectSubscriptionProjectIdTolinerIdCompoundUniqueInput
    AND?: ProjectSubscriptionWhereInput | ProjectSubscriptionWhereInput[]
    OR?: ProjectSubscriptionWhereInput[]
    NOT?: ProjectSubscriptionWhereInput | ProjectSubscriptionWhereInput[]
    projectId?: StringFilter<"ProjectSubscription"> | string
    tolinerId?: StringFilter<"ProjectSubscription"> | string
    estimatedTime?: StringNullableFilter<"ProjectSubscription"> | string | null
    requiredInformations?: StringNullableFilter<"ProjectSubscription"> | string | null
    similarExperiences?: StringNullableFilter<"ProjectSubscription"> | string | null
    proposal?: StringFilter<"ProjectSubscription"> | string
    quotation?: FloatNullableFilter<"ProjectSubscription"> | number | null
    createdAt?: DateTimeFilter<"ProjectSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectSubscription"> | Date | string
    invitation?: JsonNullableFilter<"ProjectSubscription">
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId_tolinerId">

  export type ProjectSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    tolinerId?: SortOrder
    estimatedTime?: SortOrderInput | SortOrder
    requiredInformations?: SortOrderInput | SortOrder
    similarExperiences?: SortOrderInput | SortOrder
    proposal?: SortOrder
    quotation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitation?: SortOrderInput | SortOrder
    _count?: ProjectSubscriptionCountOrderByAggregateInput
    _avg?: ProjectSubscriptionAvgOrderByAggregateInput
    _max?: ProjectSubscriptionMaxOrderByAggregateInput
    _min?: ProjectSubscriptionMinOrderByAggregateInput
    _sum?: ProjectSubscriptionSumOrderByAggregateInput
  }

  export type ProjectSubscriptionScalarWhereWithAggregatesInput = {
    AND?: ProjectSubscriptionScalarWhereWithAggregatesInput | ProjectSubscriptionScalarWhereWithAggregatesInput[]
    OR?: ProjectSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: ProjectSubscriptionScalarWhereWithAggregatesInput | ProjectSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectSubscription"> | string
    projectId?: StringWithAggregatesFilter<"ProjectSubscription"> | string
    tolinerId?: StringWithAggregatesFilter<"ProjectSubscription"> | string
    estimatedTime?: StringNullableWithAggregatesFilter<"ProjectSubscription"> | string | null
    requiredInformations?: StringNullableWithAggregatesFilter<"ProjectSubscription"> | string | null
    similarExperiences?: StringNullableWithAggregatesFilter<"ProjectSubscription"> | string | null
    proposal?: StringWithAggregatesFilter<"ProjectSubscription"> | string
    quotation?: FloatNullableWithAggregatesFilter<"ProjectSubscription"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectSubscription"> | Date | string
    invitation?: JsonNullableWithAggregatesFilter<"ProjectSubscription">
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
    skills?: SkillListRelationFilter
    toliners?: TolinerListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    projects?: ProjectListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    skills?: SkillOrderByRelationAggregateInput
    toliners?: TolinerOrderByRelationAggregateInput
    subcategories?: SubcategoryOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    skills?: SkillListRelationFilter
    toliners?: TolinerListRelationFilter
    subcategories?: SubcategoryListRelationFilter
    projects?: ProjectListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    slug?: StringWithAggregatesFilter<"Category"> | string
  }

  export type SubcategoryWhereInput = {
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    slug?: StringFilter<"Subcategory"> | string
    categoryId?: StringNullableFilter<"Subcategory"> | string | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }

  export type SubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
  }

  export type SubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId_name?: SubcategoryCategoryIdNameCompoundUniqueInput
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    slug?: StringFilter<"Subcategory"> | string
    categoryId?: StringNullableFilter<"Subcategory"> | string | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }, "id" | "categoryId_name">

  export type SubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    slug?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    _count?: SubcategoryCountOrderByAggregateInput
    _max?: SubcategoryMaxOrderByAggregateInput
    _min?: SubcategoryMinOrderByAggregateInput
  }

  export type SubcategoryScalarWhereWithAggregatesInput = {
    AND?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    OR?: SubcategoryScalarWhereWithAggregatesInput[]
    NOT?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subcategory"> | string
    name?: StringWithAggregatesFilter<"Subcategory"> | string
    description?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
    slug?: StringWithAggregatesFilter<"Subcategory"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Subcategory"> | string | null
  }

  export type FreelancerEvaluationWhereInput = {
    AND?: FreelancerEvaluationWhereInput | FreelancerEvaluationWhereInput[]
    OR?: FreelancerEvaluationWhereInput[]
    NOT?: FreelancerEvaluationWhereInput | FreelancerEvaluationWhereInput[]
    id?: StringFilter<"FreelancerEvaluation"> | string
    rate?: StringFilter<"FreelancerEvaluation"> | string
    tolinerId?: StringFilter<"FreelancerEvaluation"> | string
    evaluatorId?: StringFilter<"FreelancerEvaluation"> | string
    comment?: StringFilter<"FreelancerEvaluation"> | string
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
  }

  export type FreelancerEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    rate?: SortOrder
    tolinerId?: SortOrder
    evaluatorId?: SortOrder
    comment?: SortOrder
    toliner?: TolinerOrderByWithRelationInput
  }

  export type FreelancerEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tolinerId_evaluatorId?: FreelancerEvaluationTolinerIdEvaluatorIdCompoundUniqueInput
    AND?: FreelancerEvaluationWhereInput | FreelancerEvaluationWhereInput[]
    OR?: FreelancerEvaluationWhereInput[]
    NOT?: FreelancerEvaluationWhereInput | FreelancerEvaluationWhereInput[]
    rate?: StringFilter<"FreelancerEvaluation"> | string
    tolinerId?: StringFilter<"FreelancerEvaluation"> | string
    evaluatorId?: StringFilter<"FreelancerEvaluation"> | string
    comment?: StringFilter<"FreelancerEvaluation"> | string
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
  }, "id" | "tolinerId_evaluatorId">

  export type FreelancerEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    rate?: SortOrder
    tolinerId?: SortOrder
    evaluatorId?: SortOrder
    comment?: SortOrder
    _count?: FreelancerEvaluationCountOrderByAggregateInput
    _max?: FreelancerEvaluationMaxOrderByAggregateInput
    _min?: FreelancerEvaluationMinOrderByAggregateInput
  }

  export type FreelancerEvaluationScalarWhereWithAggregatesInput = {
    AND?: FreelancerEvaluationScalarWhereWithAggregatesInput | FreelancerEvaluationScalarWhereWithAggregatesInput[]
    OR?: FreelancerEvaluationScalarWhereWithAggregatesInput[]
    NOT?: FreelancerEvaluationScalarWhereWithAggregatesInput | FreelancerEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FreelancerEvaluation"> | string
    rate?: StringWithAggregatesFilter<"FreelancerEvaluation"> | string
    tolinerId?: StringWithAggregatesFilter<"FreelancerEvaluation"> | string
    evaluatorId?: StringWithAggregatesFilter<"FreelancerEvaluation"> | string
    comment?: StringWithAggregatesFilter<"FreelancerEvaluation"> | string
  }

  export type QuotationWhereInput = {
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    id?: StringFilter<"Quotation"> | string
    projectId?: StringFilter<"Quotation"> | string
    ammount?: IntFilter<"Quotation"> | number
    description?: StringNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type QuotationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    ammount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type QuotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: QuotationWhereInput | QuotationWhereInput[]
    OR?: QuotationWhereInput[]
    NOT?: QuotationWhereInput | QuotationWhereInput[]
    ammount?: IntFilter<"Quotation"> | number
    description?: StringNullableFilter<"Quotation"> | string | null
    createdAt?: DateTimeFilter<"Quotation"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type QuotationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    ammount?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuotationCountOrderByAggregateInput
    _avg?: QuotationAvgOrderByAggregateInput
    _max?: QuotationMaxOrderByAggregateInput
    _min?: QuotationMinOrderByAggregateInput
    _sum?: QuotationSumOrderByAggregateInput
  }

  export type QuotationScalarWhereWithAggregatesInput = {
    AND?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    OR?: QuotationScalarWhereWithAggregatesInput[]
    NOT?: QuotationScalarWhereWithAggregatesInput | QuotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quotation"> | string
    projectId?: StringWithAggregatesFilter<"Quotation"> | string
    ammount?: IntWithAggregatesFilter<"Quotation"> | number
    description?: StringNullableWithAggregatesFilter<"Quotation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quotation"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    projectId?: StringNullableFilter<"Conversation"> | string | null
    members?: UserListRelationFilter
    messages?: MessageListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    members?: UserOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    project?: ProjectOrderByWithRelationInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    projectId?: StringNullableFilter<"Conversation"> | string | null
    members?: UserListRelationFilter
    messages?: MessageListRelationFilter
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    projectId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    saw?: BoolFilter<"Message"> | boolean
    hasFile?: BoolFilter<"Message"> | boolean
    fileInfo?: JsonNullableFilter<"Message">
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    saw?: SortOrder
    hasFile?: SortOrder
    fileInfo?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    saw?: BoolFilter<"Message"> | boolean
    hasFile?: BoolFilter<"Message"> | boolean
    fileInfo?: JsonNullableFilter<"Message">
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    saw?: SortOrder
    hasFile?: SortOrder
    fileInfo?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    saw?: BoolWithAggregatesFilter<"Message"> | boolean
    hasFile?: BoolWithAggregatesFilter<"Message"> | boolean
    fileInfo?: JsonNullableWithAggregatesFilter<"Message">
  }

  export type PortifolioWhereInput = {
    AND?: PortifolioWhereInput | PortifolioWhereInput[]
    OR?: PortifolioWhereInput[]
    NOT?: PortifolioWhereInput | PortifolioWhereInput[]
    id?: StringFilter<"Portifolio"> | string
    title?: StringFilter<"Portifolio"> | string
    description?: StringFilter<"Portifolio"> | string
    cover?: StringFilter<"Portifolio"> | string
    completedAt?: StringNullableFilter<"Portifolio"> | string | null
    assets?: JsonFilter<"Portifolio">
    tolinerId?: StringNullableFilter<"Portifolio"> | string | null
    skills?: SkillListRelationFilter
    toliner?: XOR<TolinerNullableScalarRelationFilter, TolinerWhereInput> | null
  }

  export type PortifolioOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    assets?: SortOrder
    tolinerId?: SortOrderInput | SortOrder
    skills?: SkillOrderByRelationAggregateInput
    toliner?: TolinerOrderByWithRelationInput
  }

  export type PortifolioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tolinerId?: string
    title_tolinerId?: PortifolioTitleTolinerIdCompoundUniqueInput
    AND?: PortifolioWhereInput | PortifolioWhereInput[]
    OR?: PortifolioWhereInput[]
    NOT?: PortifolioWhereInput | PortifolioWhereInput[]
    title?: StringFilter<"Portifolio"> | string
    description?: StringFilter<"Portifolio"> | string
    cover?: StringFilter<"Portifolio"> | string
    completedAt?: StringNullableFilter<"Portifolio"> | string | null
    assets?: JsonFilter<"Portifolio">
    skills?: SkillListRelationFilter
    toliner?: XOR<TolinerNullableScalarRelationFilter, TolinerWhereInput> | null
  }, "id" | "tolinerId" | "title_tolinerId">

  export type PortifolioOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    assets?: SortOrder
    tolinerId?: SortOrderInput | SortOrder
    _count?: PortifolioCountOrderByAggregateInput
    _max?: PortifolioMaxOrderByAggregateInput
    _min?: PortifolioMinOrderByAggregateInput
  }

  export type PortifolioScalarWhereWithAggregatesInput = {
    AND?: PortifolioScalarWhereWithAggregatesInput | PortifolioScalarWhereWithAggregatesInput[]
    OR?: PortifolioScalarWhereWithAggregatesInput[]
    NOT?: PortifolioScalarWhereWithAggregatesInput | PortifolioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Portifolio"> | string
    title?: StringWithAggregatesFilter<"Portifolio"> | string
    description?: StringWithAggregatesFilter<"Portifolio"> | string
    cover?: StringWithAggregatesFilter<"Portifolio"> | string
    completedAt?: StringNullableWithAggregatesFilter<"Portifolio"> | string | null
    assets?: JsonWithAggregatesFilter<"Portifolio">
    tolinerId?: StringNullableWithAggregatesFilter<"Portifolio"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    ammount?: FloatFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    clientInvoice?: StringNullableFilter<"Payment"> | string | null
    systemInvoice?: StringNullableFilter<"Payment"> | string | null
    isVerified?: BoolFilter<"Payment"> | boolean
    projectId?: StringFilter<"Payment"> | string
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    tolinerId?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    freelancerId?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    freelancer?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    clientInvoice?: SortOrderInput | SortOrder
    systemInvoice?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    projectId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    tolinerId?: SortOrder
    status?: SortOrder
    freelancerId?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    toliner?: TolinerOrderByWithRelationInput
    freelancer?: TolinerOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    ammount?: FloatFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    clientInvoice?: StringNullableFilter<"Payment"> | string | null
    systemInvoice?: StringNullableFilter<"Payment"> | string | null
    isVerified?: BoolFilter<"Payment"> | boolean
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    tolinerId?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    freelancerId?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
    freelancer?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
  }, "id" | "projectId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    clientInvoice?: SortOrderInput | SortOrder
    systemInvoice?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    projectId?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    tolinerId?: SortOrder
    status?: SortOrder
    freelancerId?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    ammount?: FloatWithAggregatesFilter<"Payment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    clientInvoice?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    systemInvoice?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Payment"> | boolean
    projectId?: StringWithAggregatesFilter<"Payment"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    tolinerId?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    freelancerId?: StringWithAggregatesFilter<"Payment"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    referenceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type ChargeWhereInput = {
    AND?: ChargeWhereInput | ChargeWhereInput[]
    OR?: ChargeWhereInput[]
    NOT?: ChargeWhereInput | ChargeWhereInput[]
    id?: StringFilter<"Charge"> | string
    ammount?: FloatFilter<"Charge"> | number
    createdAt?: DateTimeFilter<"Charge"> | Date | string
    isVerified?: BoolFilter<"Charge"> | boolean
    invoice?: StringFilter<"Charge"> | string
    updatedAt?: DateTimeFilter<"Charge"> | Date | string
    referenceNumber?: StringNullableFilter<"Charge"> | string | null
    status?: EnumChargeStatusFilter<"Charge"> | $Enums.ChargeStatus
    tolinerId?: StringFilter<"Charge"> | string
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
  }

  export type ChargeOrderByWithRelationInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    invoice?: SortOrder
    updatedAt?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    tolinerId?: SortOrder
    toliner?: TolinerOrderByWithRelationInput
  }

  export type ChargeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChargeWhereInput | ChargeWhereInput[]
    OR?: ChargeWhereInput[]
    NOT?: ChargeWhereInput | ChargeWhereInput[]
    ammount?: FloatFilter<"Charge"> | number
    createdAt?: DateTimeFilter<"Charge"> | Date | string
    isVerified?: BoolFilter<"Charge"> | boolean
    invoice?: StringFilter<"Charge"> | string
    updatedAt?: DateTimeFilter<"Charge"> | Date | string
    referenceNumber?: StringNullableFilter<"Charge"> | string | null
    status?: EnumChargeStatusFilter<"Charge"> | $Enums.ChargeStatus
    tolinerId?: StringFilter<"Charge"> | string
    toliner?: XOR<TolinerScalarRelationFilter, TolinerWhereInput>
  }, "id">

  export type ChargeOrderByWithAggregationInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    invoice?: SortOrder
    updatedAt?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    status?: SortOrder
    tolinerId?: SortOrder
    _count?: ChargeCountOrderByAggregateInput
    _avg?: ChargeAvgOrderByAggregateInput
    _max?: ChargeMaxOrderByAggregateInput
    _min?: ChargeMinOrderByAggregateInput
    _sum?: ChargeSumOrderByAggregateInput
  }

  export type ChargeScalarWhereWithAggregatesInput = {
    AND?: ChargeScalarWhereWithAggregatesInput | ChargeScalarWhereWithAggregatesInput[]
    OR?: ChargeScalarWhereWithAggregatesInput[]
    NOT?: ChargeScalarWhereWithAggregatesInput | ChargeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Charge"> | string
    ammount?: FloatWithAggregatesFilter<"Charge"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Charge"> | Date | string
    isVerified?: BoolWithAggregatesFilter<"Charge"> | boolean
    invoice?: StringWithAggregatesFilter<"Charge"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Charge"> | Date | string
    referenceNumber?: StringNullableWithAggregatesFilter<"Charge"> | string | null
    status?: EnumChargeStatusWithAggregatesFilter<"Charge"> | $Enums.ChargeStatus
    tolinerId?: StringWithAggregatesFilter<"Charge"> | string
  }

  export type BalanceWhereInput = {
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    id?: StringFilter<"Balance"> | string
    ammount?: FloatFilter<"Balance"> | number
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    tolinerId?: StringNullableFilter<"Balance"> | string | null
    toliner?: XOR<TolinerNullableScalarRelationFilter, TolinerWhereInput> | null
  }

  export type BalanceOrderByWithRelationInput = {
    id?: SortOrder
    ammount?: SortOrder
    updatedAt?: SortOrder
    tolinerId?: SortOrderInput | SortOrder
    toliner?: TolinerOrderByWithRelationInput
  }

  export type BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tolinerId?: string
    AND?: BalanceWhereInput | BalanceWhereInput[]
    OR?: BalanceWhereInput[]
    NOT?: BalanceWhereInput | BalanceWhereInput[]
    ammount?: FloatFilter<"Balance"> | number
    updatedAt?: DateTimeFilter<"Balance"> | Date | string
    toliner?: XOR<TolinerNullableScalarRelationFilter, TolinerWhereInput> | null
  }, "id" | "tolinerId">

  export type BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    ammount?: SortOrder
    updatedAt?: SortOrder
    tolinerId?: SortOrderInput | SortOrder
    _count?: BalanceCountOrderByAggregateInput
    _avg?: BalanceAvgOrderByAggregateInput
    _max?: BalanceMaxOrderByAggregateInput
    _min?: BalanceMinOrderByAggregateInput
    _sum?: BalanceSumOrderByAggregateInput
  }

  export type BalanceScalarWhereWithAggregatesInput = {
    AND?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    OR?: BalanceScalarWhereWithAggregatesInput[]
    NOT?: BalanceScalarWhereWithAggregatesInput | BalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Balance"> | string
    ammount?: FloatWithAggregatesFilter<"Balance"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Balance"> | Date | string
    tolinerId?: StringNullableWithAggregatesFilter<"Balance"> | string | null
  }

  export type VerificationCodeWhereInput = {
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    id?: StringFilter<"VerificationCode"> | string
    userEmail?: StringFilter<"VerificationCode"> | string
    code?: StringFilter<"VerificationCode"> | string
    expires?: DateTimeFilter<"VerificationCode"> | Date | string
    type?: StringFilter<"VerificationCode"> | string
  }

  export type VerificationCodeOrderByWithRelationInput = {
    id?: SortOrder
    userEmail?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
  }

  export type VerificationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userEmail?: string
    userEmail_code?: VerificationCodeUserEmailCodeCompoundUniqueInput
    AND?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    OR?: VerificationCodeWhereInput[]
    NOT?: VerificationCodeWhereInput | VerificationCodeWhereInput[]
    code?: StringFilter<"VerificationCode"> | string
    expires?: DateTimeFilter<"VerificationCode"> | Date | string
    type?: StringFilter<"VerificationCode"> | string
  }, "id" | "userEmail" | "userEmail_code">

  export type VerificationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    userEmail?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
    _count?: VerificationCodeCountOrderByAggregateInput
    _max?: VerificationCodeMaxOrderByAggregateInput
    _min?: VerificationCodeMinOrderByAggregateInput
  }

  export type VerificationCodeScalarWhereWithAggregatesInput = {
    AND?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    OR?: VerificationCodeScalarWhereWithAggregatesInput[]
    NOT?: VerificationCodeScalarWhereWithAggregatesInput | VerificationCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationCode"> | string
    userEmail?: StringWithAggregatesFilter<"VerificationCode"> | string
    code?: StringWithAggregatesFilter<"VerificationCode"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationCode"> | Date | string
    type?: StringWithAggregatesFilter<"VerificationCode"> | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    slug?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    categoryId?: StringNullableFilter<"Skill"> | string | null
    subcategoryId?: StringNullableFilter<"Skill"> | string | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    users?: UserListRelationFilter
    portifolios?: PortifolioListRelationFilter
    projects?: ProjectListRelationFilter
    certificationTest?: XOR<CertificationTestNullableScalarRelationFilter, CertificationTestWhereInput> | null
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    portifolios?: PortifolioOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    certificationTest?: CertificationTestOrderByWithRelationInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    subcategoryId_categoryId_name?: SkillSubcategoryIdCategoryIdNameCompoundUniqueInput
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    name?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    categoryId?: StringNullableFilter<"Skill"> | string | null
    subcategoryId?: StringNullableFilter<"Skill"> | string | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    users?: UserListRelationFilter
    portifolios?: PortifolioListRelationFilter
    projects?: ProjectListRelationFilter
    certificationTest?: XOR<CertificationTestNullableScalarRelationFilter, CertificationTestWhereInput> | null
  }, "id" | "slug" | "subcategoryId_categoryId_name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    subcategoryId?: SortOrderInput | SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    slug?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    categoryId?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    subcategoryId?: StringNullableWithAggregatesFilter<"Skill"> | string | null
  }

  export type CertificationTestWhereInput = {
    AND?: CertificationTestWhereInput | CertificationTestWhereInput[]
    OR?: CertificationTestWhereInput[]
    NOT?: CertificationTestWhereInput | CertificationTestWhereInput[]
    id?: StringFilter<"CertificationTest"> | string
    title?: StringFilter<"CertificationTest"> | string
    description?: StringNullableFilter<"CertificationTest"> | string | null
    timeLimit?: IntNullableFilter<"CertificationTest"> | number | null
    passingScore?: FloatFilter<"CertificationTest"> | number
    createdAt?: DateTimeFilter<"CertificationTest"> | Date | string
    updatedAt?: DateTimeFilter<"CertificationTest"> | Date | string
    skillId?: StringFilter<"CertificationTest"> | string
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
    questions?: QuestionListRelationFilter
    attempts?: TestAttemptListRelationFilter
  }

  export type CertificationTestOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skillId?: SortOrder
    skill?: SkillOrderByWithRelationInput
    questions?: QuestionOrderByRelationAggregateInput
    attempts?: TestAttemptOrderByRelationAggregateInput
  }

  export type CertificationTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    skillId?: string
    AND?: CertificationTestWhereInput | CertificationTestWhereInput[]
    OR?: CertificationTestWhereInput[]
    NOT?: CertificationTestWhereInput | CertificationTestWhereInput[]
    title?: StringFilter<"CertificationTest"> | string
    description?: StringNullableFilter<"CertificationTest"> | string | null
    timeLimit?: IntNullableFilter<"CertificationTest"> | number | null
    passingScore?: FloatFilter<"CertificationTest"> | number
    createdAt?: DateTimeFilter<"CertificationTest"> | Date | string
    updatedAt?: DateTimeFilter<"CertificationTest"> | Date | string
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
    questions?: QuestionListRelationFilter
    attempts?: TestAttemptListRelationFilter
  }, "id" | "skillId">

  export type CertificationTestOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skillId?: SortOrder
    _count?: CertificationTestCountOrderByAggregateInput
    _avg?: CertificationTestAvgOrderByAggregateInput
    _max?: CertificationTestMaxOrderByAggregateInput
    _min?: CertificationTestMinOrderByAggregateInput
    _sum?: CertificationTestSumOrderByAggregateInput
  }

  export type CertificationTestScalarWhereWithAggregatesInput = {
    AND?: CertificationTestScalarWhereWithAggregatesInput | CertificationTestScalarWhereWithAggregatesInput[]
    OR?: CertificationTestScalarWhereWithAggregatesInput[]
    NOT?: CertificationTestScalarWhereWithAggregatesInput | CertificationTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CertificationTest"> | string
    title?: StringWithAggregatesFilter<"CertificationTest"> | string
    description?: StringNullableWithAggregatesFilter<"CertificationTest"> | string | null
    timeLimit?: IntNullableWithAggregatesFilter<"CertificationTest"> | number | null
    passingScore?: FloatWithAggregatesFilter<"CertificationTest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CertificationTest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CertificationTest"> | Date | string
    skillId?: StringWithAggregatesFilter<"CertificationTest"> | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    score?: FloatFilter<"Question"> | number
    explanation?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    certificationTestId?: StringFilter<"Question"> | string
    certificationTest?: XOR<CertificationTestScalarRelationFilter, CertificationTestWhereInput>
    alternatives?: AlternativeListRelationFilter
    answers?: AnswerListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    score?: SortOrder
    explanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    certificationTest?: CertificationTestOrderByWithRelationInput
    alternatives?: AlternativeOrderByRelationAggregateInput
    answers?: AnswerOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    text?: StringFilter<"Question"> | string
    score?: FloatFilter<"Question"> | number
    explanation?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    certificationTestId?: StringFilter<"Question"> | string
    certificationTest?: XOR<CertificationTestScalarRelationFilter, CertificationTestWhereInput>
    alternatives?: AlternativeListRelationFilter
    answers?: AnswerListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    score?: SortOrder
    explanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    text?: StringWithAggregatesFilter<"Question"> | string
    score?: FloatWithAggregatesFilter<"Question"> | number
    explanation?: StringNullableWithAggregatesFilter<"Question"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    certificationTestId?: StringWithAggregatesFilter<"Question"> | string
  }

  export type AlternativeWhereInput = {
    AND?: AlternativeWhereInput | AlternativeWhereInput[]
    OR?: AlternativeWhereInput[]
    NOT?: AlternativeWhereInput | AlternativeWhereInput[]
    id?: StringFilter<"Alternative"> | string
    text?: StringFilter<"Alternative"> | string
    isCorrect?: BoolFilter<"Alternative"> | boolean
    createdAt?: DateTimeFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeFilter<"Alternative"> | Date | string
    questionId?: StringFilter<"Alternative"> | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    answers?: AnswerListRelationFilter
  }

  export type AlternativeOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionId?: SortOrder
    question?: QuestionOrderByWithRelationInput
    answers?: AnswerOrderByRelationAggregateInput
  }

  export type AlternativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlternativeWhereInput | AlternativeWhereInput[]
    OR?: AlternativeWhereInput[]
    NOT?: AlternativeWhereInput | AlternativeWhereInput[]
    text?: StringFilter<"Alternative"> | string
    isCorrect?: BoolFilter<"Alternative"> | boolean
    createdAt?: DateTimeFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeFilter<"Alternative"> | Date | string
    questionId?: StringFilter<"Alternative"> | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    answers?: AnswerListRelationFilter
  }, "id">

  export type AlternativeOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionId?: SortOrder
    _count?: AlternativeCountOrderByAggregateInput
    _max?: AlternativeMaxOrderByAggregateInput
    _min?: AlternativeMinOrderByAggregateInput
  }

  export type AlternativeScalarWhereWithAggregatesInput = {
    AND?: AlternativeScalarWhereWithAggregatesInput | AlternativeScalarWhereWithAggregatesInput[]
    OR?: AlternativeScalarWhereWithAggregatesInput[]
    NOT?: AlternativeScalarWhereWithAggregatesInput | AlternativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alternative"> | string
    text?: StringWithAggregatesFilter<"Alternative"> | string
    isCorrect?: BoolWithAggregatesFilter<"Alternative"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alternative"> | Date | string
    questionId?: StringWithAggregatesFilter<"Alternative"> | string
  }

  export type TestAttemptWhereInput = {
    AND?: TestAttemptWhereInput | TestAttemptWhereInput[]
    OR?: TestAttemptWhereInput[]
    NOT?: TestAttemptWhereInput | TestAttemptWhereInput[]
    id?: StringFilter<"TestAttempt"> | string
    startTime?: DateTimeFilter<"TestAttempt"> | Date | string
    endTime?: DateTimeNullableFilter<"TestAttempt"> | Date | string | null
    score?: FloatNullableFilter<"TestAttempt"> | number | null
    passed?: BoolNullableFilter<"TestAttempt"> | boolean | null
    completionTime?: IntNullableFilter<"TestAttempt"> | number | null
    createdAt?: DateTimeFilter<"TestAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"TestAttempt"> | Date | string
    certificationTestId?: StringFilter<"TestAttempt"> | string
    userId?: StringFilter<"TestAttempt"> | string
    certificationTest?: XOR<CertificationTestScalarRelationFilter, CertificationTestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: AnswerListRelationFilter
  }

  export type TestAttemptOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    completionTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    userId?: SortOrder
    certificationTest?: CertificationTestOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    answers?: AnswerOrderByRelationAggregateInput
  }

  export type TestAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestAttemptWhereInput | TestAttemptWhereInput[]
    OR?: TestAttemptWhereInput[]
    NOT?: TestAttemptWhereInput | TestAttemptWhereInput[]
    startTime?: DateTimeFilter<"TestAttempt"> | Date | string
    endTime?: DateTimeNullableFilter<"TestAttempt"> | Date | string | null
    score?: FloatNullableFilter<"TestAttempt"> | number | null
    passed?: BoolNullableFilter<"TestAttempt"> | boolean | null
    completionTime?: IntNullableFilter<"TestAttempt"> | number | null
    createdAt?: DateTimeFilter<"TestAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"TestAttempt"> | Date | string
    certificationTestId?: StringFilter<"TestAttempt"> | string
    userId?: StringFilter<"TestAttempt"> | string
    certificationTest?: XOR<CertificationTestScalarRelationFilter, CertificationTestWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: AnswerListRelationFilter
  }, "id">

  export type TestAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    completionTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    userId?: SortOrder
    _count?: TestAttemptCountOrderByAggregateInput
    _avg?: TestAttemptAvgOrderByAggregateInput
    _max?: TestAttemptMaxOrderByAggregateInput
    _min?: TestAttemptMinOrderByAggregateInput
    _sum?: TestAttemptSumOrderByAggregateInput
  }

  export type TestAttemptScalarWhereWithAggregatesInput = {
    AND?: TestAttemptScalarWhereWithAggregatesInput | TestAttemptScalarWhereWithAggregatesInput[]
    OR?: TestAttemptScalarWhereWithAggregatesInput[]
    NOT?: TestAttemptScalarWhereWithAggregatesInput | TestAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestAttempt"> | string
    startTime?: DateTimeWithAggregatesFilter<"TestAttempt"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"TestAttempt"> | Date | string | null
    score?: FloatNullableWithAggregatesFilter<"TestAttempt"> | number | null
    passed?: BoolNullableWithAggregatesFilter<"TestAttempt"> | boolean | null
    completionTime?: IntNullableWithAggregatesFilter<"TestAttempt"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TestAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestAttempt"> | Date | string
    certificationTestId?: StringWithAggregatesFilter<"TestAttempt"> | string
    userId?: StringWithAggregatesFilter<"TestAttempt"> | string
  }

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    id?: StringFilter<"Answer"> | string
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    testAttemptId?: StringFilter<"Answer"> | string
    questionId?: StringFilter<"Answer"> | string
    alternativeId?: StringNullableFilter<"Answer"> | string | null
    testAttempt?: XOR<TestAttemptScalarRelationFilter, TestAttemptWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    alternative?: XOR<AlternativeNullableScalarRelationFilter, AlternativeWhereInput> | null
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    testAttemptId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrderInput | SortOrder
    testAttempt?: TestAttemptOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
    alternative?: AlternativeOrderByWithRelationInput
  }

  export type AnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    testAttemptId_questionId?: AnswerTestAttemptIdQuestionIdCompoundUniqueInput
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    testAttemptId?: StringFilter<"Answer"> | string
    questionId?: StringFilter<"Answer"> | string
    alternativeId?: StringNullableFilter<"Answer"> | string | null
    testAttempt?: XOR<TestAttemptScalarRelationFilter, TestAttemptWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    alternative?: XOR<AlternativeNullableScalarRelationFilter, AlternativeWhereInput> | null
  }, "id" | "testAttemptId_questionId">

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    testAttemptId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrderInput | SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    OR?: AnswerScalarWhereWithAggregatesInput[]
    NOT?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Answer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Answer"> | Date | string
    testAttemptId?: StringWithAggregatesFilter<"Answer"> | string
    questionId?: StringWithAggregatesFilter<"Answer"> | string
    alternativeId?: StringNullableWithAggregatesFilter<"Answer"> | string | null
  }

  export type TolinerCreateInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerCreateManyInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
  }

  export type TolinerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TolinerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    conversations?: ConversationCreateNestedManyWithoutMembersInput
    toliner: TolinerCreateNestedOneWithoutUserInput
    skills?: SkillCreateNestedManyWithoutUsersInput
    TestAttempt?: TestAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    tolinerId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutMembersInput
    skills?: SkillUncheckedCreateNestedManyWithoutUsersInput
    TestAttempt?: TestAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUpdateManyWithoutMembersNestedInput
    toliner?: TolinerUpdateOneRequiredWithoutUserNestedInput
    skills?: SkillUpdateManyWithoutUsersNestedInput
    TestAttempt?: TestAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutMembersNestedInput
    skills?: SkillUncheckedUpdateManyWithoutUsersNestedInput
    TestAttempt?: TestAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    tolinerId: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectSubscriptionCreateInput = {
    id?: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
    toliner: TolinerCreateNestedOneWithoutSubscriptionsInput
    project: ProjectCreateNestedOneWithoutSubscriptionsInput
  }

  export type ProjectSubscriptionUncheckedCreateInput = {
    id?: string
    projectId: string
    tolinerId: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
    toliner?: TolinerUpdateOneRequiredWithoutSubscriptionsNestedInput
    project?: ProjectUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ProjectSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tolinerId?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionCreateManyInput = {
    id?: string
    projectId: string
    tolinerId: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    tolinerId?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillCreateNestedManyWithoutCategoryInput
    toliners?: TolinerCreateNestedManyWithoutSpecializationInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    projects?: ProjectCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillUncheckedCreateNestedManyWithoutCategoryInput
    toliners?: TolinerUncheckedCreateNestedManyWithoutSpecializationInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUpdateManyWithoutCategoryNestedInput
    toliners?: TolinerUpdateManyWithoutSpecializationNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    projects?: ProjectUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUncheckedUpdateManyWithoutCategoryNestedInput
    toliners?: TolinerUncheckedUpdateManyWithoutSpecializationNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    category?: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    categoryId?: string | null
  }

  export type SubcategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubcategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    categoryId?: string | null
  }

  export type SubcategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FreelancerEvaluationCreateInput = {
    id?: string
    rate: string
    evaluatorId: string
    comment: string
    toliner: TolinerCreateNestedOneWithoutFreelancerEvaluationInput
  }

  export type FreelancerEvaluationUncheckedCreateInput = {
    id?: string
    rate: string
    tolinerId: string
    evaluatorId: string
    comment: string
  }

  export type FreelancerEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    toliner?: TolinerUpdateOneRequiredWithoutFreelancerEvaluationNestedInput
  }

  export type FreelancerEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    tolinerId?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type FreelancerEvaluationCreateManyInput = {
    id?: string
    rate: string
    tolinerId: string
    evaluatorId: string
    comment: string
  }

  export type FreelancerEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type FreelancerEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    tolinerId?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type QuotationCreateInput = {
    id?: string
    ammount: number
    description?: string | null
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutQuotationInput
  }

  export type QuotationUncheckedCreateInput = {
    id?: string
    projectId: string
    ammount: number
    description?: string | null
    createdAt?: Date | string
  }

  export type QuotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutQuotationNestedInput
  }

  export type QuotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    ammount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationCreateManyInput = {
    id?: string
    projectId: string
    ammount: number
    description?: string | null
    createdAt?: Date | string
  }

  export type QuotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    ammount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    members?: UserCreateNestedManyWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    project?: ProjectCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    projectId?: string | null
    members?: UserUncheckedCreateNestedManyWithoutConversationsInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: UserUpdateManyWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    project?: ProjectUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: UserUncheckedUpdateManyWithoutConversationsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    projectId?: string | null
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    saw?: boolean
    hasFile?: boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    conversationId: string
    saw?: boolean
    hasFile?: boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    conversationId: string
    saw?: boolean
    hasFile?: boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: StringFieldUpdateOperationsInput | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PortifolioCreateInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    skills?: SkillCreateNestedManyWithoutPortifoliosInput
    toliner?: TolinerCreateNestedOneWithoutPortifolioInput
  }

  export type PortifolioUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    tolinerId?: string | null
    skills?: SkillUncheckedCreateNestedManyWithoutPortifoliosInput
  }

  export type PortifolioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    skills?: SkillUpdateManyWithoutPortifoliosNestedInput
    toliner?: TolinerUpdateOneWithoutPortifolioNestedInput
  }

  export type PortifolioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    tolinerId?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: SkillUncheckedUpdateManyWithoutPortifoliosNestedInput
  }

  export type PortifolioCreateManyInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    tolinerId?: string | null
  }

  export type PortifolioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
  }

  export type PortifolioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    tolinerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    completedAt?: Date | string | null
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    referenceNumber?: string | null
    project: ProjectCreateNestedOneWithoutPaymentInput
    toliner: TolinerCreateNestedOneWithoutPaymentsInput
    freelancer: TolinerCreateNestedOneWithoutFreelancerPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    projectId: string
    completedAt?: Date | string | null
    tolinerId: string
    status?: $Enums.PaymentStatus
    freelancerId: string
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutPaymentNestedInput
    toliner?: TolinerUpdateOneRequiredWithoutPaymentsNestedInput
    freelancer?: TolinerUpdateOneRequiredWithoutFreelancerPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    freelancerId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    projectId: string
    completedAt?: Date | string | null
    tolinerId: string
    status?: $Enums.PaymentStatus
    freelancerId: string
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    freelancerId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChargeCreateInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    isVerified?: boolean
    invoice: string
    updatedAt?: Date | string
    referenceNumber?: string | null
    status?: $Enums.ChargeStatus
    toliner: TolinerCreateNestedOneWithoutChargesInput
  }

  export type ChargeUncheckedCreateInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    isVerified?: boolean
    invoice: string
    updatedAt?: Date | string
    referenceNumber?: string | null
    status?: $Enums.ChargeStatus
    tolinerId: string
  }

  export type ChargeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
    toliner?: TolinerUpdateOneRequiredWithoutChargesNestedInput
  }

  export type ChargeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
    tolinerId?: StringFieldUpdateOperationsInput | string
  }

  export type ChargeCreateManyInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    isVerified?: boolean
    invoice: string
    updatedAt?: Date | string
    referenceNumber?: string | null
    status?: $Enums.ChargeStatus
    tolinerId: string
  }

  export type ChargeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
  }

  export type ChargeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
    tolinerId?: StringFieldUpdateOperationsInput | string
  }

  export type BalanceCreateInput = {
    id?: string
    ammount: number
    updatedAt?: Date | string
    toliner?: TolinerCreateNestedOneWithoutBalanceInput
  }

  export type BalanceUncheckedCreateInput = {
    id?: string
    ammount: number
    updatedAt?: Date | string
    tolinerId?: string | null
  }

  export type BalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toliner?: TolinerUpdateOneWithoutBalanceNestedInput
  }

  export type BalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tolinerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BalanceCreateManyInput = {
    id?: string
    ammount: number
    updatedAt?: Date | string
    tolinerId?: string | null
  }

  export type BalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tolinerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationCodeCreateInput = {
    id?: string
    userEmail: string
    code: string
    expires: Date | string
    type: string
  }

  export type VerificationCodeUncheckedCreateInput = {
    id?: string
    userEmail: string
    code: string
    expires: Date | string
    type: string
  }

  export type VerificationCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCodeCreateManyInput = {
    id?: string
    userEmail: string
    code: string
    expires: Date | string
    type: string
  }

  export type VerificationCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    category?: CategoryCreateNestedOneWithoutSkillsInput
    users?: UserCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioCreateNestedManyWithoutSkillsInput
    projects?: ProjectCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    subcategoryId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioUncheckedCreateNestedManyWithoutSkillsInput
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestUncheckedCreateNestedOneWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneWithoutSkillsNestedInput
    users?: UserUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUncheckedUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUncheckedUpdateOneWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    subcategoryId?: string | null
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificationTestCreateInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutCertificationTestInput
    questions?: QuestionCreateNestedManyWithoutCertificationTestInput
    attempts?: TestAttemptCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skillId: string
    questions?: QuestionUncheckedCreateNestedManyWithoutCertificationTestInput
    attempts?: TestAttemptUncheckedCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutCertificationTestNestedInput
    questions?: QuestionUpdateManyWithoutCertificationTestNestedInput
    attempts?: TestAttemptUpdateManyWithoutCertificationTestNestedInput
  }

  export type CertificationTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillId?: StringFieldUpdateOperationsInput | string
    questions?: QuestionUncheckedUpdateManyWithoutCertificationTestNestedInput
    attempts?: TestAttemptUncheckedUpdateManyWithoutCertificationTestNestedInput
  }

  export type CertificationTestCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skillId: string
  }

  export type CertificationTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionCreateInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTest: CertificationTestCreateNestedOneWithoutQuestionsInput
    alternatives?: AlternativeCreateNestedManyWithoutQuestionInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    alternatives?: AlternativeUncheckedCreateNestedManyWithoutQuestionInput
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTest?: CertificationTestUpdateOneRequiredWithoutQuestionsNestedInput
    alternatives?: AlternativeUpdateManyWithoutQuestionNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    alternatives?: AlternativeUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternativeCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutAlternativesInput
    answers?: AnswerCreateNestedManyWithoutAlternativeInput
  }

  export type AlternativeUncheckedCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questionId: string
    answers?: AnswerUncheckedCreateNestedManyWithoutAlternativeInput
  }

  export type AlternativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAlternativesNestedInput
    answers?: AnswerUpdateManyWithoutAlternativeNestedInput
  }

  export type AlternativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionId?: StringFieldUpdateOperationsInput | string
    answers?: AnswerUncheckedUpdateManyWithoutAlternativeNestedInput
  }

  export type AlternativeCreateManyInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questionId: string
  }

  export type AlternativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlternativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type TestAttemptCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTest: CertificationTestCreateNestedOneWithoutAttemptsInput
    user: UserCreateNestedOneWithoutTestAttemptInput
    answers?: AnswerCreateNestedManyWithoutTestAttemptInput
  }

  export type TestAttemptUncheckedCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    userId: string
    answers?: AnswerUncheckedCreateNestedManyWithoutTestAttemptInput
  }

  export type TestAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTest?: CertificationTestUpdateOneRequiredWithoutAttemptsNestedInput
    user?: UserUpdateOneRequiredWithoutTestAttemptNestedInput
    answers?: AnswerUpdateManyWithoutTestAttemptNestedInput
  }

  export type TestAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: AnswerUncheckedUpdateManyWithoutTestAttemptNestedInput
  }

  export type TestAttemptCreateManyInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    userId: string
  }

  export type TestAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AnswerCreateInput = {
    id?: string
    createdAt?: Date | string
    testAttempt: TestAttemptCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutAnswersInput
    alternative?: AlternativeCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    testAttemptId: string
    questionId: string
    alternativeId?: string | null
  }

  export type AnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttempt?: TestAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    alternative?: AlternativeUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerCreateManyInput = {
    id?: string
    createdAt?: Date | string
    testAttemptId: string
    questionId: string
    alternativeId?: string | null
  }

  export type AnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectSubscriptionListRelationFilter = {
    every?: ProjectSubscriptionWhereInput
    some?: ProjectSubscriptionWhereInput
    none?: ProjectSubscriptionWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type PortifolioListRelationFilter = {
    every?: PortifolioWhereInput
    some?: PortifolioWhereInput
    none?: PortifolioWhereInput
  }

  export type FreelancerEvaluationListRelationFilter = {
    every?: FreelancerEvaluationWhereInput
    some?: FreelancerEvaluationWhereInput
    none?: FreelancerEvaluationWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ChargeListRelationFilter = {
    every?: ChargeWhereInput
    some?: ChargeWhereInput
    none?: ChargeWhereInput
  }

  export type BalanceNullableScalarRelationFilter = {
    is?: BalanceWhereInput | null
    isNot?: BalanceWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortifolioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelancerEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TolinerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    jobDescription?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    bankAccount?: SortOrder
    identification?: SortOrder
    isSuspended?: SortOrder
    isActive?: SortOrder
    hasCompletedProfile?: SortOrder
    hasAprovedProfile?: SortOrder
    gainPerOurs?: SortOrder
    nacionality?: SortOrder
  }

  export type TolinerAvgOrderByAggregateInput = {
    gainPerOurs?: SortOrder
  }

  export type TolinerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    jobDescription?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    isSuspended?: SortOrder
    isActive?: SortOrder
    hasCompletedProfile?: SortOrder
    hasAprovedProfile?: SortOrder
    gainPerOurs?: SortOrder
    nacionality?: SortOrder
  }

  export type TolinerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    jobDescription?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    isSuspended?: SortOrder
    isActive?: SortOrder
    hasCompletedProfile?: SortOrder
    hasAprovedProfile?: SortOrder
    gainPerOurs?: SortOrder
    nacionality?: SortOrder
  }

  export type TolinerSumOrderByAggregateInput = {
    gainPerOurs?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type TolinerScalarRelationFilter = {
    is?: TolinerWhereInput
    isNot?: TolinerWhereInput
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type TestAttemptListRelationFilter = {
    every?: TestAttemptWhereInput
    some?: TestAttemptWhereInput
    none?: TestAttemptWhereInput
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    tag?: SortOrder
    clientBio?: SortOrder
    freelancerBio?: SortOrder
    avatarUrl?: SortOrder
    tolinerId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    tag?: SortOrder
    clientBio?: SortOrder
    freelancerBio?: SortOrder
    avatarUrl?: SortOrder
    tolinerId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    tag?: SortOrder
    clientBio?: SortOrder
    freelancerBio?: SortOrder
    avatarUrl?: SortOrder
    tolinerId?: SortOrder
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TolinerNullableScalarRelationFilter = {
    is?: TolinerWhereInput | null
    isNot?: TolinerWhereInput | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type QuotationNullableScalarRelationFilter = {
    is?: QuotationWhereInput | null
    isNot?: QuotationWhereInput | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type ProjectNameCategoryIdOwnerIdCompoundUniqueInput = {
    name: string
    categoryId: string
    ownerId: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    freelancerId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    dueDate?: SortOrder
    concludedAt?: SortOrder
    isAproved?: SortOrder
    isActive?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    freelancerId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    dueDate?: SortOrder
    concludedAt?: SortOrder
    isAproved?: SortOrder
    isActive?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    freelancerId?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    dueDate?: SortOrder
    concludedAt?: SortOrder
    isAproved?: SortOrder
    isActive?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectSubscriptionProjectIdTolinerIdCompoundUniqueInput = {
    projectId: string
    tolinerId: string
  }

  export type ProjectSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tolinerId?: SortOrder
    estimatedTime?: SortOrder
    requiredInformations?: SortOrder
    similarExperiences?: SortOrder
    proposal?: SortOrder
    quotation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitation?: SortOrder
  }

  export type ProjectSubscriptionAvgOrderByAggregateInput = {
    quotation?: SortOrder
  }

  export type ProjectSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tolinerId?: SortOrder
    estimatedTime?: SortOrder
    requiredInformations?: SortOrder
    similarExperiences?: SortOrder
    proposal?: SortOrder
    quotation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tolinerId?: SortOrder
    estimatedTime?: SortOrder
    requiredInformations?: SortOrder
    similarExperiences?: SortOrder
    proposal?: SortOrder
    quotation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSubscriptionSumOrderByAggregateInput = {
    quotation?: SortOrder
  }

  export type TolinerListRelationFilter = {
    every?: TolinerWhereInput
    some?: TolinerWhereInput
    none?: TolinerWhereInput
  }

  export type SubcategoryListRelationFilter = {
    every?: SubcategoryWhereInput
    some?: SubcategoryWhereInput
    none?: SubcategoryWhereInput
  }

  export type TolinerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
  }

  export type SubcategoryCategoryIdNameCompoundUniqueInput = {
    categoryId: string
    name: string
  }

  export type SubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    categoryId?: SortOrder
  }

  export type FreelancerEvaluationTolinerIdEvaluatorIdCompoundUniqueInput = {
    tolinerId: string
    evaluatorId: string
  }

  export type FreelancerEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    tolinerId?: SortOrder
    evaluatorId?: SortOrder
    comment?: SortOrder
  }

  export type FreelancerEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    tolinerId?: SortOrder
    evaluatorId?: SortOrder
    comment?: SortOrder
  }

  export type FreelancerEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    tolinerId?: SortOrder
    evaluatorId?: SortOrder
    comment?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type QuotationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    ammount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotationAvgOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type QuotationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    ammount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    ammount?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotationSumOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    saw?: SortOrder
    hasFile?: SortOrder
    fileInfo?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    saw?: SortOrder
    hasFile?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversationId?: SortOrder
    saw?: SortOrder
    hasFile?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PortifolioTitleTolinerIdCompoundUniqueInput = {
    title: string
    tolinerId: string
  }

  export type PortifolioCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    completedAt?: SortOrder
    assets?: SortOrder
    tolinerId?: SortOrder
  }

  export type PortifolioMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    completedAt?: SortOrder
    tolinerId?: SortOrder
  }

  export type PortifolioMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    cover?: SortOrder
    completedAt?: SortOrder
    tolinerId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    clientInvoice?: SortOrder
    systemInvoice?: SortOrder
    isVerified?: SortOrder
    projectId?: SortOrder
    completedAt?: SortOrder
    tolinerId?: SortOrder
    status?: SortOrder
    freelancerId?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    clientInvoice?: SortOrder
    systemInvoice?: SortOrder
    isVerified?: SortOrder
    projectId?: SortOrder
    completedAt?: SortOrder
    tolinerId?: SortOrder
    status?: SortOrder
    freelancerId?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    clientInvoice?: SortOrder
    systemInvoice?: SortOrder
    isVerified?: SortOrder
    projectId?: SortOrder
    completedAt?: SortOrder
    tolinerId?: SortOrder
    status?: SortOrder
    freelancerId?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumChargeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeStatus | EnumChargeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeStatusFilter<$PrismaModel> | $Enums.ChargeStatus
  }

  export type ChargeCountOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    invoice?: SortOrder
    updatedAt?: SortOrder
    referenceNumber?: SortOrder
    status?: SortOrder
    tolinerId?: SortOrder
  }

  export type ChargeAvgOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type ChargeMaxOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    invoice?: SortOrder
    updatedAt?: SortOrder
    referenceNumber?: SortOrder
    status?: SortOrder
    tolinerId?: SortOrder
  }

  export type ChargeMinOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    createdAt?: SortOrder
    isVerified?: SortOrder
    invoice?: SortOrder
    updatedAt?: SortOrder
    referenceNumber?: SortOrder
    status?: SortOrder
    tolinerId?: SortOrder
  }

  export type ChargeSumOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type EnumChargeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeStatus | EnumChargeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChargeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChargeStatusFilter<$PrismaModel>
    _max?: NestedEnumChargeStatusFilter<$PrismaModel>
  }

  export type BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    updatedAt?: SortOrder
    tolinerId?: SortOrder
  }

  export type BalanceAvgOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    updatedAt?: SortOrder
    tolinerId?: SortOrder
  }

  export type BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    ammount?: SortOrder
    updatedAt?: SortOrder
    tolinerId?: SortOrder
  }

  export type BalanceSumOrderByAggregateInput = {
    ammount?: SortOrder
  }

  export type VerificationCodeUserEmailCodeCompoundUniqueInput = {
    userEmail: string
    code: string
  }

  export type VerificationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    userEmail?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
  }

  export type VerificationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    userEmail?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
  }

  export type VerificationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    userEmail?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
  }

  export type CertificationTestNullableScalarRelationFilter = {
    is?: CertificationTestWhereInput | null
    isNot?: CertificationTestWhereInput | null
  }

  export type SkillSubcategoryIdCategoryIdNameCompoundUniqueInput = {
    subcategoryId: string
    categoryId: string
    name: string
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationTestCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skillId?: SortOrder
  }

  export type CertificationTestAvgOrderByAggregateInput = {
    timeLimit?: SortOrder
    passingScore?: SortOrder
  }

  export type CertificationTestMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skillId?: SortOrder
  }

  export type CertificationTestMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    skillId?: SortOrder
  }

  export type CertificationTestSumOrderByAggregateInput = {
    timeLimit?: SortOrder
    passingScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CertificationTestScalarRelationFilter = {
    is?: CertificationTestWhereInput
    isNot?: CertificationTestWhereInput
  }

  export type AlternativeListRelationFilter = {
    every?: AlternativeWhereInput
    some?: AlternativeWhereInput
    none?: AlternativeWhereInput
  }

  export type AnswerListRelationFilter = {
    every?: AnswerWhereInput
    some?: AnswerWhereInput
    none?: AnswerWhereInput
  }

  export type AlternativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    score?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    score?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    score?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type AlternativeCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionId?: SortOrder
  }

  export type AlternativeMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionId?: SortOrder
  }

  export type AlternativeMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questionId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TestAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    completionTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    userId?: SortOrder
  }

  export type TestAttemptAvgOrderByAggregateInput = {
    score?: SortOrder
    completionTime?: SortOrder
  }

  export type TestAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    completionTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    userId?: SortOrder
  }

  export type TestAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    completionTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificationTestId?: SortOrder
    userId?: SortOrder
  }

  export type TestAttemptSumOrderByAggregateInput = {
    score?: SortOrder
    completionTime?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TestAttemptScalarRelationFilter = {
    is?: TestAttemptWhereInput
    isNot?: TestAttemptWhereInput
  }

  export type AlternativeNullableScalarRelationFilter = {
    is?: AlternativeWhereInput | null
    isNot?: AlternativeWhereInput | null
  }

  export type AnswerTestAttemptIdQuestionIdCompoundUniqueInput = {
    testAttemptId: string
    questionId: string
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    testAttemptId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    testAttemptId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    testAttemptId?: SortOrder
    questionId?: SortOrder
    alternativeId?: SortOrder
  }

  export type ProjectCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<ProjectCreateWithoutFreelancerInput, ProjectUncheckedCreateWithoutFreelancerInput> | ProjectCreateWithoutFreelancerInput[] | ProjectUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFreelancerInput | ProjectCreateOrConnectWithoutFreelancerInput[]
    createMany?: ProjectCreateManyFreelancerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectSubscriptionCreateNestedManyWithoutTolinerInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutTolinerInput, ProjectSubscriptionUncheckedCreateWithoutTolinerInput> | ProjectSubscriptionCreateWithoutTolinerInput[] | ProjectSubscriptionUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutTolinerInput | ProjectSubscriptionCreateOrConnectWithoutTolinerInput[]
    createMany?: ProjectSubscriptionCreateManyTolinerInputEnvelope
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutTolinersInput = {
    create?: XOR<CategoryCreateWithoutTolinersInput, CategoryUncheckedCreateWithoutTolinersInput> | CategoryCreateWithoutTolinersInput[] | CategoryUncheckedCreateWithoutTolinersInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTolinersInput | CategoryCreateOrConnectWithoutTolinersInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PortifolioCreateNestedManyWithoutTolinerInput = {
    create?: XOR<PortifolioCreateWithoutTolinerInput, PortifolioUncheckedCreateWithoutTolinerInput> | PortifolioCreateWithoutTolinerInput[] | PortifolioUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutTolinerInput | PortifolioCreateOrConnectWithoutTolinerInput[]
    createMany?: PortifolioCreateManyTolinerInputEnvelope
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
  }

  export type FreelancerEvaluationCreateNestedManyWithoutTolinerInput = {
    create?: XOR<FreelancerEvaluationCreateWithoutTolinerInput, FreelancerEvaluationUncheckedCreateWithoutTolinerInput> | FreelancerEvaluationCreateWithoutTolinerInput[] | FreelancerEvaluationUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: FreelancerEvaluationCreateOrConnectWithoutTolinerInput | FreelancerEvaluationCreateOrConnectWithoutTolinerInput[]
    createMany?: FreelancerEvaluationCreateManyTolinerInputEnvelope
    connect?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutTolinerInput = {
    create?: XOR<UserCreateWithoutTolinerInput, UserUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTolinerInput
    connect?: UserWhereUniqueInput
  }

  export type ChargeCreateNestedManyWithoutTolinerInput = {
    create?: XOR<ChargeCreateWithoutTolinerInput, ChargeUncheckedCreateWithoutTolinerInput> | ChargeCreateWithoutTolinerInput[] | ChargeUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ChargeCreateOrConnectWithoutTolinerInput | ChargeCreateOrConnectWithoutTolinerInput[]
    createMany?: ChargeCreateManyTolinerInputEnvelope
    connect?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
  }

  export type BalanceCreateNestedOneWithoutTolinerInput = {
    create?: XOR<BalanceCreateWithoutTolinerInput, BalanceUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: BalanceCreateOrConnectWithoutTolinerInput
    connect?: BalanceWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutTolinerInput = {
    create?: XOR<PaymentCreateWithoutTolinerInput, PaymentUncheckedCreateWithoutTolinerInput> | PaymentCreateWithoutTolinerInput[] | PaymentUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTolinerInput | PaymentCreateOrConnectWithoutTolinerInput[]
    createMany?: PaymentCreateManyTolinerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<PaymentCreateWithoutFreelancerInput, PaymentUncheckedCreateWithoutFreelancerInput> | PaymentCreateWithoutFreelancerInput[] | PaymentUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutFreelancerInput | PaymentCreateOrConnectWithoutFreelancerInput[]
    createMany?: PaymentCreateManyFreelancerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<ProjectCreateWithoutFreelancerInput, ProjectUncheckedCreateWithoutFreelancerInput> | ProjectCreateWithoutFreelancerInput[] | ProjectUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFreelancerInput | ProjectCreateOrConnectWithoutFreelancerInput[]
    createMany?: ProjectCreateManyFreelancerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutTolinerInput, ProjectSubscriptionUncheckedCreateWithoutTolinerInput> | ProjectSubscriptionCreateWithoutTolinerInput[] | ProjectSubscriptionUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutTolinerInput | ProjectSubscriptionCreateOrConnectWithoutTolinerInput[]
    createMany?: ProjectSubscriptionCreateManyTolinerInputEnvelope
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutTolinersInput = {
    create?: XOR<CategoryCreateWithoutTolinersInput, CategoryUncheckedCreateWithoutTolinersInput> | CategoryCreateWithoutTolinersInput[] | CategoryUncheckedCreateWithoutTolinersInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTolinersInput | CategoryCreateOrConnectWithoutTolinersInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PortifolioUncheckedCreateNestedManyWithoutTolinerInput = {
    create?: XOR<PortifolioCreateWithoutTolinerInput, PortifolioUncheckedCreateWithoutTolinerInput> | PortifolioCreateWithoutTolinerInput[] | PortifolioUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutTolinerInput | PortifolioCreateOrConnectWithoutTolinerInput[]
    createMany?: PortifolioCreateManyTolinerInputEnvelope
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
  }

  export type FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput = {
    create?: XOR<FreelancerEvaluationCreateWithoutTolinerInput, FreelancerEvaluationUncheckedCreateWithoutTolinerInput> | FreelancerEvaluationCreateWithoutTolinerInput[] | FreelancerEvaluationUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: FreelancerEvaluationCreateOrConnectWithoutTolinerInput | FreelancerEvaluationCreateOrConnectWithoutTolinerInput[]
    createMany?: FreelancerEvaluationCreateManyTolinerInputEnvelope
    connect?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutTolinerInput = {
    create?: XOR<UserCreateWithoutTolinerInput, UserUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTolinerInput
    connect?: UserWhereUniqueInput
  }

  export type ChargeUncheckedCreateNestedManyWithoutTolinerInput = {
    create?: XOR<ChargeCreateWithoutTolinerInput, ChargeUncheckedCreateWithoutTolinerInput> | ChargeCreateWithoutTolinerInput[] | ChargeUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ChargeCreateOrConnectWithoutTolinerInput | ChargeCreateOrConnectWithoutTolinerInput[]
    createMany?: ChargeCreateManyTolinerInputEnvelope
    connect?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
  }

  export type BalanceUncheckedCreateNestedOneWithoutTolinerInput = {
    create?: XOR<BalanceCreateWithoutTolinerInput, BalanceUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: BalanceCreateOrConnectWithoutTolinerInput
    connect?: BalanceWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutTolinerInput = {
    create?: XOR<PaymentCreateWithoutTolinerInput, PaymentUncheckedCreateWithoutTolinerInput> | PaymentCreateWithoutTolinerInput[] | PaymentUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTolinerInput | PaymentCreateOrConnectWithoutTolinerInput[]
    createMany?: PaymentCreateManyTolinerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutFreelancerInput = {
    create?: XOR<PaymentCreateWithoutFreelancerInput, PaymentUncheckedCreateWithoutFreelancerInput> | PaymentCreateWithoutFreelancerInput[] | PaymentUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutFreelancerInput | PaymentCreateOrConnectWithoutFreelancerInput[]
    createMany?: PaymentCreateManyFreelancerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<ProjectCreateWithoutFreelancerInput, ProjectUncheckedCreateWithoutFreelancerInput> | ProjectCreateWithoutFreelancerInput[] | ProjectUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFreelancerInput | ProjectCreateOrConnectWithoutFreelancerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFreelancerInput | ProjectUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: ProjectCreateManyFreelancerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFreelancerInput | ProjectUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFreelancerInput | ProjectUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectSubscriptionUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutTolinerInput, ProjectSubscriptionUncheckedCreateWithoutTolinerInput> | ProjectSubscriptionCreateWithoutTolinerInput[] | ProjectSubscriptionUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutTolinerInput | ProjectSubscriptionCreateOrConnectWithoutTolinerInput[]
    upsert?: ProjectSubscriptionUpsertWithWhereUniqueWithoutTolinerInput | ProjectSubscriptionUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: ProjectSubscriptionCreateManyTolinerInputEnvelope
    set?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    disconnect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    delete?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    update?: ProjectSubscriptionUpdateWithWhereUniqueWithoutTolinerInput | ProjectSubscriptionUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: ProjectSubscriptionUpdateManyWithWhereWithoutTolinerInput | ProjectSubscriptionUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: ProjectSubscriptionScalarWhereInput | ProjectSubscriptionScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutTolinersNestedInput = {
    create?: XOR<CategoryCreateWithoutTolinersInput, CategoryUncheckedCreateWithoutTolinersInput> | CategoryCreateWithoutTolinersInput[] | CategoryUncheckedCreateWithoutTolinersInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTolinersInput | CategoryCreateOrConnectWithoutTolinersInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTolinersInput | CategoryUpsertWithWhereUniqueWithoutTolinersInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTolinersInput | CategoryUpdateWithWhereUniqueWithoutTolinersInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTolinersInput | CategoryUpdateManyWithWhereWithoutTolinersInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PortifolioUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<PortifolioCreateWithoutTolinerInput, PortifolioUncheckedCreateWithoutTolinerInput> | PortifolioCreateWithoutTolinerInput[] | PortifolioUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutTolinerInput | PortifolioCreateOrConnectWithoutTolinerInput[]
    upsert?: PortifolioUpsertWithWhereUniqueWithoutTolinerInput | PortifolioUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: PortifolioCreateManyTolinerInputEnvelope
    set?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    disconnect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    delete?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    update?: PortifolioUpdateWithWhereUniqueWithoutTolinerInput | PortifolioUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: PortifolioUpdateManyWithWhereWithoutTolinerInput | PortifolioUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: PortifolioScalarWhereInput | PortifolioScalarWhereInput[]
  }

  export type FreelancerEvaluationUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<FreelancerEvaluationCreateWithoutTolinerInput, FreelancerEvaluationUncheckedCreateWithoutTolinerInput> | FreelancerEvaluationCreateWithoutTolinerInput[] | FreelancerEvaluationUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: FreelancerEvaluationCreateOrConnectWithoutTolinerInput | FreelancerEvaluationCreateOrConnectWithoutTolinerInput[]
    upsert?: FreelancerEvaluationUpsertWithWhereUniqueWithoutTolinerInput | FreelancerEvaluationUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: FreelancerEvaluationCreateManyTolinerInputEnvelope
    set?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    disconnect?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    delete?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    connect?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    update?: FreelancerEvaluationUpdateWithWhereUniqueWithoutTolinerInput | FreelancerEvaluationUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: FreelancerEvaluationUpdateManyWithWhereWithoutTolinerInput | FreelancerEvaluationUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: FreelancerEvaluationScalarWhereInput | FreelancerEvaluationScalarWhereInput[]
  }

  export type UserUpdateOneWithoutTolinerNestedInput = {
    create?: XOR<UserCreateWithoutTolinerInput, UserUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTolinerInput
    upsert?: UserUpsertWithoutTolinerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTolinerInput, UserUpdateWithoutTolinerInput>, UserUncheckedUpdateWithoutTolinerInput>
  }

  export type ChargeUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<ChargeCreateWithoutTolinerInput, ChargeUncheckedCreateWithoutTolinerInput> | ChargeCreateWithoutTolinerInput[] | ChargeUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ChargeCreateOrConnectWithoutTolinerInput | ChargeCreateOrConnectWithoutTolinerInput[]
    upsert?: ChargeUpsertWithWhereUniqueWithoutTolinerInput | ChargeUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: ChargeCreateManyTolinerInputEnvelope
    set?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    disconnect?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    delete?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    connect?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    update?: ChargeUpdateWithWhereUniqueWithoutTolinerInput | ChargeUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: ChargeUpdateManyWithWhereWithoutTolinerInput | ChargeUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: ChargeScalarWhereInput | ChargeScalarWhereInput[]
  }

  export type BalanceUpdateOneWithoutTolinerNestedInput = {
    create?: XOR<BalanceCreateWithoutTolinerInput, BalanceUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: BalanceCreateOrConnectWithoutTolinerInput
    upsert?: BalanceUpsertWithoutTolinerInput
    disconnect?: BalanceWhereInput | boolean
    delete?: BalanceWhereInput | boolean
    connect?: BalanceWhereUniqueInput
    update?: XOR<XOR<BalanceUpdateToOneWithWhereWithoutTolinerInput, BalanceUpdateWithoutTolinerInput>, BalanceUncheckedUpdateWithoutTolinerInput>
  }

  export type PaymentUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<PaymentCreateWithoutTolinerInput, PaymentUncheckedCreateWithoutTolinerInput> | PaymentCreateWithoutTolinerInput[] | PaymentUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTolinerInput | PaymentCreateOrConnectWithoutTolinerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTolinerInput | PaymentUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: PaymentCreateManyTolinerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTolinerInput | PaymentUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTolinerInput | PaymentUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<PaymentCreateWithoutFreelancerInput, PaymentUncheckedCreateWithoutFreelancerInput> | PaymentCreateWithoutFreelancerInput[] | PaymentUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutFreelancerInput | PaymentCreateOrConnectWithoutFreelancerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutFreelancerInput | PaymentUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: PaymentCreateManyFreelancerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutFreelancerInput | PaymentUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutFreelancerInput | PaymentUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput> | ProjectCreateWithoutOwnerInput[] | ProjectUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOwnerInput | ProjectCreateOrConnectWithoutOwnerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOwnerInput | ProjectUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ProjectCreateManyOwnerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOwnerInput | ProjectUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOwnerInput | ProjectUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<ProjectCreateWithoutFreelancerInput, ProjectUncheckedCreateWithoutFreelancerInput> | ProjectCreateWithoutFreelancerInput[] | ProjectUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutFreelancerInput | ProjectCreateOrConnectWithoutFreelancerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutFreelancerInput | ProjectUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: ProjectCreateManyFreelancerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutFreelancerInput | ProjectUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutFreelancerInput | ProjectUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutTolinerInput, ProjectSubscriptionUncheckedCreateWithoutTolinerInput> | ProjectSubscriptionCreateWithoutTolinerInput[] | ProjectSubscriptionUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutTolinerInput | ProjectSubscriptionCreateOrConnectWithoutTolinerInput[]
    upsert?: ProjectSubscriptionUpsertWithWhereUniqueWithoutTolinerInput | ProjectSubscriptionUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: ProjectSubscriptionCreateManyTolinerInputEnvelope
    set?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    disconnect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    delete?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    update?: ProjectSubscriptionUpdateWithWhereUniqueWithoutTolinerInput | ProjectSubscriptionUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: ProjectSubscriptionUpdateManyWithWhereWithoutTolinerInput | ProjectSubscriptionUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: ProjectSubscriptionScalarWhereInput | ProjectSubscriptionScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutTolinersNestedInput = {
    create?: XOR<CategoryCreateWithoutTolinersInput, CategoryUncheckedCreateWithoutTolinersInput> | CategoryCreateWithoutTolinersInput[] | CategoryUncheckedCreateWithoutTolinersInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutTolinersInput | CategoryCreateOrConnectWithoutTolinersInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutTolinersInput | CategoryUpsertWithWhereUniqueWithoutTolinersInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutTolinersInput | CategoryUpdateWithWhereUniqueWithoutTolinersInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutTolinersInput | CategoryUpdateManyWithWhereWithoutTolinersInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PortifolioUncheckedUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<PortifolioCreateWithoutTolinerInput, PortifolioUncheckedCreateWithoutTolinerInput> | PortifolioCreateWithoutTolinerInput[] | PortifolioUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutTolinerInput | PortifolioCreateOrConnectWithoutTolinerInput[]
    upsert?: PortifolioUpsertWithWhereUniqueWithoutTolinerInput | PortifolioUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: PortifolioCreateManyTolinerInputEnvelope
    set?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    disconnect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    delete?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    update?: PortifolioUpdateWithWhereUniqueWithoutTolinerInput | PortifolioUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: PortifolioUpdateManyWithWhereWithoutTolinerInput | PortifolioUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: PortifolioScalarWhereInput | PortifolioScalarWhereInput[]
  }

  export type FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<FreelancerEvaluationCreateWithoutTolinerInput, FreelancerEvaluationUncheckedCreateWithoutTolinerInput> | FreelancerEvaluationCreateWithoutTolinerInput[] | FreelancerEvaluationUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: FreelancerEvaluationCreateOrConnectWithoutTolinerInput | FreelancerEvaluationCreateOrConnectWithoutTolinerInput[]
    upsert?: FreelancerEvaluationUpsertWithWhereUniqueWithoutTolinerInput | FreelancerEvaluationUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: FreelancerEvaluationCreateManyTolinerInputEnvelope
    set?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    disconnect?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    delete?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    connect?: FreelancerEvaluationWhereUniqueInput | FreelancerEvaluationWhereUniqueInput[]
    update?: FreelancerEvaluationUpdateWithWhereUniqueWithoutTolinerInput | FreelancerEvaluationUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: FreelancerEvaluationUpdateManyWithWhereWithoutTolinerInput | FreelancerEvaluationUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: FreelancerEvaluationScalarWhereInput | FreelancerEvaluationScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutTolinerNestedInput = {
    create?: XOR<UserCreateWithoutTolinerInput, UserUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTolinerInput
    upsert?: UserUpsertWithoutTolinerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTolinerInput, UserUpdateWithoutTolinerInput>, UserUncheckedUpdateWithoutTolinerInput>
  }

  export type ChargeUncheckedUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<ChargeCreateWithoutTolinerInput, ChargeUncheckedCreateWithoutTolinerInput> | ChargeCreateWithoutTolinerInput[] | ChargeUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: ChargeCreateOrConnectWithoutTolinerInput | ChargeCreateOrConnectWithoutTolinerInput[]
    upsert?: ChargeUpsertWithWhereUniqueWithoutTolinerInput | ChargeUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: ChargeCreateManyTolinerInputEnvelope
    set?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    disconnect?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    delete?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    connect?: ChargeWhereUniqueInput | ChargeWhereUniqueInput[]
    update?: ChargeUpdateWithWhereUniqueWithoutTolinerInput | ChargeUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: ChargeUpdateManyWithWhereWithoutTolinerInput | ChargeUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: ChargeScalarWhereInput | ChargeScalarWhereInput[]
  }

  export type BalanceUncheckedUpdateOneWithoutTolinerNestedInput = {
    create?: XOR<BalanceCreateWithoutTolinerInput, BalanceUncheckedCreateWithoutTolinerInput>
    connectOrCreate?: BalanceCreateOrConnectWithoutTolinerInput
    upsert?: BalanceUpsertWithoutTolinerInput
    disconnect?: BalanceWhereInput | boolean
    delete?: BalanceWhereInput | boolean
    connect?: BalanceWhereUniqueInput
    update?: XOR<XOR<BalanceUpdateToOneWithWhereWithoutTolinerInput, BalanceUpdateWithoutTolinerInput>, BalanceUncheckedUpdateWithoutTolinerInput>
  }

  export type PaymentUncheckedUpdateManyWithoutTolinerNestedInput = {
    create?: XOR<PaymentCreateWithoutTolinerInput, PaymentUncheckedCreateWithoutTolinerInput> | PaymentCreateWithoutTolinerInput[] | PaymentUncheckedCreateWithoutTolinerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTolinerInput | PaymentCreateOrConnectWithoutTolinerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTolinerInput | PaymentUpsertWithWhereUniqueWithoutTolinerInput[]
    createMany?: PaymentCreateManyTolinerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTolinerInput | PaymentUpdateWithWhereUniqueWithoutTolinerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTolinerInput | PaymentUpdateManyWithWhereWithoutTolinerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutFreelancerNestedInput = {
    create?: XOR<PaymentCreateWithoutFreelancerInput, PaymentUncheckedCreateWithoutFreelancerInput> | PaymentCreateWithoutFreelancerInput[] | PaymentUncheckedCreateWithoutFreelancerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutFreelancerInput | PaymentCreateOrConnectWithoutFreelancerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutFreelancerInput | PaymentUpsertWithWhereUniqueWithoutFreelancerInput[]
    createMany?: PaymentCreateManyFreelancerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutFreelancerInput | PaymentUpdateWithWhereUniqueWithoutFreelancerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutFreelancerInput | PaymentUpdateManyWithWhereWithoutFreelancerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ConversationCreateNestedManyWithoutMembersInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput> | ConversationCreateWithoutMembersInput[] | ConversationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput | ConversationCreateOrConnectWithoutMembersInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type TolinerCreateNestedOneWithoutUserInput = {
    create?: XOR<TolinerCreateWithoutUserInput, TolinerUncheckedCreateWithoutUserInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutUserInput
    connect?: TolinerWhereUniqueInput
  }

  export type SkillCreateNestedManyWithoutUsersInput = {
    create?: XOR<SkillCreateWithoutUsersInput, SkillUncheckedCreateWithoutUsersInput> | SkillCreateWithoutUsersInput[] | SkillUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUsersInput | SkillCreateOrConnectWithoutUsersInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type TestAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<TestAttemptCreateWithoutUserInput, TestAttemptUncheckedCreateWithoutUserInput> | TestAttemptCreateWithoutUserInput[] | TestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutUserInput | TestAttemptCreateOrConnectWithoutUserInput[]
    createMany?: TestAttemptCreateManyUserInputEnvelope
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput> | ConversationCreateWithoutMembersInput[] | ConversationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput | ConversationCreateOrConnectWithoutMembersInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<SkillCreateWithoutUsersInput, SkillUncheckedCreateWithoutUsersInput> | SkillCreateWithoutUsersInput[] | SkillUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUsersInput | SkillCreateOrConnectWithoutUsersInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type TestAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TestAttemptCreateWithoutUserInput, TestAttemptUncheckedCreateWithoutUserInput> | TestAttemptCreateWithoutUserInput[] | TestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutUserInput | TestAttemptCreateOrConnectWithoutUserInput[]
    createMany?: TestAttemptCreateManyUserInputEnvelope
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
  }

  export type ConversationUpdateManyWithoutMembersNestedInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput> | ConversationCreateWithoutMembersInput[] | ConversationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput | ConversationCreateOrConnectWithoutMembersInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutMembersInput | ConversationUpsertWithWhereUniqueWithoutMembersInput[]
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutMembersInput | ConversationUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutMembersInput | ConversationUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type TolinerUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<TolinerCreateWithoutUserInput, TolinerUncheckedCreateWithoutUserInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutUserInput
    upsert?: TolinerUpsertWithoutUserInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutUserInput, TolinerUpdateWithoutUserInput>, TolinerUncheckedUpdateWithoutUserInput>
  }

  export type SkillUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SkillCreateWithoutUsersInput, SkillUncheckedCreateWithoutUsersInput> | SkillCreateWithoutUsersInput[] | SkillUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUsersInput | SkillCreateOrConnectWithoutUsersInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutUsersInput | SkillUpsertWithWhereUniqueWithoutUsersInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutUsersInput | SkillUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutUsersInput | SkillUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type TestAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestAttemptCreateWithoutUserInput, TestAttemptUncheckedCreateWithoutUserInput> | TestAttemptCreateWithoutUserInput[] | TestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutUserInput | TestAttemptCreateOrConnectWithoutUserInput[]
    upsert?: TestAttemptUpsertWithWhereUniqueWithoutUserInput | TestAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestAttemptCreateManyUserInputEnvelope
    set?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    disconnect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    delete?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    update?: TestAttemptUpdateWithWhereUniqueWithoutUserInput | TestAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestAttemptUpdateManyWithWhereWithoutUserInput | TestAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestAttemptScalarWhereInput | TestAttemptScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput> | ConversationCreateWithoutMembersInput[] | ConversationUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMembersInput | ConversationCreateOrConnectWithoutMembersInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutMembersInput | ConversationUpsertWithWhereUniqueWithoutMembersInput[]
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutMembersInput | ConversationUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutMembersInput | ConversationUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<SkillCreateWithoutUsersInput, SkillUncheckedCreateWithoutUsersInput> | SkillCreateWithoutUsersInput[] | SkillUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutUsersInput | SkillCreateOrConnectWithoutUsersInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutUsersInput | SkillUpsertWithWhereUniqueWithoutUsersInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutUsersInput | SkillUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutUsersInput | SkillUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type TestAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TestAttemptCreateWithoutUserInput, TestAttemptUncheckedCreateWithoutUserInput> | TestAttemptCreateWithoutUserInput[] | TestAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutUserInput | TestAttemptCreateOrConnectWithoutUserInput[]
    upsert?: TestAttemptUpsertWithWhereUniqueWithoutUserInput | TestAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TestAttemptCreateManyUserInputEnvelope
    set?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    disconnect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    delete?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    update?: TestAttemptUpdateWithWhereUniqueWithoutUserInput | TestAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TestAttemptUpdateManyWithWhereWithoutUserInput | TestAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TestAttemptScalarWhereInput | TestAttemptScalarWhereInput[]
  }

  export type TolinerCreateNestedOneWithoutProjectsOwnedInput = {
    create?: XOR<TolinerCreateWithoutProjectsOwnedInput, TolinerUncheckedCreateWithoutProjectsOwnedInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutProjectsOwnedInput
    connect?: TolinerWhereUniqueInput
  }

  export type TolinerCreateNestedOneWithoutProjectsFreelancedInput = {
    create?: XOR<TolinerCreateWithoutProjectsFreelancedInput, TolinerUncheckedCreateWithoutProjectsFreelancedInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutProjectsFreelancedInput
    connect?: TolinerWhereUniqueInput
  }

  export type ProjectSubscriptionCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutProjectInput, ProjectSubscriptionUncheckedCreateWithoutProjectInput> | ProjectSubscriptionCreateWithoutProjectInput[] | ProjectSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutProjectInput | ProjectSubscriptionCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSubscriptionCreateManyProjectInputEnvelope
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutProjectsInput = {
    create?: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SkillCreateNestedManyWithoutProjectsInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type QuotationCreateNestedOneWithoutProjectInput = {
    create?: XOR<QuotationCreateWithoutProjectInput, QuotationUncheckedCreateWithoutProjectInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutProjectInput
    connect?: QuotationWhereUniqueInput
  }

  export type ConversationCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConversationCreateWithoutProjectInput, ConversationUncheckedCreateWithoutProjectInput> | ConversationCreateWithoutProjectInput[] | ConversationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutProjectInput | ConversationCreateOrConnectWithoutProjectInput[]
    createMany?: ConversationCreateManyProjectInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type PaymentCreateNestedOneWithoutProjectInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput
    connect?: PaymentWhereUniqueInput
  }

  export type ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutProjectInput, ProjectSubscriptionUncheckedCreateWithoutProjectInput> | ProjectSubscriptionCreateWithoutProjectInput[] | ProjectSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutProjectInput | ProjectSubscriptionCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectSubscriptionCreateManyProjectInputEnvelope
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutProjectsInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type QuotationUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<QuotationCreateWithoutProjectInput, QuotationUncheckedCreateWithoutProjectInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutProjectInput
    connect?: QuotationWhereUniqueInput
  }

  export type ConversationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ConversationCreateWithoutProjectInput, ConversationUncheckedCreateWithoutProjectInput> | ConversationCreateWithoutProjectInput[] | ConversationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutProjectInput | ConversationCreateOrConnectWithoutProjectInput[]
    createMany?: ConversationCreateManyProjectInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput = {
    create?: XOR<TolinerCreateWithoutProjectsOwnedInput, TolinerUncheckedCreateWithoutProjectsOwnedInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutProjectsOwnedInput
    upsert?: TolinerUpsertWithoutProjectsOwnedInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutProjectsOwnedInput, TolinerUpdateWithoutProjectsOwnedInput>, TolinerUncheckedUpdateWithoutProjectsOwnedInput>
  }

  export type TolinerUpdateOneWithoutProjectsFreelancedNestedInput = {
    create?: XOR<TolinerCreateWithoutProjectsFreelancedInput, TolinerUncheckedCreateWithoutProjectsFreelancedInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutProjectsFreelancedInput
    upsert?: TolinerUpsertWithoutProjectsFreelancedInput
    disconnect?: TolinerWhereInput | boolean
    delete?: TolinerWhereInput | boolean
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutProjectsFreelancedInput, TolinerUpdateWithoutProjectsFreelancedInput>, TolinerUncheckedUpdateWithoutProjectsFreelancedInput>
  }

  export type ProjectSubscriptionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutProjectInput, ProjectSubscriptionUncheckedCreateWithoutProjectInput> | ProjectSubscriptionCreateWithoutProjectInput[] | ProjectSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutProjectInput | ProjectSubscriptionCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSubscriptionUpsertWithWhereUniqueWithoutProjectInput | ProjectSubscriptionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSubscriptionCreateManyProjectInputEnvelope
    set?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    disconnect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    delete?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    update?: ProjectSubscriptionUpdateWithWhereUniqueWithoutProjectInput | ProjectSubscriptionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSubscriptionUpdateManyWithWhereWithoutProjectInput | ProjectSubscriptionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSubscriptionScalarWhereInput | ProjectSubscriptionScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProjectsInput
    upsert?: CategoryUpsertWithoutProjectsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProjectsInput, CategoryUpdateWithoutProjectsInput>, CategoryUncheckedUpdateWithoutProjectsInput>
  }

  export type SkillUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutProjectsInput | SkillUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutProjectsInput | SkillUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutProjectsInput | SkillUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type QuotationUpdateOneWithoutProjectNestedInput = {
    create?: XOR<QuotationCreateWithoutProjectInput, QuotationUncheckedCreateWithoutProjectInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutProjectInput
    upsert?: QuotationUpsertWithoutProjectInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutProjectInput, QuotationUpdateWithoutProjectInput>, QuotationUncheckedUpdateWithoutProjectInput>
  }

  export type ConversationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConversationCreateWithoutProjectInput, ConversationUncheckedCreateWithoutProjectInput> | ConversationCreateWithoutProjectInput[] | ConversationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutProjectInput | ConversationCreateOrConnectWithoutProjectInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutProjectInput | ConversationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConversationCreateManyProjectInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutProjectInput | ConversationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutProjectInput | ConversationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type PaymentUpdateOneWithoutProjectNestedInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput
    upsert?: PaymentUpsertWithoutProjectInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutProjectInput, PaymentUpdateWithoutProjectInput>, PaymentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectSubscriptionCreateWithoutProjectInput, ProjectSubscriptionUncheckedCreateWithoutProjectInput> | ProjectSubscriptionCreateWithoutProjectInput[] | ProjectSubscriptionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectSubscriptionCreateOrConnectWithoutProjectInput | ProjectSubscriptionCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectSubscriptionUpsertWithWhereUniqueWithoutProjectInput | ProjectSubscriptionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectSubscriptionCreateManyProjectInputEnvelope
    set?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    disconnect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    delete?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    connect?: ProjectSubscriptionWhereUniqueInput | ProjectSubscriptionWhereUniqueInput[]
    update?: ProjectSubscriptionUpdateWithWhereUniqueWithoutProjectInput | ProjectSubscriptionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectSubscriptionUpdateManyWithWhereWithoutProjectInput | ProjectSubscriptionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectSubscriptionScalarWhereInput | ProjectSubscriptionScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutProjectsNestedInput = {
    create?: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput> | SkillCreateWithoutProjectsInput[] | SkillUncheckedCreateWithoutProjectsInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutProjectsInput | SkillCreateOrConnectWithoutProjectsInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutProjectsInput | SkillUpsertWithWhereUniqueWithoutProjectsInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutProjectsInput | SkillUpdateWithWhereUniqueWithoutProjectsInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutProjectsInput | SkillUpdateManyWithWhereWithoutProjectsInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type QuotationUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<QuotationCreateWithoutProjectInput, QuotationUncheckedCreateWithoutProjectInput>
    connectOrCreate?: QuotationCreateOrConnectWithoutProjectInput
    upsert?: QuotationUpsertWithoutProjectInput
    disconnect?: QuotationWhereInput | boolean
    delete?: QuotationWhereInput | boolean
    connect?: QuotationWhereUniqueInput
    update?: XOR<XOR<QuotationUpdateToOneWithWhereWithoutProjectInput, QuotationUpdateWithoutProjectInput>, QuotationUncheckedUpdateWithoutProjectInput>
  }

  export type ConversationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ConversationCreateWithoutProjectInput, ConversationUncheckedCreateWithoutProjectInput> | ConversationCreateWithoutProjectInput[] | ConversationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutProjectInput | ConversationCreateOrConnectWithoutProjectInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutProjectInput | ConversationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ConversationCreateManyProjectInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutProjectInput | ConversationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutProjectInput | ConversationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutProjectInput
    upsert?: PaymentUpsertWithoutProjectInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutProjectInput, PaymentUpdateWithoutProjectInput>, PaymentUncheckedUpdateWithoutProjectInput>
  }

  export type TolinerCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<TolinerCreateWithoutSubscriptionsInput, TolinerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutSubscriptionsInput
    connect?: TolinerWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<ProjectCreateWithoutSubscriptionsInput, ProjectUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubscriptionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TolinerUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<TolinerCreateWithoutSubscriptionsInput, TolinerUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutSubscriptionsInput
    upsert?: TolinerUpsertWithoutSubscriptionsInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutSubscriptionsInput, TolinerUpdateWithoutSubscriptionsInput>, TolinerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ProjectUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<ProjectCreateWithoutSubscriptionsInput, ProjectUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubscriptionsInput
    upsert?: ProjectUpsertWithoutSubscriptionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSubscriptionsInput, ProjectUpdateWithoutSubscriptionsInput>, ProjectUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SkillCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SkillCreateWithoutCategoryInput, SkillUncheckedCreateWithoutCategoryInput> | SkillCreateWithoutCategoryInput[] | SkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCategoryInput | SkillCreateOrConnectWithoutCategoryInput[]
    createMany?: SkillCreateManyCategoryInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type TolinerCreateNestedManyWithoutSpecializationInput = {
    create?: XOR<TolinerCreateWithoutSpecializationInput, TolinerUncheckedCreateWithoutSpecializationInput> | TolinerCreateWithoutSpecializationInput[] | TolinerUncheckedCreateWithoutSpecializationInput[]
    connectOrCreate?: TolinerCreateOrConnectWithoutSpecializationInput | TolinerCreateOrConnectWithoutSpecializationInput[]
    connect?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
  }

  export type SubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProjectCreateWithoutCategoryInput, ProjectUncheckedCreateWithoutCategoryInput> | ProjectCreateWithoutCategoryInput[] | ProjectUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoryInput | ProjectCreateOrConnectWithoutCategoryInput[]
    createMany?: ProjectCreateManyCategoryInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SkillCreateWithoutCategoryInput, SkillUncheckedCreateWithoutCategoryInput> | SkillCreateWithoutCategoryInput[] | SkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCategoryInput | SkillCreateOrConnectWithoutCategoryInput[]
    createMany?: SkillCreateManyCategoryInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type TolinerUncheckedCreateNestedManyWithoutSpecializationInput = {
    create?: XOR<TolinerCreateWithoutSpecializationInput, TolinerUncheckedCreateWithoutSpecializationInput> | TolinerCreateWithoutSpecializationInput[] | TolinerUncheckedCreateWithoutSpecializationInput[]
    connectOrCreate?: TolinerCreateOrConnectWithoutSpecializationInput | TolinerCreateOrConnectWithoutSpecializationInput[]
    connect?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
  }

  export type SubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProjectCreateWithoutCategoryInput, ProjectUncheckedCreateWithoutCategoryInput> | ProjectCreateWithoutCategoryInput[] | ProjectUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoryInput | ProjectCreateOrConnectWithoutCategoryInput[]
    createMany?: ProjectCreateManyCategoryInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type SkillUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SkillCreateWithoutCategoryInput, SkillUncheckedCreateWithoutCategoryInput> | SkillCreateWithoutCategoryInput[] | SkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCategoryInput | SkillCreateOrConnectWithoutCategoryInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutCategoryInput | SkillUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SkillCreateManyCategoryInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutCategoryInput | SkillUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutCategoryInput | SkillUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type TolinerUpdateManyWithoutSpecializationNestedInput = {
    create?: XOR<TolinerCreateWithoutSpecializationInput, TolinerUncheckedCreateWithoutSpecializationInput> | TolinerCreateWithoutSpecializationInput[] | TolinerUncheckedCreateWithoutSpecializationInput[]
    connectOrCreate?: TolinerCreateOrConnectWithoutSpecializationInput | TolinerCreateOrConnectWithoutSpecializationInput[]
    upsert?: TolinerUpsertWithWhereUniqueWithoutSpecializationInput | TolinerUpsertWithWhereUniqueWithoutSpecializationInput[]
    set?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    disconnect?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    delete?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    connect?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    update?: TolinerUpdateWithWhereUniqueWithoutSpecializationInput | TolinerUpdateWithWhereUniqueWithoutSpecializationInput[]
    updateMany?: TolinerUpdateManyWithWhereWithoutSpecializationInput | TolinerUpdateManyWithWhereWithoutSpecializationInput[]
    deleteMany?: TolinerScalarWhereInput | TolinerScalarWhereInput[]
  }

  export type SubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProjectCreateWithoutCategoryInput, ProjectUncheckedCreateWithoutCategoryInput> | ProjectCreateWithoutCategoryInput[] | ProjectUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoryInput | ProjectCreateOrConnectWithoutCategoryInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCategoryInput | ProjectUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProjectCreateManyCategoryInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCategoryInput | ProjectUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCategoryInput | ProjectUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SkillCreateWithoutCategoryInput, SkillUncheckedCreateWithoutCategoryInput> | SkillCreateWithoutCategoryInput[] | SkillUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutCategoryInput | SkillCreateOrConnectWithoutCategoryInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutCategoryInput | SkillUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SkillCreateManyCategoryInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutCategoryInput | SkillUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutCategoryInput | SkillUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type TolinerUncheckedUpdateManyWithoutSpecializationNestedInput = {
    create?: XOR<TolinerCreateWithoutSpecializationInput, TolinerUncheckedCreateWithoutSpecializationInput> | TolinerCreateWithoutSpecializationInput[] | TolinerUncheckedCreateWithoutSpecializationInput[]
    connectOrCreate?: TolinerCreateOrConnectWithoutSpecializationInput | TolinerCreateOrConnectWithoutSpecializationInput[]
    upsert?: TolinerUpsertWithWhereUniqueWithoutSpecializationInput | TolinerUpsertWithWhereUniqueWithoutSpecializationInput[]
    set?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    disconnect?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    delete?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    connect?: TolinerWhereUniqueInput | TolinerWhereUniqueInput[]
    update?: TolinerUpdateWithWhereUniqueWithoutSpecializationInput | TolinerUpdateWithWhereUniqueWithoutSpecializationInput[]
    updateMany?: TolinerUpdateManyWithWhereWithoutSpecializationInput | TolinerUpdateManyWithWhereWithoutSpecializationInput[]
    deleteMany?: TolinerScalarWhereInput | TolinerScalarWhereInput[]
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProjectCreateWithoutCategoryInput, ProjectUncheckedCreateWithoutCategoryInput> | ProjectCreateWithoutCategoryInput[] | ProjectUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCategoryInput | ProjectCreateOrConnectWithoutCategoryInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCategoryInput | ProjectUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProjectCreateManyCategoryInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCategoryInput | ProjectUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCategoryInput | ProjectUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryUpdateOneWithoutSubcategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: CategoryUpsertWithoutSubcategoriesInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubcategoriesInput, CategoryUpdateWithoutSubcategoriesInput>, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type TolinerCreateNestedOneWithoutFreelancerEvaluationInput = {
    create?: XOR<TolinerCreateWithoutFreelancerEvaluationInput, TolinerUncheckedCreateWithoutFreelancerEvaluationInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutFreelancerEvaluationInput
    connect?: TolinerWhereUniqueInput
  }

  export type TolinerUpdateOneRequiredWithoutFreelancerEvaluationNestedInput = {
    create?: XOR<TolinerCreateWithoutFreelancerEvaluationInput, TolinerUncheckedCreateWithoutFreelancerEvaluationInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutFreelancerEvaluationInput
    upsert?: TolinerUpsertWithoutFreelancerEvaluationInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutFreelancerEvaluationInput, TolinerUpdateWithoutFreelancerEvaluationInput>, TolinerUncheckedUpdateWithoutFreelancerEvaluationInput>
  }

  export type ProjectCreateNestedOneWithoutQuotationInput = {
    create?: XOR<ProjectCreateWithoutQuotationInput, ProjectUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutQuotationInput
    connect?: ProjectWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutQuotationNestedInput = {
    create?: XOR<ProjectCreateWithoutQuotationInput, ProjectUncheckedCreateWithoutQuotationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutQuotationInput
    upsert?: ProjectUpsertWithoutQuotationInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutQuotationInput, ProjectUpdateWithoutQuotationInput>, ProjectUncheckedUpdateWithoutQuotationInput>
  }

  export type UserCreateNestedManyWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProjectCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ProjectCreateWithoutConversationsInput, ProjectUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConversationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutConversationsInput | UserUpsertWithWhereUniqueWithoutConversationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutConversationsInput | UserUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutConversationsInput | UserUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ProjectUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<ProjectCreateWithoutConversationsInput, ProjectUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutConversationsInput
    upsert?: ProjectUpsertWithoutConversationsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutConversationsInput, ProjectUpdateWithoutConversationsInput>, ProjectUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUncheckedUpdateManyWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput> | UserCreateWithoutConversationsInput[] | UserUncheckedCreateWithoutConversationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput | UserCreateOrConnectWithoutConversationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutConversationsInput | UserUpsertWithWhereUniqueWithoutConversationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutConversationsInput | UserUpdateWithWhereUniqueWithoutConversationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutConversationsInput | UserUpdateManyWithWhereWithoutConversationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type SkillCreateNestedManyWithoutPortifoliosInput = {
    create?: XOR<SkillCreateWithoutPortifoliosInput, SkillUncheckedCreateWithoutPortifoliosInput> | SkillCreateWithoutPortifoliosInput[] | SkillUncheckedCreateWithoutPortifoliosInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutPortifoliosInput | SkillCreateOrConnectWithoutPortifoliosInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type TolinerCreateNestedOneWithoutPortifolioInput = {
    create?: XOR<TolinerCreateWithoutPortifolioInput, TolinerUncheckedCreateWithoutPortifolioInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutPortifolioInput
    connect?: TolinerWhereUniqueInput
  }

  export type SkillUncheckedCreateNestedManyWithoutPortifoliosInput = {
    create?: XOR<SkillCreateWithoutPortifoliosInput, SkillUncheckedCreateWithoutPortifoliosInput> | SkillCreateWithoutPortifoliosInput[] | SkillUncheckedCreateWithoutPortifoliosInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutPortifoliosInput | SkillCreateOrConnectWithoutPortifoliosInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SkillUpdateManyWithoutPortifoliosNestedInput = {
    create?: XOR<SkillCreateWithoutPortifoliosInput, SkillUncheckedCreateWithoutPortifoliosInput> | SkillCreateWithoutPortifoliosInput[] | SkillUncheckedCreateWithoutPortifoliosInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutPortifoliosInput | SkillCreateOrConnectWithoutPortifoliosInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutPortifoliosInput | SkillUpsertWithWhereUniqueWithoutPortifoliosInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutPortifoliosInput | SkillUpdateWithWhereUniqueWithoutPortifoliosInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutPortifoliosInput | SkillUpdateManyWithWhereWithoutPortifoliosInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type TolinerUpdateOneWithoutPortifolioNestedInput = {
    create?: XOR<TolinerCreateWithoutPortifolioInput, TolinerUncheckedCreateWithoutPortifolioInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutPortifolioInput
    upsert?: TolinerUpsertWithoutPortifolioInput
    disconnect?: TolinerWhereInput | boolean
    delete?: TolinerWhereInput | boolean
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutPortifolioInput, TolinerUpdateWithoutPortifolioInput>, TolinerUncheckedUpdateWithoutPortifolioInput>
  }

  export type SkillUncheckedUpdateManyWithoutPortifoliosNestedInput = {
    create?: XOR<SkillCreateWithoutPortifoliosInput, SkillUncheckedCreateWithoutPortifoliosInput> | SkillCreateWithoutPortifoliosInput[] | SkillUncheckedCreateWithoutPortifoliosInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutPortifoliosInput | SkillCreateOrConnectWithoutPortifoliosInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutPortifoliosInput | SkillUpsertWithWhereUniqueWithoutPortifoliosInput[]
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutPortifoliosInput | SkillUpdateWithWhereUniqueWithoutPortifoliosInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutPortifoliosInput | SkillUpdateManyWithWhereWithoutPortifoliosInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ProjectCreateWithoutPaymentInput, ProjectUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPaymentInput
    connect?: ProjectWhereUniqueInput
  }

  export type TolinerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TolinerCreateWithoutPaymentsInput, TolinerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutPaymentsInput
    connect?: TolinerWhereUniqueInput
  }

  export type TolinerCreateNestedOneWithoutFreelancerPaymentsInput = {
    create?: XOR<TolinerCreateWithoutFreelancerPaymentsInput, TolinerUncheckedCreateWithoutFreelancerPaymentsInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutFreelancerPaymentsInput
    connect?: TolinerWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type ProjectUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<ProjectCreateWithoutPaymentInput, ProjectUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPaymentInput
    upsert?: ProjectUpsertWithoutPaymentInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPaymentInput, ProjectUpdateWithoutPaymentInput>, ProjectUncheckedUpdateWithoutPaymentInput>
  }

  export type TolinerUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TolinerCreateWithoutPaymentsInput, TolinerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutPaymentsInput
    upsert?: TolinerUpsertWithoutPaymentsInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutPaymentsInput, TolinerUpdateWithoutPaymentsInput>, TolinerUncheckedUpdateWithoutPaymentsInput>
  }

  export type TolinerUpdateOneRequiredWithoutFreelancerPaymentsNestedInput = {
    create?: XOR<TolinerCreateWithoutFreelancerPaymentsInput, TolinerUncheckedCreateWithoutFreelancerPaymentsInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutFreelancerPaymentsInput
    upsert?: TolinerUpsertWithoutFreelancerPaymentsInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutFreelancerPaymentsInput, TolinerUpdateWithoutFreelancerPaymentsInput>, TolinerUncheckedUpdateWithoutFreelancerPaymentsInput>
  }

  export type TolinerCreateNestedOneWithoutChargesInput = {
    create?: XOR<TolinerCreateWithoutChargesInput, TolinerUncheckedCreateWithoutChargesInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutChargesInput
    connect?: TolinerWhereUniqueInput
  }

  export type EnumChargeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChargeStatus
  }

  export type TolinerUpdateOneRequiredWithoutChargesNestedInput = {
    create?: XOR<TolinerCreateWithoutChargesInput, TolinerUncheckedCreateWithoutChargesInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutChargesInput
    upsert?: TolinerUpsertWithoutChargesInput
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutChargesInput, TolinerUpdateWithoutChargesInput>, TolinerUncheckedUpdateWithoutChargesInput>
  }

  export type TolinerCreateNestedOneWithoutBalanceInput = {
    create?: XOR<TolinerCreateWithoutBalanceInput, TolinerUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutBalanceInput
    connect?: TolinerWhereUniqueInput
  }

  export type TolinerUpdateOneWithoutBalanceNestedInput = {
    create?: XOR<TolinerCreateWithoutBalanceInput, TolinerUncheckedCreateWithoutBalanceInput>
    connectOrCreate?: TolinerCreateOrConnectWithoutBalanceInput
    upsert?: TolinerUpsertWithoutBalanceInput
    disconnect?: TolinerWhereInput | boolean
    delete?: TolinerWhereInput | boolean
    connect?: TolinerWhereUniqueInput
    update?: XOR<XOR<TolinerUpdateToOneWithWhereWithoutBalanceInput, TolinerUpdateWithoutBalanceInput>, TolinerUncheckedUpdateWithoutBalanceInput>
  }

  export type CategoryCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CategoryCreateWithoutSkillsInput, CategoryUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSkillsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutSkillsInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput> | UserCreateWithoutSkillsInput[] | UserUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput | UserCreateOrConnectWithoutSkillsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PortifolioCreateNestedManyWithoutSkillsInput = {
    create?: XOR<PortifolioCreateWithoutSkillsInput, PortifolioUncheckedCreateWithoutSkillsInput> | PortifolioCreateWithoutSkillsInput[] | PortifolioUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutSkillsInput | PortifolioCreateOrConnectWithoutSkillsInput[]
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutSkillsInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CertificationTestCreateNestedOneWithoutSkillInput = {
    create?: XOR<CertificationTestCreateWithoutSkillInput, CertificationTestUncheckedCreateWithoutSkillInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutSkillInput
    connect?: CertificationTestWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput> | UserCreateWithoutSkillsInput[] | UserUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput | UserCreateOrConnectWithoutSkillsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PortifolioUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<PortifolioCreateWithoutSkillsInput, PortifolioUncheckedCreateWithoutSkillsInput> | PortifolioCreateWithoutSkillsInput[] | PortifolioUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutSkillsInput | PortifolioCreateOrConnectWithoutSkillsInput[]
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type CertificationTestUncheckedCreateNestedOneWithoutSkillInput = {
    create?: XOR<CertificationTestCreateWithoutSkillInput, CertificationTestUncheckedCreateWithoutSkillInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutSkillInput
    connect?: CertificationTestWhereUniqueInput
  }

  export type CategoryUpdateOneWithoutSkillsNestedInput = {
    create?: XOR<CategoryCreateWithoutSkillsInput, CategoryUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSkillsInput
    upsert?: CategoryUpsertWithoutSkillsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSkillsInput, CategoryUpdateWithoutSkillsInput>, CategoryUncheckedUpdateWithoutSkillsInput>
  }

  export type UserUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput> | UserCreateWithoutSkillsInput[] | UserUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput | UserCreateOrConnectWithoutSkillsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSkillsInput | UserUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSkillsInput | UserUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSkillsInput | UserUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PortifolioUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<PortifolioCreateWithoutSkillsInput, PortifolioUncheckedCreateWithoutSkillsInput> | PortifolioCreateWithoutSkillsInput[] | PortifolioUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutSkillsInput | PortifolioCreateOrConnectWithoutSkillsInput[]
    upsert?: PortifolioUpsertWithWhereUniqueWithoutSkillsInput | PortifolioUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    disconnect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    delete?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    update?: PortifolioUpdateWithWhereUniqueWithoutSkillsInput | PortifolioUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: PortifolioUpdateManyWithWhereWithoutSkillsInput | PortifolioUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: PortifolioScalarWhereInput | PortifolioScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutSkillsInput | ProjectUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutSkillsInput | ProjectUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutSkillsInput | ProjectUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CertificationTestUpdateOneWithoutSkillNestedInput = {
    create?: XOR<CertificationTestCreateWithoutSkillInput, CertificationTestUncheckedCreateWithoutSkillInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutSkillInput
    upsert?: CertificationTestUpsertWithoutSkillInput
    disconnect?: CertificationTestWhereInput | boolean
    delete?: CertificationTestWhereInput | boolean
    connect?: CertificationTestWhereUniqueInput
    update?: XOR<XOR<CertificationTestUpdateToOneWithWhereWithoutSkillInput, CertificationTestUpdateWithoutSkillInput>, CertificationTestUncheckedUpdateWithoutSkillInput>
  }

  export type UserUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput> | UserCreateWithoutSkillsInput[] | UserUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutSkillsInput | UserCreateOrConnectWithoutSkillsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutSkillsInput | UserUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutSkillsInput | UserUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutSkillsInput | UserUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PortifolioUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<PortifolioCreateWithoutSkillsInput, PortifolioUncheckedCreateWithoutSkillsInput> | PortifolioCreateWithoutSkillsInput[] | PortifolioUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: PortifolioCreateOrConnectWithoutSkillsInput | PortifolioCreateOrConnectWithoutSkillsInput[]
    upsert?: PortifolioUpsertWithWhereUniqueWithoutSkillsInput | PortifolioUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    disconnect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    delete?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    connect?: PortifolioWhereUniqueInput | PortifolioWhereUniqueInput[]
    update?: PortifolioUpdateWithWhereUniqueWithoutSkillsInput | PortifolioUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: PortifolioUpdateManyWithWhereWithoutSkillsInput | PortifolioUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: PortifolioScalarWhereInput | PortifolioScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput> | ProjectCreateWithoutSkillsInput[] | ProjectUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutSkillsInput | ProjectCreateOrConnectWithoutSkillsInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutSkillsInput | ProjectUpsertWithWhereUniqueWithoutSkillsInput[]
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutSkillsInput | ProjectUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutSkillsInput | ProjectUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type CertificationTestUncheckedUpdateOneWithoutSkillNestedInput = {
    create?: XOR<CertificationTestCreateWithoutSkillInput, CertificationTestUncheckedCreateWithoutSkillInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutSkillInput
    upsert?: CertificationTestUpsertWithoutSkillInput
    disconnect?: CertificationTestWhereInput | boolean
    delete?: CertificationTestWhereInput | boolean
    connect?: CertificationTestWhereUniqueInput
    update?: XOR<XOR<CertificationTestUpdateToOneWithWhereWithoutSkillInput, CertificationTestUpdateWithoutSkillInput>, CertificationTestUncheckedUpdateWithoutSkillInput>
  }

  export type SkillCreateNestedOneWithoutCertificationTestInput = {
    create?: XOR<SkillCreateWithoutCertificationTestInput, SkillUncheckedCreateWithoutCertificationTestInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCertificationTestInput
    connect?: SkillWhereUniqueInput
  }

  export type QuestionCreateNestedManyWithoutCertificationTestInput = {
    create?: XOR<QuestionCreateWithoutCertificationTestInput, QuestionUncheckedCreateWithoutCertificationTestInput> | QuestionCreateWithoutCertificationTestInput[] | QuestionUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCertificationTestInput | QuestionCreateOrConnectWithoutCertificationTestInput[]
    createMany?: QuestionCreateManyCertificationTestInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type TestAttemptCreateNestedManyWithoutCertificationTestInput = {
    create?: XOR<TestAttemptCreateWithoutCertificationTestInput, TestAttemptUncheckedCreateWithoutCertificationTestInput> | TestAttemptCreateWithoutCertificationTestInput[] | TestAttemptUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutCertificationTestInput | TestAttemptCreateOrConnectWithoutCertificationTestInput[]
    createMany?: TestAttemptCreateManyCertificationTestInputEnvelope
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutCertificationTestInput = {
    create?: XOR<QuestionCreateWithoutCertificationTestInput, QuestionUncheckedCreateWithoutCertificationTestInput> | QuestionCreateWithoutCertificationTestInput[] | QuestionUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCertificationTestInput | QuestionCreateOrConnectWithoutCertificationTestInput[]
    createMany?: QuestionCreateManyCertificationTestInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type TestAttemptUncheckedCreateNestedManyWithoutCertificationTestInput = {
    create?: XOR<TestAttemptCreateWithoutCertificationTestInput, TestAttemptUncheckedCreateWithoutCertificationTestInput> | TestAttemptCreateWithoutCertificationTestInput[] | TestAttemptUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutCertificationTestInput | TestAttemptCreateOrConnectWithoutCertificationTestInput[]
    createMany?: TestAttemptCreateManyCertificationTestInputEnvelope
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SkillUpdateOneRequiredWithoutCertificationTestNestedInput = {
    create?: XOR<SkillCreateWithoutCertificationTestInput, SkillUncheckedCreateWithoutCertificationTestInput>
    connectOrCreate?: SkillCreateOrConnectWithoutCertificationTestInput
    upsert?: SkillUpsertWithoutCertificationTestInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutCertificationTestInput, SkillUpdateWithoutCertificationTestInput>, SkillUncheckedUpdateWithoutCertificationTestInput>
  }

  export type QuestionUpdateManyWithoutCertificationTestNestedInput = {
    create?: XOR<QuestionCreateWithoutCertificationTestInput, QuestionUncheckedCreateWithoutCertificationTestInput> | QuestionCreateWithoutCertificationTestInput[] | QuestionUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCertificationTestInput | QuestionCreateOrConnectWithoutCertificationTestInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCertificationTestInput | QuestionUpsertWithWhereUniqueWithoutCertificationTestInput[]
    createMany?: QuestionCreateManyCertificationTestInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCertificationTestInput | QuestionUpdateWithWhereUniqueWithoutCertificationTestInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCertificationTestInput | QuestionUpdateManyWithWhereWithoutCertificationTestInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type TestAttemptUpdateManyWithoutCertificationTestNestedInput = {
    create?: XOR<TestAttemptCreateWithoutCertificationTestInput, TestAttemptUncheckedCreateWithoutCertificationTestInput> | TestAttemptCreateWithoutCertificationTestInput[] | TestAttemptUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutCertificationTestInput | TestAttemptCreateOrConnectWithoutCertificationTestInput[]
    upsert?: TestAttemptUpsertWithWhereUniqueWithoutCertificationTestInput | TestAttemptUpsertWithWhereUniqueWithoutCertificationTestInput[]
    createMany?: TestAttemptCreateManyCertificationTestInputEnvelope
    set?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    disconnect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    delete?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    update?: TestAttemptUpdateWithWhereUniqueWithoutCertificationTestInput | TestAttemptUpdateWithWhereUniqueWithoutCertificationTestInput[]
    updateMany?: TestAttemptUpdateManyWithWhereWithoutCertificationTestInput | TestAttemptUpdateManyWithWhereWithoutCertificationTestInput[]
    deleteMany?: TestAttemptScalarWhereInput | TestAttemptScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutCertificationTestNestedInput = {
    create?: XOR<QuestionCreateWithoutCertificationTestInput, QuestionUncheckedCreateWithoutCertificationTestInput> | QuestionCreateWithoutCertificationTestInput[] | QuestionUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCertificationTestInput | QuestionCreateOrConnectWithoutCertificationTestInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCertificationTestInput | QuestionUpsertWithWhereUniqueWithoutCertificationTestInput[]
    createMany?: QuestionCreateManyCertificationTestInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCertificationTestInput | QuestionUpdateWithWhereUniqueWithoutCertificationTestInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCertificationTestInput | QuestionUpdateManyWithWhereWithoutCertificationTestInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type TestAttemptUncheckedUpdateManyWithoutCertificationTestNestedInput = {
    create?: XOR<TestAttemptCreateWithoutCertificationTestInput, TestAttemptUncheckedCreateWithoutCertificationTestInput> | TestAttemptCreateWithoutCertificationTestInput[] | TestAttemptUncheckedCreateWithoutCertificationTestInput[]
    connectOrCreate?: TestAttemptCreateOrConnectWithoutCertificationTestInput | TestAttemptCreateOrConnectWithoutCertificationTestInput[]
    upsert?: TestAttemptUpsertWithWhereUniqueWithoutCertificationTestInput | TestAttemptUpsertWithWhereUniqueWithoutCertificationTestInput[]
    createMany?: TestAttemptCreateManyCertificationTestInputEnvelope
    set?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    disconnect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    delete?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    connect?: TestAttemptWhereUniqueInput | TestAttemptWhereUniqueInput[]
    update?: TestAttemptUpdateWithWhereUniqueWithoutCertificationTestInput | TestAttemptUpdateWithWhereUniqueWithoutCertificationTestInput[]
    updateMany?: TestAttemptUpdateManyWithWhereWithoutCertificationTestInput | TestAttemptUpdateManyWithWhereWithoutCertificationTestInput[]
    deleteMany?: TestAttemptScalarWhereInput | TestAttemptScalarWhereInput[]
  }

  export type CertificationTestCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<CertificationTestCreateWithoutQuestionsInput, CertificationTestUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutQuestionsInput
    connect?: CertificationTestWhereUniqueInput
  }

  export type AlternativeCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
  }

  export type AnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type AlternativeUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type CertificationTestUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<CertificationTestCreateWithoutQuestionsInput, CertificationTestUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutQuestionsInput
    upsert?: CertificationTestUpsertWithoutQuestionsInput
    connect?: CertificationTestWhereUniqueInput
    update?: XOR<XOR<CertificationTestUpdateToOneWithWhereWithoutQuestionsInput, CertificationTestUpdateWithoutQuestionsInput>, CertificationTestUncheckedUpdateWithoutQuestionsInput>
  }

  export type AlternativeUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    upsert?: AlternativeUpsertWithWhereUniqueWithoutQuestionInput | AlternativeUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    set?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    disconnect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    delete?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    update?: AlternativeUpdateWithWhereUniqueWithoutQuestionInput | AlternativeUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AlternativeUpdateManyWithWhereWithoutQuestionInput | AlternativeUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
  }

  export type AnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type AlternativeUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput> | AlternativeCreateWithoutQuestionInput[] | AlternativeUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AlternativeCreateOrConnectWithoutQuestionInput | AlternativeCreateOrConnectWithoutQuestionInput[]
    upsert?: AlternativeUpsertWithWhereUniqueWithoutQuestionInput | AlternativeUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AlternativeCreateManyQuestionInputEnvelope
    set?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    disconnect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    delete?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    connect?: AlternativeWhereUniqueInput | AlternativeWhereUniqueInput[]
    update?: AlternativeUpdateWithWhereUniqueWithoutQuestionInput | AlternativeUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AlternativeUpdateManyWithWhereWithoutQuestionInput | AlternativeUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput> | AnswerCreateWithoutQuestionInput[] | AnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutQuestionInput | AnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutQuestionInput | AnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: AnswerCreateManyQuestionInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutQuestionInput | AnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutQuestionInput | AnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutAlternativesInput = {
    create?: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAlternativesInput
    connect?: QuestionWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutAlternativeInput = {
    create?: XOR<AnswerCreateWithoutAlternativeInput, AnswerUncheckedCreateWithoutAlternativeInput> | AnswerCreateWithoutAlternativeInput[] | AnswerUncheckedCreateWithoutAlternativeInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAlternativeInput | AnswerCreateOrConnectWithoutAlternativeInput[]
    createMany?: AnswerCreateManyAlternativeInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutAlternativeInput = {
    create?: XOR<AnswerCreateWithoutAlternativeInput, AnswerUncheckedCreateWithoutAlternativeInput> | AnswerCreateWithoutAlternativeInput[] | AnswerUncheckedCreateWithoutAlternativeInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAlternativeInput | AnswerCreateOrConnectWithoutAlternativeInput[]
    createMany?: AnswerCreateManyAlternativeInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type QuestionUpdateOneRequiredWithoutAlternativesNestedInput = {
    create?: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAlternativesInput
    upsert?: QuestionUpsertWithoutAlternativesInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAlternativesInput, QuestionUpdateWithoutAlternativesInput>, QuestionUncheckedUpdateWithoutAlternativesInput>
  }

  export type AnswerUpdateManyWithoutAlternativeNestedInput = {
    create?: XOR<AnswerCreateWithoutAlternativeInput, AnswerUncheckedCreateWithoutAlternativeInput> | AnswerCreateWithoutAlternativeInput[] | AnswerUncheckedCreateWithoutAlternativeInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAlternativeInput | AnswerCreateOrConnectWithoutAlternativeInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutAlternativeInput | AnswerUpsertWithWhereUniqueWithoutAlternativeInput[]
    createMany?: AnswerCreateManyAlternativeInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutAlternativeInput | AnswerUpdateWithWhereUniqueWithoutAlternativeInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutAlternativeInput | AnswerUpdateManyWithWhereWithoutAlternativeInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutAlternativeNestedInput = {
    create?: XOR<AnswerCreateWithoutAlternativeInput, AnswerUncheckedCreateWithoutAlternativeInput> | AnswerCreateWithoutAlternativeInput[] | AnswerUncheckedCreateWithoutAlternativeInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutAlternativeInput | AnswerCreateOrConnectWithoutAlternativeInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutAlternativeInput | AnswerUpsertWithWhereUniqueWithoutAlternativeInput[]
    createMany?: AnswerCreateManyAlternativeInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutAlternativeInput | AnswerUpdateWithWhereUniqueWithoutAlternativeInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutAlternativeInput | AnswerUpdateManyWithWhereWithoutAlternativeInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type CertificationTestCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<CertificationTestCreateWithoutAttemptsInput, CertificationTestUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutAttemptsInput
    connect?: CertificationTestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTestAttemptInput = {
    create?: XOR<UserCreateWithoutTestAttemptInput, UserUncheckedCreateWithoutTestAttemptInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestAttemptInput
    connect?: UserWhereUniqueInput
  }

  export type AnswerCreateNestedManyWithoutTestAttemptInput = {
    create?: XOR<AnswerCreateWithoutTestAttemptInput, AnswerUncheckedCreateWithoutTestAttemptInput> | AnswerCreateWithoutTestAttemptInput[] | AnswerUncheckedCreateWithoutTestAttemptInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutTestAttemptInput | AnswerCreateOrConnectWithoutTestAttemptInput[]
    createMany?: AnswerCreateManyTestAttemptInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type AnswerUncheckedCreateNestedManyWithoutTestAttemptInput = {
    create?: XOR<AnswerCreateWithoutTestAttemptInput, AnswerUncheckedCreateWithoutTestAttemptInput> | AnswerCreateWithoutTestAttemptInput[] | AnswerUncheckedCreateWithoutTestAttemptInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutTestAttemptInput | AnswerCreateOrConnectWithoutTestAttemptInput[]
    createMany?: AnswerCreateManyTestAttemptInputEnvelope
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CertificationTestUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<CertificationTestCreateWithoutAttemptsInput, CertificationTestUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: CertificationTestCreateOrConnectWithoutAttemptsInput
    upsert?: CertificationTestUpsertWithoutAttemptsInput
    connect?: CertificationTestWhereUniqueInput
    update?: XOR<XOR<CertificationTestUpdateToOneWithWhereWithoutAttemptsInput, CertificationTestUpdateWithoutAttemptsInput>, CertificationTestUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateOneRequiredWithoutTestAttemptNestedInput = {
    create?: XOR<UserCreateWithoutTestAttemptInput, UserUncheckedCreateWithoutTestAttemptInput>
    connectOrCreate?: UserCreateOrConnectWithoutTestAttemptInput
    upsert?: UserUpsertWithoutTestAttemptInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTestAttemptInput, UserUpdateWithoutTestAttemptInput>, UserUncheckedUpdateWithoutTestAttemptInput>
  }

  export type AnswerUpdateManyWithoutTestAttemptNestedInput = {
    create?: XOR<AnswerCreateWithoutTestAttemptInput, AnswerUncheckedCreateWithoutTestAttemptInput> | AnswerCreateWithoutTestAttemptInput[] | AnswerUncheckedCreateWithoutTestAttemptInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutTestAttemptInput | AnswerCreateOrConnectWithoutTestAttemptInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutTestAttemptInput | AnswerUpsertWithWhereUniqueWithoutTestAttemptInput[]
    createMany?: AnswerCreateManyTestAttemptInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutTestAttemptInput | AnswerUpdateWithWhereUniqueWithoutTestAttemptInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutTestAttemptInput | AnswerUpdateManyWithWhereWithoutTestAttemptInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type AnswerUncheckedUpdateManyWithoutTestAttemptNestedInput = {
    create?: XOR<AnswerCreateWithoutTestAttemptInput, AnswerUncheckedCreateWithoutTestAttemptInput> | AnswerCreateWithoutTestAttemptInput[] | AnswerUncheckedCreateWithoutTestAttemptInput[]
    connectOrCreate?: AnswerCreateOrConnectWithoutTestAttemptInput | AnswerCreateOrConnectWithoutTestAttemptInput[]
    upsert?: AnswerUpsertWithWhereUniqueWithoutTestAttemptInput | AnswerUpsertWithWhereUniqueWithoutTestAttemptInput[]
    createMany?: AnswerCreateManyTestAttemptInputEnvelope
    set?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    disconnect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    delete?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    connect?: AnswerWhereUniqueInput | AnswerWhereUniqueInput[]
    update?: AnswerUpdateWithWhereUniqueWithoutTestAttemptInput | AnswerUpdateWithWhereUniqueWithoutTestAttemptInput[]
    updateMany?: AnswerUpdateManyWithWhereWithoutTestAttemptInput | AnswerUpdateManyWithWhereWithoutTestAttemptInput[]
    deleteMany?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
  }

  export type TestAttemptCreateNestedOneWithoutAnswersInput = {
    create?: XOR<TestAttemptCreateWithoutAnswersInput, TestAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: TestAttemptCreateOrConnectWithoutAnswersInput
    connect?: TestAttemptWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
  }

  export type AlternativeCreateNestedOneWithoutAnswersInput = {
    create?: XOR<AlternativeCreateWithoutAnswersInput, AlternativeUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: AlternativeCreateOrConnectWithoutAnswersInput
    connect?: AlternativeWhereUniqueInput
  }

  export type TestAttemptUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<TestAttemptCreateWithoutAnswersInput, TestAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: TestAttemptCreateOrConnectWithoutAnswersInput
    upsert?: TestAttemptUpsertWithoutAnswersInput
    connect?: TestAttemptWhereUniqueInput
    update?: XOR<XOR<TestAttemptUpdateToOneWithWhereWithoutAnswersInput, TestAttemptUpdateWithoutAnswersInput>, TestAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionUpsertWithoutAnswersInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutAnswersInput, QuestionUpdateWithoutAnswersInput>, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type AlternativeUpdateOneWithoutAnswersNestedInput = {
    create?: XOR<AlternativeCreateWithoutAnswersInput, AlternativeUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: AlternativeCreateOrConnectWithoutAnswersInput
    upsert?: AlternativeUpsertWithoutAnswersInput
    disconnect?: AlternativeWhereInput | boolean
    delete?: AlternativeWhereInput | boolean
    connect?: AlternativeWhereUniqueInput
    update?: XOR<XOR<AlternativeUpdateToOneWithWhereWithoutAnswersInput, AlternativeUpdateWithoutAnswersInput>, AlternativeUncheckedUpdateWithoutAnswersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumChargeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeStatus | EnumChargeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeStatusFilter<$PrismaModel> | $Enums.ChargeStatus
  }

  export type NestedEnumChargeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChargeStatus | EnumChargeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChargeStatus[] | ListEnumChargeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChargeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChargeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChargeStatusFilter<$PrismaModel>
    _max?: NestedEnumChargeStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutOwnerInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectCreateManyOwnerInputEnvelope = {
    data: ProjectCreateManyOwnerInput | ProjectCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutFreelancerInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFreelancerInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFreelancerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFreelancerInput, ProjectUncheckedCreateWithoutFreelancerInput>
  }

  export type ProjectCreateManyFreelancerInputEnvelope = {
    data: ProjectCreateManyFreelancerInput | ProjectCreateManyFreelancerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectSubscriptionCreateWithoutTolinerInput = {
    id?: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutSubscriptionsInput
  }

  export type ProjectSubscriptionUncheckedCreateWithoutTolinerInput = {
    id?: string
    projectId: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionCreateOrConnectWithoutTolinerInput = {
    where: ProjectSubscriptionWhereUniqueInput
    create: XOR<ProjectSubscriptionCreateWithoutTolinerInput, ProjectSubscriptionUncheckedCreateWithoutTolinerInput>
  }

  export type ProjectSubscriptionCreateManyTolinerInputEnvelope = {
    data: ProjectSubscriptionCreateManyTolinerInput | ProjectSubscriptionCreateManyTolinerInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutTolinersInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    projects?: ProjectCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutTolinersInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutTolinersInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutTolinersInput, CategoryUncheckedCreateWithoutTolinersInput>
  }

  export type PortifolioCreateWithoutTolinerInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    skills?: SkillCreateNestedManyWithoutPortifoliosInput
  }

  export type PortifolioUncheckedCreateWithoutTolinerInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    skills?: SkillUncheckedCreateNestedManyWithoutPortifoliosInput
  }

  export type PortifolioCreateOrConnectWithoutTolinerInput = {
    where: PortifolioWhereUniqueInput
    create: XOR<PortifolioCreateWithoutTolinerInput, PortifolioUncheckedCreateWithoutTolinerInput>
  }

  export type PortifolioCreateManyTolinerInputEnvelope = {
    data: PortifolioCreateManyTolinerInput | PortifolioCreateManyTolinerInput[]
    skipDuplicates?: boolean
  }

  export type FreelancerEvaluationCreateWithoutTolinerInput = {
    id?: string
    rate: string
    evaluatorId: string
    comment: string
  }

  export type FreelancerEvaluationUncheckedCreateWithoutTolinerInput = {
    id?: string
    rate: string
    evaluatorId: string
    comment: string
  }

  export type FreelancerEvaluationCreateOrConnectWithoutTolinerInput = {
    where: FreelancerEvaluationWhereUniqueInput
    create: XOR<FreelancerEvaluationCreateWithoutTolinerInput, FreelancerEvaluationUncheckedCreateWithoutTolinerInput>
  }

  export type FreelancerEvaluationCreateManyTolinerInputEnvelope = {
    data: FreelancerEvaluationCreateManyTolinerInput | FreelancerEvaluationCreateManyTolinerInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTolinerInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    conversations?: ConversationCreateNestedManyWithoutMembersInput
    skills?: SkillCreateNestedManyWithoutUsersInput
    TestAttempt?: TestAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTolinerInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    conversations?: ConversationUncheckedCreateNestedManyWithoutMembersInput
    skills?: SkillUncheckedCreateNestedManyWithoutUsersInput
    TestAttempt?: TestAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTolinerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTolinerInput, UserUncheckedCreateWithoutTolinerInput>
  }

  export type ChargeCreateWithoutTolinerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    isVerified?: boolean
    invoice: string
    updatedAt?: Date | string
    referenceNumber?: string | null
    status?: $Enums.ChargeStatus
  }

  export type ChargeUncheckedCreateWithoutTolinerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    isVerified?: boolean
    invoice: string
    updatedAt?: Date | string
    referenceNumber?: string | null
    status?: $Enums.ChargeStatus
  }

  export type ChargeCreateOrConnectWithoutTolinerInput = {
    where: ChargeWhereUniqueInput
    create: XOR<ChargeCreateWithoutTolinerInput, ChargeUncheckedCreateWithoutTolinerInput>
  }

  export type ChargeCreateManyTolinerInputEnvelope = {
    data: ChargeCreateManyTolinerInput | ChargeCreateManyTolinerInput[]
    skipDuplicates?: boolean
  }

  export type BalanceCreateWithoutTolinerInput = {
    id?: string
    ammount: number
    updatedAt?: Date | string
  }

  export type BalanceUncheckedCreateWithoutTolinerInput = {
    id?: string
    ammount: number
    updatedAt?: Date | string
  }

  export type BalanceCreateOrConnectWithoutTolinerInput = {
    where: BalanceWhereUniqueInput
    create: XOR<BalanceCreateWithoutTolinerInput, BalanceUncheckedCreateWithoutTolinerInput>
  }

  export type PaymentCreateWithoutTolinerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    completedAt?: Date | string | null
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    referenceNumber?: string | null
    project: ProjectCreateNestedOneWithoutPaymentInput
    freelancer: TolinerCreateNestedOneWithoutFreelancerPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTolinerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    projectId: string
    completedAt?: Date | string | null
    status?: $Enums.PaymentStatus
    freelancerId: string
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type PaymentCreateOrConnectWithoutTolinerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTolinerInput, PaymentUncheckedCreateWithoutTolinerInput>
  }

  export type PaymentCreateManyTolinerInputEnvelope = {
    data: PaymentCreateManyTolinerInput | PaymentCreateManyTolinerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutFreelancerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    completedAt?: Date | string | null
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    referenceNumber?: string | null
    project: ProjectCreateNestedOneWithoutPaymentInput
    toliner: TolinerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutFreelancerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    projectId: string
    completedAt?: Date | string | null
    tolinerId: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type PaymentCreateOrConnectWithoutFreelancerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutFreelancerInput, PaymentUncheckedCreateWithoutFreelancerInput>
  }

  export type PaymentCreateManyFreelancerInputEnvelope = {
    data: PaymentCreateManyFreelancerInput | PaymentCreateManyFreelancerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
    create: XOR<ProjectCreateWithoutOwnerInput, ProjectUncheckedCreateWithoutOwnerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOwnerInput, ProjectUncheckedUpdateWithoutOwnerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOwnerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    ownerId?: StringFilter<"Project"> | string
    freelancerId?: StringNullableFilter<"Project"> | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    categoryId?: StringNullableFilter<"Project"> | string | null
    subcategoryId?: StringNullableFilter<"Project"> | string | null
    dueDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    concludedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    isAproved?: BoolFilter<"Project"> | boolean
    isActive?: BoolFilter<"Project"> | boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutFreelancerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutFreelancerInput, ProjectUncheckedUpdateWithoutFreelancerInput>
    create: XOR<ProjectCreateWithoutFreelancerInput, ProjectUncheckedCreateWithoutFreelancerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutFreelancerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutFreelancerInput, ProjectUncheckedUpdateWithoutFreelancerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutFreelancerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutFreelancerInput>
  }

  export type ProjectSubscriptionUpsertWithWhereUniqueWithoutTolinerInput = {
    where: ProjectSubscriptionWhereUniqueInput
    update: XOR<ProjectSubscriptionUpdateWithoutTolinerInput, ProjectSubscriptionUncheckedUpdateWithoutTolinerInput>
    create: XOR<ProjectSubscriptionCreateWithoutTolinerInput, ProjectSubscriptionUncheckedCreateWithoutTolinerInput>
  }

  export type ProjectSubscriptionUpdateWithWhereUniqueWithoutTolinerInput = {
    where: ProjectSubscriptionWhereUniqueInput
    data: XOR<ProjectSubscriptionUpdateWithoutTolinerInput, ProjectSubscriptionUncheckedUpdateWithoutTolinerInput>
  }

  export type ProjectSubscriptionUpdateManyWithWhereWithoutTolinerInput = {
    where: ProjectSubscriptionScalarWhereInput
    data: XOR<ProjectSubscriptionUpdateManyMutationInput, ProjectSubscriptionUncheckedUpdateManyWithoutTolinerInput>
  }

  export type ProjectSubscriptionScalarWhereInput = {
    AND?: ProjectSubscriptionScalarWhereInput | ProjectSubscriptionScalarWhereInput[]
    OR?: ProjectSubscriptionScalarWhereInput[]
    NOT?: ProjectSubscriptionScalarWhereInput | ProjectSubscriptionScalarWhereInput[]
    id?: StringFilter<"ProjectSubscription"> | string
    projectId?: StringFilter<"ProjectSubscription"> | string
    tolinerId?: StringFilter<"ProjectSubscription"> | string
    estimatedTime?: StringNullableFilter<"ProjectSubscription"> | string | null
    requiredInformations?: StringNullableFilter<"ProjectSubscription"> | string | null
    similarExperiences?: StringNullableFilter<"ProjectSubscription"> | string | null
    proposal?: StringFilter<"ProjectSubscription"> | string
    quotation?: FloatNullableFilter<"ProjectSubscription"> | number | null
    createdAt?: DateTimeFilter<"ProjectSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectSubscription"> | Date | string
    invitation?: JsonNullableFilter<"ProjectSubscription">
  }

  export type CategoryUpsertWithWhereUniqueWithoutTolinersInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutTolinersInput, CategoryUncheckedUpdateWithoutTolinersInput>
    create: XOR<CategoryCreateWithoutTolinersInput, CategoryUncheckedCreateWithoutTolinersInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutTolinersInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutTolinersInput, CategoryUncheckedUpdateWithoutTolinersInput>
  }

  export type CategoryUpdateManyWithWhereWithoutTolinersInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutTolinersInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    slug?: StringFilter<"Category"> | string
  }

  export type PortifolioUpsertWithWhereUniqueWithoutTolinerInput = {
    where: PortifolioWhereUniqueInput
    update: XOR<PortifolioUpdateWithoutTolinerInput, PortifolioUncheckedUpdateWithoutTolinerInput>
    create: XOR<PortifolioCreateWithoutTolinerInput, PortifolioUncheckedCreateWithoutTolinerInput>
  }

  export type PortifolioUpdateWithWhereUniqueWithoutTolinerInput = {
    where: PortifolioWhereUniqueInput
    data: XOR<PortifolioUpdateWithoutTolinerInput, PortifolioUncheckedUpdateWithoutTolinerInput>
  }

  export type PortifolioUpdateManyWithWhereWithoutTolinerInput = {
    where: PortifolioScalarWhereInput
    data: XOR<PortifolioUpdateManyMutationInput, PortifolioUncheckedUpdateManyWithoutTolinerInput>
  }

  export type PortifolioScalarWhereInput = {
    AND?: PortifolioScalarWhereInput | PortifolioScalarWhereInput[]
    OR?: PortifolioScalarWhereInput[]
    NOT?: PortifolioScalarWhereInput | PortifolioScalarWhereInput[]
    id?: StringFilter<"Portifolio"> | string
    title?: StringFilter<"Portifolio"> | string
    description?: StringFilter<"Portifolio"> | string
    cover?: StringFilter<"Portifolio"> | string
    completedAt?: StringNullableFilter<"Portifolio"> | string | null
    assets?: JsonFilter<"Portifolio">
    tolinerId?: StringNullableFilter<"Portifolio"> | string | null
  }

  export type FreelancerEvaluationUpsertWithWhereUniqueWithoutTolinerInput = {
    where: FreelancerEvaluationWhereUniqueInput
    update: XOR<FreelancerEvaluationUpdateWithoutTolinerInput, FreelancerEvaluationUncheckedUpdateWithoutTolinerInput>
    create: XOR<FreelancerEvaluationCreateWithoutTolinerInput, FreelancerEvaluationUncheckedCreateWithoutTolinerInput>
  }

  export type FreelancerEvaluationUpdateWithWhereUniqueWithoutTolinerInput = {
    where: FreelancerEvaluationWhereUniqueInput
    data: XOR<FreelancerEvaluationUpdateWithoutTolinerInput, FreelancerEvaluationUncheckedUpdateWithoutTolinerInput>
  }

  export type FreelancerEvaluationUpdateManyWithWhereWithoutTolinerInput = {
    where: FreelancerEvaluationScalarWhereInput
    data: XOR<FreelancerEvaluationUpdateManyMutationInput, FreelancerEvaluationUncheckedUpdateManyWithoutTolinerInput>
  }

  export type FreelancerEvaluationScalarWhereInput = {
    AND?: FreelancerEvaluationScalarWhereInput | FreelancerEvaluationScalarWhereInput[]
    OR?: FreelancerEvaluationScalarWhereInput[]
    NOT?: FreelancerEvaluationScalarWhereInput | FreelancerEvaluationScalarWhereInput[]
    id?: StringFilter<"FreelancerEvaluation"> | string
    rate?: StringFilter<"FreelancerEvaluation"> | string
    tolinerId?: StringFilter<"FreelancerEvaluation"> | string
    evaluatorId?: StringFilter<"FreelancerEvaluation"> | string
    comment?: StringFilter<"FreelancerEvaluation"> | string
  }

  export type UserUpsertWithoutTolinerInput = {
    update: XOR<UserUpdateWithoutTolinerInput, UserUncheckedUpdateWithoutTolinerInput>
    create: XOR<UserCreateWithoutTolinerInput, UserUncheckedCreateWithoutTolinerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTolinerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTolinerInput, UserUncheckedUpdateWithoutTolinerInput>
  }

  export type UserUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUpdateManyWithoutMembersNestedInput
    skills?: SkillUpdateManyWithoutUsersNestedInput
    TestAttempt?: TestAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUncheckedUpdateManyWithoutMembersNestedInput
    skills?: SkillUncheckedUpdateManyWithoutUsersNestedInput
    TestAttempt?: TestAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChargeUpsertWithWhereUniqueWithoutTolinerInput = {
    where: ChargeWhereUniqueInput
    update: XOR<ChargeUpdateWithoutTolinerInput, ChargeUncheckedUpdateWithoutTolinerInput>
    create: XOR<ChargeCreateWithoutTolinerInput, ChargeUncheckedCreateWithoutTolinerInput>
  }

  export type ChargeUpdateWithWhereUniqueWithoutTolinerInput = {
    where: ChargeWhereUniqueInput
    data: XOR<ChargeUpdateWithoutTolinerInput, ChargeUncheckedUpdateWithoutTolinerInput>
  }

  export type ChargeUpdateManyWithWhereWithoutTolinerInput = {
    where: ChargeScalarWhereInput
    data: XOR<ChargeUpdateManyMutationInput, ChargeUncheckedUpdateManyWithoutTolinerInput>
  }

  export type ChargeScalarWhereInput = {
    AND?: ChargeScalarWhereInput | ChargeScalarWhereInput[]
    OR?: ChargeScalarWhereInput[]
    NOT?: ChargeScalarWhereInput | ChargeScalarWhereInput[]
    id?: StringFilter<"Charge"> | string
    ammount?: FloatFilter<"Charge"> | number
    createdAt?: DateTimeFilter<"Charge"> | Date | string
    isVerified?: BoolFilter<"Charge"> | boolean
    invoice?: StringFilter<"Charge"> | string
    updatedAt?: DateTimeFilter<"Charge"> | Date | string
    referenceNumber?: StringNullableFilter<"Charge"> | string | null
    status?: EnumChargeStatusFilter<"Charge"> | $Enums.ChargeStatus
    tolinerId?: StringFilter<"Charge"> | string
  }

  export type BalanceUpsertWithoutTolinerInput = {
    update: XOR<BalanceUpdateWithoutTolinerInput, BalanceUncheckedUpdateWithoutTolinerInput>
    create: XOR<BalanceCreateWithoutTolinerInput, BalanceUncheckedCreateWithoutTolinerInput>
    where?: BalanceWhereInput
  }

  export type BalanceUpdateToOneWithWhereWithoutTolinerInput = {
    where?: BalanceWhereInput
    data: XOR<BalanceUpdateWithoutTolinerInput, BalanceUncheckedUpdateWithoutTolinerInput>
  }

  export type BalanceUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BalanceUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTolinerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTolinerInput, PaymentUncheckedUpdateWithoutTolinerInput>
    create: XOR<PaymentCreateWithoutTolinerInput, PaymentUncheckedCreateWithoutTolinerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTolinerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTolinerInput, PaymentUncheckedUpdateWithoutTolinerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTolinerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTolinerInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    ammount?: FloatFilter<"Payment"> | number
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    clientInvoice?: StringNullableFilter<"Payment"> | string | null
    systemInvoice?: StringNullableFilter<"Payment"> | string | null
    isVerified?: BoolFilter<"Payment"> | boolean
    projectId?: StringFilter<"Payment"> | string
    completedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    tolinerId?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    freelancerId?: StringFilter<"Payment"> | string
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutFreelancerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutFreelancerInput, PaymentUncheckedUpdateWithoutFreelancerInput>
    create: XOR<PaymentCreateWithoutFreelancerInput, PaymentUncheckedCreateWithoutFreelancerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutFreelancerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutFreelancerInput, PaymentUncheckedUpdateWithoutFreelancerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutFreelancerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutFreelancerInput>
  }

  export type ConversationCreateWithoutMembersInput = {
    id?: string
    messages?: MessageCreateNestedManyWithoutConversationInput
    project?: ProjectCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMembersInput = {
    id?: string
    projectId?: string | null
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMembersInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
  }

  export type TolinerCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutUserInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutUserInput, TolinerUncheckedCreateWithoutUserInput>
  }

  export type SkillCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    category?: CategoryCreateNestedOneWithoutSkillsInput
    portifolios?: PortifolioCreateNestedManyWithoutSkillsInput
    projects?: ProjectCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    subcategoryId?: string | null
    portifolios?: PortifolioUncheckedCreateNestedManyWithoutSkillsInput
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestUncheckedCreateNestedOneWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutUsersInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutUsersInput, SkillUncheckedCreateWithoutUsersInput>
  }

  export type TestAttemptCreateWithoutUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTest: CertificationTestCreateNestedOneWithoutAttemptsInput
    answers?: AnswerCreateNestedManyWithoutTestAttemptInput
  }

  export type TestAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    answers?: AnswerUncheckedCreateNestedManyWithoutTestAttemptInput
  }

  export type TestAttemptCreateOrConnectWithoutUserInput = {
    where: TestAttemptWhereUniqueInput
    create: XOR<TestAttemptCreateWithoutUserInput, TestAttemptUncheckedCreateWithoutUserInput>
  }

  export type TestAttemptCreateManyUserInputEnvelope = {
    data: TestAttemptCreateManyUserInput | TestAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithWhereUniqueWithoutMembersInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutMembersInput, ConversationUncheckedUpdateWithoutMembersInput>
    create: XOR<ConversationCreateWithoutMembersInput, ConversationUncheckedCreateWithoutMembersInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutMembersInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutMembersInput, ConversationUncheckedUpdateWithoutMembersInput>
  }

  export type ConversationUpdateManyWithWhereWithoutMembersInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutMembersInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    projectId?: StringNullableFilter<"Conversation"> | string | null
  }

  export type TolinerUpsertWithoutUserInput = {
    update: XOR<TolinerUpdateWithoutUserInput, TolinerUncheckedUpdateWithoutUserInput>
    create: XOR<TolinerCreateWithoutUserInput, TolinerUncheckedCreateWithoutUserInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutUserInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutUserInput, TolinerUncheckedUpdateWithoutUserInput>
  }

  export type TolinerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type SkillUpsertWithWhereUniqueWithoutUsersInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutUsersInput, SkillUncheckedUpdateWithoutUsersInput>
    create: XOR<SkillCreateWithoutUsersInput, SkillUncheckedCreateWithoutUsersInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutUsersInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutUsersInput, SkillUncheckedUpdateWithoutUsersInput>
  }

  export type SkillUpdateManyWithWhereWithoutUsersInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutUsersInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    slug?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    categoryId?: StringNullableFilter<"Skill"> | string | null
    subcategoryId?: StringNullableFilter<"Skill"> | string | null
  }

  export type TestAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: TestAttemptWhereUniqueInput
    update: XOR<TestAttemptUpdateWithoutUserInput, TestAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<TestAttemptCreateWithoutUserInput, TestAttemptUncheckedCreateWithoutUserInput>
  }

  export type TestAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: TestAttemptWhereUniqueInput
    data: XOR<TestAttemptUpdateWithoutUserInput, TestAttemptUncheckedUpdateWithoutUserInput>
  }

  export type TestAttemptUpdateManyWithWhereWithoutUserInput = {
    where: TestAttemptScalarWhereInput
    data: XOR<TestAttemptUpdateManyMutationInput, TestAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type TestAttemptScalarWhereInput = {
    AND?: TestAttemptScalarWhereInput | TestAttemptScalarWhereInput[]
    OR?: TestAttemptScalarWhereInput[]
    NOT?: TestAttemptScalarWhereInput | TestAttemptScalarWhereInput[]
    id?: StringFilter<"TestAttempt"> | string
    startTime?: DateTimeFilter<"TestAttempt"> | Date | string
    endTime?: DateTimeNullableFilter<"TestAttempt"> | Date | string | null
    score?: FloatNullableFilter<"TestAttempt"> | number | null
    passed?: BoolNullableFilter<"TestAttempt"> | boolean | null
    completionTime?: IntNullableFilter<"TestAttempt"> | number | null
    createdAt?: DateTimeFilter<"TestAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"TestAttempt"> | Date | string
    certificationTestId?: StringFilter<"TestAttempt"> | string
    userId?: StringFilter<"TestAttempt"> | string
  }

  export type TolinerCreateWithoutProjectsOwnedInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutProjectsOwnedInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutProjectsOwnedInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutProjectsOwnedInput, TolinerUncheckedCreateWithoutProjectsOwnedInput>
  }

  export type TolinerCreateWithoutProjectsFreelancedInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutProjectsFreelancedInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutProjectsFreelancedInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutProjectsFreelancedInput, TolinerUncheckedCreateWithoutProjectsFreelancedInput>
  }

  export type ProjectSubscriptionCreateWithoutProjectInput = {
    id?: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
    toliner: TolinerCreateNestedOneWithoutSubscriptionsInput
  }

  export type ProjectSubscriptionUncheckedCreateWithoutProjectInput = {
    id?: string
    tolinerId: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionCreateOrConnectWithoutProjectInput = {
    where: ProjectSubscriptionWhereUniqueInput
    create: XOR<ProjectSubscriptionCreateWithoutProjectInput, ProjectSubscriptionUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSubscriptionCreateManyProjectInputEnvelope = {
    data: ProjectSubscriptionCreateManyProjectInput | ProjectSubscriptionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutProjectsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillCreateNestedManyWithoutCategoryInput
    toliners?: TolinerCreateNestedManyWithoutSpecializationInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillUncheckedCreateNestedManyWithoutCategoryInput
    toliners?: TolinerUncheckedCreateNestedManyWithoutSpecializationInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProjectsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput>
  }

  export type SkillCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    category?: CategoryCreateNestedOneWithoutSkillsInput
    users?: UserCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    subcategoryId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioUncheckedCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestUncheckedCreateNestedOneWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
  }

  export type QuotationCreateWithoutProjectInput = {
    id?: string
    ammount: number
    description?: string | null
    createdAt?: Date | string
  }

  export type QuotationUncheckedCreateWithoutProjectInput = {
    id?: string
    ammount: number
    description?: string | null
    createdAt?: Date | string
  }

  export type QuotationCreateOrConnectWithoutProjectInput = {
    where: QuotationWhereUniqueInput
    create: XOR<QuotationCreateWithoutProjectInput, QuotationUncheckedCreateWithoutProjectInput>
  }

  export type ConversationCreateWithoutProjectInput = {
    id?: string
    members?: UserCreateNestedManyWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutProjectInput = {
    id?: string
    members?: UserUncheckedCreateNestedManyWithoutConversationsInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutProjectInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutProjectInput, ConversationUncheckedCreateWithoutProjectInput>
  }

  export type ConversationCreateManyProjectInputEnvelope = {
    data: ConversationCreateManyProjectInput | ConversationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutProjectInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    completedAt?: Date | string | null
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    referenceNumber?: string | null
    toliner: TolinerCreateNestedOneWithoutPaymentsInput
    freelancer: TolinerCreateNestedOneWithoutFreelancerPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutProjectInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    completedAt?: Date | string | null
    tolinerId: string
    status?: $Enums.PaymentStatus
    freelancerId: string
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type PaymentCreateOrConnectWithoutProjectInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
  }

  export type TolinerUpsertWithoutProjectsOwnedInput = {
    update: XOR<TolinerUpdateWithoutProjectsOwnedInput, TolinerUncheckedUpdateWithoutProjectsOwnedInput>
    create: XOR<TolinerCreateWithoutProjectsOwnedInput, TolinerUncheckedCreateWithoutProjectsOwnedInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutProjectsOwnedInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutProjectsOwnedInput, TolinerUncheckedUpdateWithoutProjectsOwnedInput>
  }

  export type TolinerUpdateWithoutProjectsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutProjectsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUpsertWithoutProjectsFreelancedInput = {
    update: XOR<TolinerUpdateWithoutProjectsFreelancedInput, TolinerUncheckedUpdateWithoutProjectsFreelancedInput>
    create: XOR<TolinerCreateWithoutProjectsFreelancedInput, TolinerUncheckedCreateWithoutProjectsFreelancedInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutProjectsFreelancedInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutProjectsFreelancedInput, TolinerUncheckedUpdateWithoutProjectsFreelancedInput>
  }

  export type TolinerUpdateWithoutProjectsFreelancedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutProjectsFreelancedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type ProjectSubscriptionUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectSubscriptionWhereUniqueInput
    update: XOR<ProjectSubscriptionUpdateWithoutProjectInput, ProjectSubscriptionUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectSubscriptionCreateWithoutProjectInput, ProjectSubscriptionUncheckedCreateWithoutProjectInput>
  }

  export type ProjectSubscriptionUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectSubscriptionWhereUniqueInput
    data: XOR<ProjectSubscriptionUpdateWithoutProjectInput, ProjectSubscriptionUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectSubscriptionUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectSubscriptionScalarWhereInput
    data: XOR<ProjectSubscriptionUpdateManyMutationInput, ProjectSubscriptionUncheckedUpdateManyWithoutProjectInput>
  }

  export type CategoryUpsertWithoutProjectsInput = {
    update: XOR<CategoryUpdateWithoutProjectsInput, CategoryUncheckedUpdateWithoutProjectsInput>
    create: XOR<CategoryCreateWithoutProjectsInput, CategoryUncheckedCreateWithoutProjectsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProjectsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProjectsInput, CategoryUncheckedUpdateWithoutProjectsInput>
  }

  export type CategoryUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUpdateManyWithoutCategoryNestedInput
    toliners?: TolinerUpdateManyWithoutSpecializationNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUncheckedUpdateManyWithoutCategoryNestedInput
    toliners?: TolinerUncheckedUpdateManyWithoutSpecializationNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SkillUpsertWithWhereUniqueWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutProjectsInput, SkillUncheckedUpdateWithoutProjectsInput>
    create: XOR<SkillCreateWithoutProjectsInput, SkillUncheckedCreateWithoutProjectsInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutProjectsInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutProjectsInput, SkillUncheckedUpdateWithoutProjectsInput>
  }

  export type SkillUpdateManyWithWhereWithoutProjectsInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutProjectsInput>
  }

  export type QuotationUpsertWithoutProjectInput = {
    update: XOR<QuotationUpdateWithoutProjectInput, QuotationUncheckedUpdateWithoutProjectInput>
    create: XOR<QuotationCreateWithoutProjectInput, QuotationUncheckedCreateWithoutProjectInput>
    where?: QuotationWhereInput
  }

  export type QuotationUpdateToOneWithWhereWithoutProjectInput = {
    where?: QuotationWhereInput
    data: XOR<QuotationUpdateWithoutProjectInput, QuotationUncheckedUpdateWithoutProjectInput>
  }

  export type QuotationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutProjectInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutProjectInput, ConversationUncheckedUpdateWithoutProjectInput>
    create: XOR<ConversationCreateWithoutProjectInput, ConversationUncheckedCreateWithoutProjectInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutProjectInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutProjectInput, ConversationUncheckedUpdateWithoutProjectInput>
  }

  export type ConversationUpdateManyWithWhereWithoutProjectInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutProjectInput>
  }

  export type PaymentUpsertWithoutProjectInput = {
    update: XOR<PaymentUpdateWithoutProjectInput, PaymentUncheckedUpdateWithoutProjectInput>
    create: XOR<PaymentCreateWithoutProjectInput, PaymentUncheckedCreateWithoutProjectInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutProjectInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutProjectInput, PaymentUncheckedUpdateWithoutProjectInput>
  }

  export type PaymentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    toliner?: TolinerUpdateOneRequiredWithoutPaymentsNestedInput
    freelancer?: TolinerUpdateOneRequiredWithoutFreelancerPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    freelancerId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TolinerCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutSubscriptionsInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutSubscriptionsInput, TolinerUncheckedCreateWithoutSubscriptionsInput>
  }

  export type ProjectCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSubscriptionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSubscriptionsInput, ProjectUncheckedCreateWithoutSubscriptionsInput>
  }

  export type TolinerUpsertWithoutSubscriptionsInput = {
    update: XOR<TolinerUpdateWithoutSubscriptionsInput, TolinerUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<TolinerCreateWithoutSubscriptionsInput, TolinerUncheckedCreateWithoutSubscriptionsInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutSubscriptionsInput, TolinerUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type TolinerUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type ProjectUpsertWithoutSubscriptionsInput = {
    update: XOR<ProjectUpdateWithoutSubscriptionsInput, ProjectUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<ProjectCreateWithoutSubscriptionsInput, ProjectUncheckedCreateWithoutSubscriptionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSubscriptionsInput, ProjectUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type ProjectUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type SkillCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    users?: UserCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioCreateNestedManyWithoutSkillsInput
    projects?: ProjectCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioUncheckedCreateNestedManyWithoutSkillsInput
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestUncheckedCreateNestedOneWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutCategoryInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCategoryInput, SkillUncheckedCreateWithoutCategoryInput>
  }

  export type SkillCreateManyCategoryInputEnvelope = {
    data: SkillCreateManyCategoryInput | SkillCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TolinerCreateWithoutSpecializationInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutSpecializationInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutSpecializationInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutSpecializationInput, TolinerUncheckedCreateWithoutSpecializationInput>
  }

  export type SubcategoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
  }

  export type SubcategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
  }

  export type SubcategoryCreateOrConnectWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryCreateManyCategoryInputEnvelope = {
    data: SubcategoryCreateManyCategoryInput | SubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCategoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCategoryInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCategoryInput, ProjectUncheckedCreateWithoutCategoryInput>
  }

  export type ProjectCreateManyCategoryInputEnvelope = {
    data: ProjectCreateManyCategoryInput | ProjectCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SkillUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutCategoryInput, SkillUncheckedUpdateWithoutCategoryInput>
    create: XOR<SkillCreateWithoutCategoryInput, SkillUncheckedCreateWithoutCategoryInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutCategoryInput, SkillUncheckedUpdateWithoutCategoryInput>
  }

  export type SkillUpdateManyWithWhereWithoutCategoryInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutCategoryInput>
  }

  export type TolinerUpsertWithWhereUniqueWithoutSpecializationInput = {
    where: TolinerWhereUniqueInput
    update: XOR<TolinerUpdateWithoutSpecializationInput, TolinerUncheckedUpdateWithoutSpecializationInput>
    create: XOR<TolinerCreateWithoutSpecializationInput, TolinerUncheckedCreateWithoutSpecializationInput>
  }

  export type TolinerUpdateWithWhereUniqueWithoutSpecializationInput = {
    where: TolinerWhereUniqueInput
    data: XOR<TolinerUpdateWithoutSpecializationInput, TolinerUncheckedUpdateWithoutSpecializationInput>
  }

  export type TolinerUpdateManyWithWhereWithoutSpecializationInput = {
    where: TolinerScalarWhereInput
    data: XOR<TolinerUpdateManyMutationInput, TolinerUncheckedUpdateManyWithoutSpecializationInput>
  }

  export type TolinerScalarWhereInput = {
    AND?: TolinerScalarWhereInput | TolinerScalarWhereInput[]
    OR?: TolinerScalarWhereInput[]
    NOT?: TolinerScalarWhereInput | TolinerScalarWhereInput[]
    id?: StringFilter<"Toliner"> | string
    name?: StringFilter<"Toliner"> | string
    email?: StringFilter<"Toliner"> | string
    jobDescription?: StringNullableFilter<"Toliner"> | string | null
    isVerified?: BoolFilter<"Toliner"> | boolean
    createdAt?: DateTimeFilter<"Toliner"> | Date | string
    bankAccount?: JsonNullableFilter<"Toliner">
    identification?: JsonNullableFilter<"Toliner">
    isSuspended?: BoolFilter<"Toliner"> | boolean
    isActive?: BoolFilter<"Toliner"> | boolean
    hasCompletedProfile?: BoolFilter<"Toliner"> | boolean
    hasAprovedProfile?: BoolFilter<"Toliner"> | boolean
    gainPerOurs?: FloatNullableFilter<"Toliner"> | number | null
    nacionality?: StringNullableFilter<"Toliner"> | string | null
  }

  export type SubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    update: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    data: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubcategoryScalarWhereInput
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryScalarWhereInput = {
    AND?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    OR?: SubcategoryScalarWhereInput[]
    NOT?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    name?: StringFilter<"Subcategory"> | string
    description?: StringNullableFilter<"Subcategory"> | string | null
    slug?: StringFilter<"Subcategory"> | string
    categoryId?: StringNullableFilter<"Subcategory"> | string | null
  }

  export type ProjectUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCategoryInput, ProjectUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProjectCreateWithoutCategoryInput, ProjectUncheckedCreateWithoutCategoryInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCategoryInput, ProjectUncheckedUpdateWithoutCategoryInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCategoryInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryCreateWithoutSubcategoriesInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillCreateNestedManyWithoutCategoryInput
    toliners?: TolinerCreateNestedManyWithoutSpecializationInput
    projects?: ProjectCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    skills?: SkillUncheckedCreateNestedManyWithoutCategoryInput
    toliners?: TolinerUncheckedCreateNestedManyWithoutSpecializationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type CategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CategoryUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUpdateManyWithoutCategoryNestedInput
    toliners?: TolinerUpdateManyWithoutSpecializationNestedInput
    projects?: ProjectUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUncheckedUpdateManyWithoutCategoryNestedInput
    toliners?: TolinerUncheckedUpdateManyWithoutSpecializationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TolinerCreateWithoutFreelancerEvaluationInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutFreelancerEvaluationInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutFreelancerEvaluationInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutFreelancerEvaluationInput, TolinerUncheckedCreateWithoutFreelancerEvaluationInput>
  }

  export type TolinerUpsertWithoutFreelancerEvaluationInput = {
    update: XOR<TolinerUpdateWithoutFreelancerEvaluationInput, TolinerUncheckedUpdateWithoutFreelancerEvaluationInput>
    create: XOR<TolinerCreateWithoutFreelancerEvaluationInput, TolinerUncheckedCreateWithoutFreelancerEvaluationInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutFreelancerEvaluationInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutFreelancerEvaluationInput, TolinerUncheckedUpdateWithoutFreelancerEvaluationInput>
  }

  export type TolinerUpdateWithoutFreelancerEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutFreelancerEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type ProjectCreateWithoutQuotationInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutQuotationInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutQuotationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutQuotationInput, ProjectUncheckedCreateWithoutQuotationInput>
  }

  export type ProjectUpsertWithoutQuotationInput = {
    update: XOR<ProjectUpdateWithoutQuotationInput, ProjectUncheckedUpdateWithoutQuotationInput>
    create: XOR<ProjectCreateWithoutQuotationInput, ProjectUncheckedCreateWithoutQuotationInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutQuotationInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutQuotationInput, ProjectUncheckedUpdateWithoutQuotationInput>
  }

  export type ProjectUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutQuotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    toliner: TolinerCreateNestedOneWithoutUserInput
    skills?: SkillCreateNestedManyWithoutUsersInput
    TestAttempt?: TestAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    tolinerId: string
    skills?: SkillUncheckedCreateNestedManyWithoutUsersInput
    TestAttempt?: TestAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    saw?: boolean
    hasFile?: boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    saw?: boolean
    hasFile?: boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutConversationsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutConversationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutConversationsInput, ProjectUncheckedCreateWithoutConversationsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutConversationsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutConversationsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateManyWithWhereWithoutConversationsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutConversationsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    type?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    tag?: StringFilter<"User"> | string
    clientBio?: StringNullableFilter<"User"> | string | null
    freelancerBio?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    tolinerId?: StringFilter<"User"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversationId?: StringFilter<"Message"> | string
    saw?: BoolFilter<"Message"> | boolean
    hasFile?: BoolFilter<"Message"> | boolean
    fileInfo?: JsonNullableFilter<"Message">
  }

  export type ProjectUpsertWithoutConversationsInput = {
    update: XOR<ProjectUpdateWithoutConversationsInput, ProjectUncheckedUpdateWithoutConversationsInput>
    create: XOR<ProjectCreateWithoutConversationsInput, ProjectUncheckedCreateWithoutConversationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutConversationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutConversationsInput, ProjectUncheckedUpdateWithoutConversationsInput>
  }

  export type ProjectUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    members?: UserCreateNestedManyWithoutConversationsInput
    project?: ProjectCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    projectId?: string | null
    members?: UserUncheckedCreateNestedManyWithoutConversationsInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: UserUpdateManyWithoutConversationsNestedInput
    project?: ProjectUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    members?: UserUncheckedUpdateManyWithoutConversationsNestedInput
  }

  export type SkillCreateWithoutPortifoliosInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    category?: CategoryCreateNestedOneWithoutSkillsInput
    users?: UserCreateNestedManyWithoutSkillsInput
    projects?: ProjectCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestCreateNestedOneWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutPortifoliosInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    subcategoryId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutSkillsInput
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
    certificationTest?: CertificationTestUncheckedCreateNestedOneWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutPortifoliosInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutPortifoliosInput, SkillUncheckedCreateWithoutPortifoliosInput>
  }

  export type TolinerCreateWithoutPortifolioInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutPortifolioInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutPortifolioInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutPortifolioInput, TolinerUncheckedCreateWithoutPortifolioInput>
  }

  export type SkillUpsertWithWhereUniqueWithoutPortifoliosInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutPortifoliosInput, SkillUncheckedUpdateWithoutPortifoliosInput>
    create: XOR<SkillCreateWithoutPortifoliosInput, SkillUncheckedCreateWithoutPortifoliosInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutPortifoliosInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutPortifoliosInput, SkillUncheckedUpdateWithoutPortifoliosInput>
  }

  export type SkillUpdateManyWithWhereWithoutPortifoliosInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutPortifoliosInput>
  }

  export type TolinerUpsertWithoutPortifolioInput = {
    update: XOR<TolinerUpdateWithoutPortifolioInput, TolinerUncheckedUpdateWithoutPortifolioInput>
    create: XOR<TolinerCreateWithoutPortifolioInput, TolinerUncheckedCreateWithoutPortifolioInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutPortifolioInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutPortifolioInput, TolinerUncheckedUpdateWithoutPortifolioInput>
  }

  export type TolinerUpdateWithoutPortifolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutPortifolioInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type ProjectCreateWithoutPaymentInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    skills?: SkillCreateNestedManyWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPaymentInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    skills?: SkillUncheckedCreateNestedManyWithoutProjectsInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPaymentInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPaymentInput, ProjectUncheckedCreateWithoutPaymentInput>
  }

  export type TolinerCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutPaymentsInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutPaymentsInput, TolinerUncheckedCreateWithoutPaymentsInput>
  }

  export type TolinerCreateWithoutFreelancerPaymentsInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
  }

  export type TolinerUncheckedCreateWithoutFreelancerPaymentsInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
  }

  export type TolinerCreateOrConnectWithoutFreelancerPaymentsInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutFreelancerPaymentsInput, TolinerUncheckedCreateWithoutFreelancerPaymentsInput>
  }

  export type ProjectUpsertWithoutPaymentInput = {
    update: XOR<ProjectUpdateWithoutPaymentInput, ProjectUncheckedUpdateWithoutPaymentInput>
    create: XOR<ProjectCreateWithoutPaymentInput, ProjectUncheckedCreateWithoutPaymentInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPaymentInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPaymentInput, ProjectUncheckedUpdateWithoutPaymentInput>
  }

  export type ProjectUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TolinerUpsertWithoutPaymentsInput = {
    update: XOR<TolinerUpdateWithoutPaymentsInput, TolinerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TolinerCreateWithoutPaymentsInput, TolinerUncheckedCreateWithoutPaymentsInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutPaymentsInput, TolinerUncheckedUpdateWithoutPaymentsInput>
  }

  export type TolinerUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUpsertWithoutFreelancerPaymentsInput = {
    update: XOR<TolinerUpdateWithoutFreelancerPaymentsInput, TolinerUncheckedUpdateWithoutFreelancerPaymentsInput>
    create: XOR<TolinerCreateWithoutFreelancerPaymentsInput, TolinerUncheckedCreateWithoutFreelancerPaymentsInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutFreelancerPaymentsInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutFreelancerPaymentsInput, TolinerUncheckedUpdateWithoutFreelancerPaymentsInput>
  }

  export type TolinerUpdateWithoutFreelancerPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutFreelancerPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
  }

  export type TolinerCreateWithoutChargesInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    balance?: BalanceCreateNestedOneWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutChargesInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    balance?: BalanceUncheckedCreateNestedOneWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutChargesInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutChargesInput, TolinerUncheckedCreateWithoutChargesInput>
  }

  export type TolinerUpsertWithoutChargesInput = {
    update: XOR<TolinerUpdateWithoutChargesInput, TolinerUncheckedUpdateWithoutChargesInput>
    create: XOR<TolinerCreateWithoutChargesInput, TolinerUncheckedCreateWithoutChargesInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutChargesInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutChargesInput, TolinerUncheckedUpdateWithoutChargesInput>
  }

  export type TolinerUpdateWithoutChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutChargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerCreateWithoutBalanceInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutTolinerInput
    specialization?: CategoryCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationCreateNestedManyWithoutTolinerInput
    user?: UserCreateNestedOneWithoutTolinerInput
    charges?: ChargeCreateNestedManyWithoutTolinerInput
    payments?: PaymentCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerUncheckedCreateWithoutBalanceInput = {
    id?: string
    name: string
    email: string
    jobDescription?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: boolean
    isActive?: boolean
    hasCompletedProfile?: boolean
    hasAprovedProfile?: boolean
    gainPerOurs?: number | null
    nacionality?: string | null
    projectsOwned?: ProjectUncheckedCreateNestedManyWithoutOwnerInput
    projectsFreelanced?: ProjectUncheckedCreateNestedManyWithoutFreelancerInput
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutTolinerInput
    specialization?: CategoryUncheckedCreateNestedManyWithoutTolinersInput
    portifolio?: PortifolioUncheckedCreateNestedManyWithoutTolinerInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedCreateNestedManyWithoutTolinerInput
    user?: UserUncheckedCreateNestedOneWithoutTolinerInput
    charges?: ChargeUncheckedCreateNestedManyWithoutTolinerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTolinerInput
    freelancerPayments?: PaymentUncheckedCreateNestedManyWithoutFreelancerInput
  }

  export type TolinerCreateOrConnectWithoutBalanceInput = {
    where: TolinerWhereUniqueInput
    create: XOR<TolinerCreateWithoutBalanceInput, TolinerUncheckedCreateWithoutBalanceInput>
  }

  export type TolinerUpsertWithoutBalanceInput = {
    update: XOR<TolinerUpdateWithoutBalanceInput, TolinerUncheckedUpdateWithoutBalanceInput>
    create: XOR<TolinerCreateWithoutBalanceInput, TolinerUncheckedCreateWithoutBalanceInput>
    where?: TolinerWhereInput
  }

  export type TolinerUpdateToOneWithWhereWithoutBalanceInput = {
    where?: TolinerWhereInput
    data: XOR<TolinerUpdateWithoutBalanceInput, TolinerUncheckedUpdateWithoutBalanceInput>
  }

  export type TolinerUpdateWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    specialization?: CategoryUncheckedUpdateManyWithoutTolinersNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type CategoryCreateWithoutSkillsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    toliners?: TolinerCreateNestedManyWithoutSpecializationInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
    projects?: ProjectCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
    toliners?: TolinerUncheckedCreateNestedManyWithoutSpecializationInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
    projects?: ProjectUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSkillsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSkillsInput, CategoryUncheckedCreateWithoutSkillsInput>
  }

  export type UserCreateWithoutSkillsInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    conversations?: ConversationCreateNestedManyWithoutMembersInput
    toliner: TolinerCreateNestedOneWithoutUserInput
    TestAttempt?: TestAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSkillsInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    tolinerId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutMembersInput
    TestAttempt?: TestAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSkillsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
  }

  export type PortifolioCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    toliner?: TolinerCreateNestedOneWithoutPortifolioInput
  }

  export type PortifolioUncheckedCreateWithoutSkillsInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
    tolinerId?: string | null
  }

  export type PortifolioCreateOrConnectWithoutSkillsInput = {
    where: PortifolioWhereUniqueInput
    create: XOR<PortifolioCreateWithoutSkillsInput, PortifolioUncheckedCreateWithoutSkillsInput>
  }

  export type ProjectCreateWithoutSkillsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    owner: TolinerCreateNestedOneWithoutProjectsOwnedInput
    freelancer?: TolinerCreateNestedOneWithoutProjectsFreelancedInput
    subscriptions?: ProjectSubscriptionCreateNestedManyWithoutProjectInput
    category?: CategoryCreateNestedOneWithoutProjectsInput
    quotation?: QuotationCreateNestedOneWithoutProjectInput
    conversations?: ConversationCreateNestedManyWithoutProjectInput
    payment?: PaymentCreateNestedOneWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
    subscriptions?: ProjectSubscriptionUncheckedCreateNestedManyWithoutProjectInput
    quotation?: QuotationUncheckedCreateNestedOneWithoutProjectInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutProjectInput
    payment?: PaymentUncheckedCreateNestedOneWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
  }

  export type CertificationTestCreateWithoutSkillInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutCertificationTestInput
    attempts?: TestAttemptCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestUncheckedCreateWithoutSkillInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutCertificationTestInput
    attempts?: TestAttemptUncheckedCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestCreateOrConnectWithoutSkillInput = {
    where: CertificationTestWhereUniqueInput
    create: XOR<CertificationTestCreateWithoutSkillInput, CertificationTestUncheckedCreateWithoutSkillInput>
  }

  export type CategoryUpsertWithoutSkillsInput = {
    update: XOR<CategoryUpdateWithoutSkillsInput, CategoryUncheckedUpdateWithoutSkillsInput>
    create: XOR<CategoryCreateWithoutSkillsInput, CategoryUncheckedCreateWithoutSkillsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSkillsInput, CategoryUncheckedUpdateWithoutSkillsInput>
  }

  export type CategoryUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    toliners?: TolinerUpdateManyWithoutSpecializationNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    projects?: ProjectUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    toliners?: TolinerUncheckedUpdateManyWithoutSpecializationNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutSkillsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutSkillsInput, UserUncheckedUpdateWithoutSkillsInput>
    create: XOR<UserCreateWithoutSkillsInput, UserUncheckedCreateWithoutSkillsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutSkillsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutSkillsInput, UserUncheckedUpdateWithoutSkillsInput>
  }

  export type UserUpdateManyWithWhereWithoutSkillsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutSkillsInput>
  }

  export type PortifolioUpsertWithWhereUniqueWithoutSkillsInput = {
    where: PortifolioWhereUniqueInput
    update: XOR<PortifolioUpdateWithoutSkillsInput, PortifolioUncheckedUpdateWithoutSkillsInput>
    create: XOR<PortifolioCreateWithoutSkillsInput, PortifolioUncheckedCreateWithoutSkillsInput>
  }

  export type PortifolioUpdateWithWhereUniqueWithoutSkillsInput = {
    where: PortifolioWhereUniqueInput
    data: XOR<PortifolioUpdateWithoutSkillsInput, PortifolioUncheckedUpdateWithoutSkillsInput>
  }

  export type PortifolioUpdateManyWithWhereWithoutSkillsInput = {
    where: PortifolioScalarWhereInput
    data: XOR<PortifolioUpdateManyMutationInput, PortifolioUncheckedUpdateManyWithoutSkillsInput>
  }

  export type ProjectUpsertWithWhereUniqueWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
    create: XOR<ProjectCreateWithoutSkillsInput, ProjectUncheckedCreateWithoutSkillsInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutSkillsInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutSkillsInput, ProjectUncheckedUpdateWithoutSkillsInput>
  }

  export type ProjectUpdateManyWithWhereWithoutSkillsInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutSkillsInput>
  }

  export type CertificationTestUpsertWithoutSkillInput = {
    update: XOR<CertificationTestUpdateWithoutSkillInput, CertificationTestUncheckedUpdateWithoutSkillInput>
    create: XOR<CertificationTestCreateWithoutSkillInput, CertificationTestUncheckedCreateWithoutSkillInput>
    where?: CertificationTestWhereInput
  }

  export type CertificationTestUpdateToOneWithWhereWithoutSkillInput = {
    where?: CertificationTestWhereInput
    data: XOR<CertificationTestUpdateWithoutSkillInput, CertificationTestUncheckedUpdateWithoutSkillInput>
  }

  export type CertificationTestUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutCertificationTestNestedInput
    attempts?: TestAttemptUpdateManyWithoutCertificationTestNestedInput
  }

  export type CertificationTestUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutCertificationTestNestedInput
    attempts?: TestAttemptUncheckedUpdateManyWithoutCertificationTestNestedInput
  }

  export type SkillCreateWithoutCertificationTestInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
    category?: CategoryCreateNestedOneWithoutSkillsInput
    users?: UserCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioCreateNestedManyWithoutSkillsInput
    projects?: ProjectCreateNestedManyWithoutSkillsInput
  }

  export type SkillUncheckedCreateWithoutCertificationTestInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    subcategoryId?: string | null
    users?: UserUncheckedCreateNestedManyWithoutSkillsInput
    portifolios?: PortifolioUncheckedCreateNestedManyWithoutSkillsInput
    projects?: ProjectUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type SkillCreateOrConnectWithoutCertificationTestInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutCertificationTestInput, SkillUncheckedCreateWithoutCertificationTestInput>
  }

  export type QuestionCreateWithoutCertificationTestInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeCreateNestedManyWithoutQuestionInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutCertificationTestInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alternatives?: AlternativeUncheckedCreateNestedManyWithoutQuestionInput
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutCertificationTestInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutCertificationTestInput, QuestionUncheckedCreateWithoutCertificationTestInput>
  }

  export type QuestionCreateManyCertificationTestInputEnvelope = {
    data: QuestionCreateManyCertificationTestInput | QuestionCreateManyCertificationTestInput[]
    skipDuplicates?: boolean
  }

  export type TestAttemptCreateWithoutCertificationTestInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTestAttemptInput
    answers?: AnswerCreateNestedManyWithoutTestAttemptInput
  }

  export type TestAttemptUncheckedCreateWithoutCertificationTestInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    answers?: AnswerUncheckedCreateNestedManyWithoutTestAttemptInput
  }

  export type TestAttemptCreateOrConnectWithoutCertificationTestInput = {
    where: TestAttemptWhereUniqueInput
    create: XOR<TestAttemptCreateWithoutCertificationTestInput, TestAttemptUncheckedCreateWithoutCertificationTestInput>
  }

  export type TestAttemptCreateManyCertificationTestInputEnvelope = {
    data: TestAttemptCreateManyCertificationTestInput | TestAttemptCreateManyCertificationTestInput[]
    skipDuplicates?: boolean
  }

  export type SkillUpsertWithoutCertificationTestInput = {
    update: XOR<SkillUpdateWithoutCertificationTestInput, SkillUncheckedUpdateWithoutCertificationTestInput>
    create: XOR<SkillCreateWithoutCertificationTestInput, SkillUncheckedCreateWithoutCertificationTestInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutCertificationTestInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutCertificationTestInput, SkillUncheckedUpdateWithoutCertificationTestInput>
  }

  export type SkillUpdateWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneWithoutSkillsNestedInput
    users?: UserUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUncheckedUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type QuestionUpsertWithWhereUniqueWithoutCertificationTestInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutCertificationTestInput, QuestionUncheckedUpdateWithoutCertificationTestInput>
    create: XOR<QuestionCreateWithoutCertificationTestInput, QuestionUncheckedCreateWithoutCertificationTestInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutCertificationTestInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutCertificationTestInput, QuestionUncheckedUpdateWithoutCertificationTestInput>
  }

  export type QuestionUpdateManyWithWhereWithoutCertificationTestInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutCertificationTestInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    score?: FloatFilter<"Question"> | number
    explanation?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    certificationTestId?: StringFilter<"Question"> | string
  }

  export type TestAttemptUpsertWithWhereUniqueWithoutCertificationTestInput = {
    where: TestAttemptWhereUniqueInput
    update: XOR<TestAttemptUpdateWithoutCertificationTestInput, TestAttemptUncheckedUpdateWithoutCertificationTestInput>
    create: XOR<TestAttemptCreateWithoutCertificationTestInput, TestAttemptUncheckedCreateWithoutCertificationTestInput>
  }

  export type TestAttemptUpdateWithWhereUniqueWithoutCertificationTestInput = {
    where: TestAttemptWhereUniqueInput
    data: XOR<TestAttemptUpdateWithoutCertificationTestInput, TestAttemptUncheckedUpdateWithoutCertificationTestInput>
  }

  export type TestAttemptUpdateManyWithWhereWithoutCertificationTestInput = {
    where: TestAttemptScalarWhereInput
    data: XOR<TestAttemptUpdateManyMutationInput, TestAttemptUncheckedUpdateManyWithoutCertificationTestInput>
  }

  export type CertificationTestCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutCertificationTestInput
    attempts?: TestAttemptCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skillId: string
    attempts?: TestAttemptUncheckedCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestCreateOrConnectWithoutQuestionsInput = {
    where: CertificationTestWhereUniqueInput
    create: XOR<CertificationTestCreateWithoutQuestionsInput, CertificationTestUncheckedCreateWithoutQuestionsInput>
  }

  export type AlternativeCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerCreateNestedManyWithoutAlternativeInput
  }

  export type AlternativeUncheckedCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: AnswerUncheckedCreateNestedManyWithoutAlternativeInput
  }

  export type AlternativeCreateOrConnectWithoutQuestionInput = {
    where: AlternativeWhereUniqueInput
    create: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput>
  }

  export type AlternativeCreateManyQuestionInputEnvelope = {
    data: AlternativeCreateManyQuestionInput | AlternativeCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type AnswerCreateWithoutQuestionInput = {
    id?: string
    createdAt?: Date | string
    testAttempt: TestAttemptCreateNestedOneWithoutAnswersInput
    alternative?: AlternativeCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    createdAt?: Date | string
    testAttemptId: string
    alternativeId?: string | null
  }

  export type AnswerCreateOrConnectWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerCreateManyQuestionInputEnvelope = {
    data: AnswerCreateManyQuestionInput | AnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type CertificationTestUpsertWithoutQuestionsInput = {
    update: XOR<CertificationTestUpdateWithoutQuestionsInput, CertificationTestUncheckedUpdateWithoutQuestionsInput>
    create: XOR<CertificationTestCreateWithoutQuestionsInput, CertificationTestUncheckedCreateWithoutQuestionsInput>
    where?: CertificationTestWhereInput
  }

  export type CertificationTestUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: CertificationTestWhereInput
    data: XOR<CertificationTestUpdateWithoutQuestionsInput, CertificationTestUncheckedUpdateWithoutQuestionsInput>
  }

  export type CertificationTestUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutCertificationTestNestedInput
    attempts?: TestAttemptUpdateManyWithoutCertificationTestNestedInput
  }

  export type CertificationTestUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillId?: StringFieldUpdateOperationsInput | string
    attempts?: TestAttemptUncheckedUpdateManyWithoutCertificationTestNestedInput
  }

  export type AlternativeUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AlternativeWhereUniqueInput
    update: XOR<AlternativeUpdateWithoutQuestionInput, AlternativeUncheckedUpdateWithoutQuestionInput>
    create: XOR<AlternativeCreateWithoutQuestionInput, AlternativeUncheckedCreateWithoutQuestionInput>
  }

  export type AlternativeUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AlternativeWhereUniqueInput
    data: XOR<AlternativeUpdateWithoutQuestionInput, AlternativeUncheckedUpdateWithoutQuestionInput>
  }

  export type AlternativeUpdateManyWithWhereWithoutQuestionInput = {
    where: AlternativeScalarWhereInput
    data: XOR<AlternativeUpdateManyMutationInput, AlternativeUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AlternativeScalarWhereInput = {
    AND?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
    OR?: AlternativeScalarWhereInput[]
    NOT?: AlternativeScalarWhereInput | AlternativeScalarWhereInput[]
    id?: StringFilter<"Alternative"> | string
    text?: StringFilter<"Alternative"> | string
    isCorrect?: BoolFilter<"Alternative"> | boolean
    createdAt?: DateTimeFilter<"Alternative"> | Date | string
    updatedAt?: DateTimeFilter<"Alternative"> | Date | string
    questionId?: StringFilter<"Alternative"> | string
  }

  export type AnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<AnswerCreateWithoutQuestionInput, AnswerUncheckedCreateWithoutQuestionInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutQuestionInput, AnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type AnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type AnswerScalarWhereInput = {
    AND?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    OR?: AnswerScalarWhereInput[]
    NOT?: AnswerScalarWhereInput | AnswerScalarWhereInput[]
    id?: StringFilter<"Answer"> | string
    createdAt?: DateTimeFilter<"Answer"> | Date | string
    testAttemptId?: StringFilter<"Answer"> | string
    questionId?: StringFilter<"Answer"> | string
    alternativeId?: StringNullableFilter<"Answer"> | string | null
  }

  export type QuestionCreateWithoutAlternativesInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTest: CertificationTestCreateNestedOneWithoutQuestionsInput
    answers?: AnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutAlternativesInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    answers?: AnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutAlternativesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
  }

  export type AnswerCreateWithoutAlternativeInput = {
    id?: string
    createdAt?: Date | string
    testAttempt: TestAttemptCreateNestedOneWithoutAnswersInput
    question: QuestionCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutAlternativeInput = {
    id?: string
    createdAt?: Date | string
    testAttemptId: string
    questionId: string
  }

  export type AnswerCreateOrConnectWithoutAlternativeInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutAlternativeInput, AnswerUncheckedCreateWithoutAlternativeInput>
  }

  export type AnswerCreateManyAlternativeInputEnvelope = {
    data: AnswerCreateManyAlternativeInput | AnswerCreateManyAlternativeInput[]
    skipDuplicates?: boolean
  }

  export type QuestionUpsertWithoutAlternativesInput = {
    update: XOR<QuestionUpdateWithoutAlternativesInput, QuestionUncheckedUpdateWithoutAlternativesInput>
    create: XOR<QuestionCreateWithoutAlternativesInput, QuestionUncheckedCreateWithoutAlternativesInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAlternativesInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAlternativesInput, QuestionUncheckedUpdateWithoutAlternativesInput>
  }

  export type QuestionUpdateWithoutAlternativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTest?: CertificationTestUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAlternativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type AnswerUpsertWithWhereUniqueWithoutAlternativeInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutAlternativeInput, AnswerUncheckedUpdateWithoutAlternativeInput>
    create: XOR<AnswerCreateWithoutAlternativeInput, AnswerUncheckedCreateWithoutAlternativeInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutAlternativeInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutAlternativeInput, AnswerUncheckedUpdateWithoutAlternativeInput>
  }

  export type AnswerUpdateManyWithWhereWithoutAlternativeInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutAlternativeInput>
  }

  export type CertificationTestCreateWithoutAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutCertificationTestInput
    questions?: QuestionCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestUncheckedCreateWithoutAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    skillId: string
    questions?: QuestionUncheckedCreateNestedManyWithoutCertificationTestInput
  }

  export type CertificationTestCreateOrConnectWithoutAttemptsInput = {
    where: CertificationTestWhereUniqueInput
    create: XOR<CertificationTestCreateWithoutAttemptsInput, CertificationTestUncheckedCreateWithoutAttemptsInput>
  }

  export type UserCreateWithoutTestAttemptInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    conversations?: ConversationCreateNestedManyWithoutMembersInput
    toliner: TolinerCreateNestedOneWithoutUserInput
    skills?: SkillCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTestAttemptInput = {
    id?: string
    email: string
    password?: string | null
    username: string
    type: string
    createdAt?: Date | string
    tag: string
    clientBio?: string | null
    freelancerBio?: string | null
    avatarUrl?: string | null
    tolinerId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutMembersInput
    skills?: SkillUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTestAttemptInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTestAttemptInput, UserUncheckedCreateWithoutTestAttemptInput>
  }

  export type AnswerCreateWithoutTestAttemptInput = {
    id?: string
    createdAt?: Date | string
    question: QuestionCreateNestedOneWithoutAnswersInput
    alternative?: AlternativeCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutTestAttemptInput = {
    id?: string
    createdAt?: Date | string
    questionId: string
    alternativeId?: string | null
  }

  export type AnswerCreateOrConnectWithoutTestAttemptInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutTestAttemptInput, AnswerUncheckedCreateWithoutTestAttemptInput>
  }

  export type AnswerCreateManyTestAttemptInputEnvelope = {
    data: AnswerCreateManyTestAttemptInput | AnswerCreateManyTestAttemptInput[]
    skipDuplicates?: boolean
  }

  export type CertificationTestUpsertWithoutAttemptsInput = {
    update: XOR<CertificationTestUpdateWithoutAttemptsInput, CertificationTestUncheckedUpdateWithoutAttemptsInput>
    create: XOR<CertificationTestCreateWithoutAttemptsInput, CertificationTestUncheckedCreateWithoutAttemptsInput>
    where?: CertificationTestWhereInput
  }

  export type CertificationTestUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: CertificationTestWhereInput
    data: XOR<CertificationTestUpdateWithoutAttemptsInput, CertificationTestUncheckedUpdateWithoutAttemptsInput>
  }

  export type CertificationTestUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutCertificationTestNestedInput
    questions?: QuestionUpdateManyWithoutCertificationTestNestedInput
  }

  export type CertificationTestUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skillId?: StringFieldUpdateOperationsInput | string
    questions?: QuestionUncheckedUpdateManyWithoutCertificationTestNestedInput
  }

  export type UserUpsertWithoutTestAttemptInput = {
    update: XOR<UserUpdateWithoutTestAttemptInput, UserUncheckedUpdateWithoutTestAttemptInput>
    create: XOR<UserCreateWithoutTestAttemptInput, UserUncheckedCreateWithoutTestAttemptInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTestAttemptInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTestAttemptInput, UserUncheckedUpdateWithoutTestAttemptInput>
  }

  export type UserUpdateWithoutTestAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUpdateManyWithoutMembersNestedInput
    toliner?: TolinerUpdateOneRequiredWithoutUserNestedInput
    skills?: SkillUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTestAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutMembersNestedInput
    skills?: SkillUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AnswerUpsertWithWhereUniqueWithoutTestAttemptInput = {
    where: AnswerWhereUniqueInput
    update: XOR<AnswerUpdateWithoutTestAttemptInput, AnswerUncheckedUpdateWithoutTestAttemptInput>
    create: XOR<AnswerCreateWithoutTestAttemptInput, AnswerUncheckedCreateWithoutTestAttemptInput>
  }

  export type AnswerUpdateWithWhereUniqueWithoutTestAttemptInput = {
    where: AnswerWhereUniqueInput
    data: XOR<AnswerUpdateWithoutTestAttemptInput, AnswerUncheckedUpdateWithoutTestAttemptInput>
  }

  export type AnswerUpdateManyWithWhereWithoutTestAttemptInput = {
    where: AnswerScalarWhereInput
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyWithoutTestAttemptInput>
  }

  export type TestAttemptCreateWithoutAnswersInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTest: CertificationTestCreateNestedOneWithoutAttemptsInput
    user: UserCreateNestedOneWithoutTestAttemptInput
  }

  export type TestAttemptUncheckedCreateWithoutAnswersInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    userId: string
  }

  export type TestAttemptCreateOrConnectWithoutAnswersInput = {
    where: TestAttemptWhereUniqueInput
    create: XOR<TestAttemptCreateWithoutAnswersInput, TestAttemptUncheckedCreateWithoutAnswersInput>
  }

  export type QuestionCreateWithoutAnswersInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTest: CertificationTestCreateNestedOneWithoutQuestionsInput
    alternatives?: AlternativeCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
    alternatives?: AlternativeUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
  }

  export type AlternativeCreateWithoutAnswersInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutAlternativesInput
  }

  export type AlternativeUncheckedCreateWithoutAnswersInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questionId: string
  }

  export type AlternativeCreateOrConnectWithoutAnswersInput = {
    where: AlternativeWhereUniqueInput
    create: XOR<AlternativeCreateWithoutAnswersInput, AlternativeUncheckedCreateWithoutAnswersInput>
  }

  export type TestAttemptUpsertWithoutAnswersInput = {
    update: XOR<TestAttemptUpdateWithoutAnswersInput, TestAttemptUncheckedUpdateWithoutAnswersInput>
    create: XOR<TestAttemptCreateWithoutAnswersInput, TestAttemptUncheckedCreateWithoutAnswersInput>
    where?: TestAttemptWhereInput
  }

  export type TestAttemptUpdateToOneWithWhereWithoutAnswersInput = {
    where?: TestAttemptWhereInput
    data: XOR<TestAttemptUpdateWithoutAnswersInput, TestAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type TestAttemptUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTest?: CertificationTestUpdateOneRequiredWithoutAttemptsNestedInput
    user?: UserUpdateOneRequiredWithoutTestAttemptNestedInput
  }

  export type TestAttemptUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionCreateWithoutAnswersInput, QuestionUncheckedCreateWithoutAnswersInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutAnswersInput, QuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTest?: CertificationTestUpdateOneRequiredWithoutQuestionsNestedInput
    alternatives?: AlternativeUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    alternatives?: AlternativeUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type AlternativeUpsertWithoutAnswersInput = {
    update: XOR<AlternativeUpdateWithoutAnswersInput, AlternativeUncheckedUpdateWithoutAnswersInput>
    create: XOR<AlternativeCreateWithoutAnswersInput, AlternativeUncheckedCreateWithoutAnswersInput>
    where?: AlternativeWhereInput
  }

  export type AlternativeUpdateToOneWithWhereWithoutAnswersInput = {
    where?: AlternativeWhereInput
    data: XOR<AlternativeUpdateWithoutAnswersInput, AlternativeUncheckedUpdateWithoutAnswersInput>
  }

  export type AlternativeUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAlternativesNestedInput
  }

  export type AlternativeUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectCreateManyOwnerInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
  }

  export type ProjectCreateManyFreelancerInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    status?: $Enums.ProjectStatus
    categoryId?: string | null
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
  }

  export type ProjectSubscriptionCreateManyTolinerInput = {
    id?: string
    projectId: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PortifolioCreateManyTolinerInput = {
    id?: string
    title: string
    description: string
    cover: string
    completedAt?: string | null
    assets: JsonNullValueInput | InputJsonValue
  }

  export type FreelancerEvaluationCreateManyTolinerInput = {
    id?: string
    rate: string
    evaluatorId: string
    comment: string
  }

  export type ChargeCreateManyTolinerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    isVerified?: boolean
    invoice: string
    updatedAt?: Date | string
    referenceNumber?: string | null
    status?: $Enums.ChargeStatus
  }

  export type PaymentCreateManyTolinerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    projectId: string
    completedAt?: Date | string | null
    status?: $Enums.PaymentStatus
    freelancerId: string
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type PaymentCreateManyFreelancerInput = {
    id?: string
    ammount: number
    createdAt?: Date | string
    clientInvoice?: string | null
    systemInvoice?: string | null
    isVerified?: boolean
    projectId: string
    completedAt?: Date | string | null
    tolinerId: string
    status?: $Enums.PaymentStatus
    paymentMethod?: string | null
    referenceNumber?: string | null
  }

  export type ProjectUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProjectSubscriptionUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ProjectSubscriptionUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionUncheckedUpdateManyWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CategoryUpdateWithoutTolinersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
    projects?: ProjectUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutTolinersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    skills?: SkillUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutTolinersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type PortifolioUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    skills?: SkillUpdateManyWithoutPortifoliosNestedInput
  }

  export type PortifolioUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    skills?: SkillUncheckedUpdateManyWithoutPortifoliosNestedInput
  }

  export type PortifolioUncheckedUpdateManyWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
  }

  export type FreelancerEvaluationUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type FreelancerEvaluationUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type FreelancerEvaluationUncheckedUpdateManyWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    rate?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type ChargeUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
  }

  export type ChargeUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
  }

  export type ChargeUncheckedUpdateManyWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    invoice?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumChargeStatusFieldUpdateOperationsInput | $Enums.ChargeStatus
  }

  export type PaymentUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutPaymentNestedInput
    freelancer?: TolinerUpdateOneRequiredWithoutFreelancerPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    freelancerId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutTolinerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    freelancerId?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneRequiredWithoutPaymentNestedInput
    toliner?: TolinerUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutFreelancerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ammount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    systemInvoice?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    projectId?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestAttemptCreateManyUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    certificationTestId: string
  }

  export type ConversationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    project?: ProjectUpdateOneWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SkillUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneWithoutSkillsNestedInput
    portifolios?: PortifolioUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    portifolios?: PortifolioUncheckedUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUncheckedUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTest?: CertificationTestUpdateOneRequiredWithoutAttemptsNestedInput
    answers?: AnswerUpdateManyWithoutTestAttemptNestedInput
  }

  export type TestAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
    answers?: AnswerUncheckedUpdateManyWithoutTestAttemptNestedInput
  }

  export type TestAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificationTestId?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectSubscriptionCreateManyProjectInput = {
    id?: string
    tolinerId: string
    estimatedTime?: string | null
    requiredInformations?: string | null
    similarExperiences?: string | null
    proposal: string
    quotation?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ConversationCreateManyProjectInput = {
    id?: string
  }

  export type ProjectSubscriptionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
    toliner?: TolinerUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type ProjectSubscriptionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tolinerId?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectSubscriptionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    tolinerId?: StringFieldUpdateOperationsInput | string
    estimatedTime?: NullableStringFieldUpdateOperationsInput | string | null
    requiredInformations?: NullableStringFieldUpdateOperationsInput | string | null
    similarExperiences?: NullableStringFieldUpdateOperationsInput | string | null
    proposal?: StringFieldUpdateOperationsInput | string
    quotation?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SkillUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneWithoutSkillsNestedInput
    users?: UserUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUncheckedUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUncheckedUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: UserUpdateManyWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    members?: UserUncheckedUpdateManyWithoutConversationsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type SkillCreateManyCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subcategoryId?: string | null
  }

  export type SubcategoryCreateManyCategoryInput = {
    id?: string
    name: string
    description?: string | null
    slug: string
  }

  export type ProjectCreateManyCategoryInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ownerId: string
    freelancerId?: string | null
    status?: $Enums.ProjectStatus
    subcategoryId?: string | null
    dueDate?: Date | string | null
    concludedAt?: Date | string | null
    isAproved?: boolean
    isActive?: boolean
  }

  export type SkillUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutSkillsNestedInput
    portifolios?: PortifolioUncheckedUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUncheckedUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TolinerUpdateWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutTolinerNestedInput
    portifolio?: PortifolioUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUpdateManyWithoutTolinerNestedInput
    user?: UserUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
    projectsOwned?: ProjectUncheckedUpdateManyWithoutOwnerNestedInput
    projectsFreelanced?: ProjectUncheckedUpdateManyWithoutFreelancerNestedInput
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutTolinerNestedInput
    portifolio?: PortifolioUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerEvaluation?: FreelancerEvaluationUncheckedUpdateManyWithoutTolinerNestedInput
    user?: UserUncheckedUpdateOneWithoutTolinerNestedInput
    charges?: ChargeUncheckedUpdateManyWithoutTolinerNestedInput
    balance?: BalanceUncheckedUpdateOneWithoutTolinerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTolinerNestedInput
    freelancerPayments?: PaymentUncheckedUpdateManyWithoutFreelancerNestedInput
  }

  export type TolinerUncheckedUpdateManyWithoutSpecializationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bankAccount?: NullableJsonNullValueInput | InputJsonValue
    identification?: NullableJsonNullValueInput | InputJsonValue
    isSuspended?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    hasCompletedProfile?: BoolFieldUpdateOperationsInput | boolean
    hasAprovedProfile?: BoolFieldUpdateOperationsInput | boolean
    gainPerOurs?: NullableFloatFieldUpdateOperationsInput | number | null
    nacionality?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubcategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ProjectUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    skills?: SkillUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    skills?: SkillUncheckedUpdateManyWithoutProjectsNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    saw?: boolean
    hasFile?: boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    toliner?: TolinerUpdateOneRequiredWithoutUserNestedInput
    skills?: SkillUpdateManyWithoutUsersNestedInput
    TestAttempt?: TestAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    skills?: SkillUncheckedUpdateManyWithoutUsersNestedInput
    TestAttempt?: TestAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saw?: BoolFieldUpdateOperationsInput | boolean
    hasFile?: BoolFieldUpdateOperationsInput | boolean
    fileInfo?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SkillUpdateWithoutPortifoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneWithoutSkillsNestedInput
    users?: UserUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutPortifoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutSkillsNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutSkillsNestedInput
    certificationTest?: CertificationTestUncheckedUpdateOneWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutPortifoliosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    conversations?: ConversationUpdateManyWithoutMembersNestedInput
    toliner?: TolinerUpdateOneRequiredWithoutUserNestedInput
    TestAttempt?: TestAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutMembersNestedInput
    TestAttempt?: TestAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: StringFieldUpdateOperationsInput | string
    clientBio?: NullableStringFieldUpdateOperationsInput | string | null
    freelancerBio?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tolinerId?: StringFieldUpdateOperationsInput | string
  }

  export type PortifolioUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    toliner?: TolinerUpdateOneWithoutPortifolioNestedInput
  }

  export type PortifolioUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    tolinerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortifolioUncheckedUpdateManyWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    cover?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: JsonNullValueInput | InputJsonValue
    tolinerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    owner?: TolinerUpdateOneRequiredWithoutProjectsOwnedNestedInput
    freelancer?: TolinerUpdateOneWithoutProjectsFreelancedNestedInput
    subscriptions?: ProjectSubscriptionUpdateManyWithoutProjectNestedInput
    category?: CategoryUpdateOneWithoutProjectsNestedInput
    quotation?: QuotationUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUpdateManyWithoutProjectNestedInput
    payment?: PaymentUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscriptions?: ProjectSubscriptionUncheckedUpdateManyWithoutProjectNestedInput
    quotation?: QuotationUncheckedUpdateOneWithoutProjectNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutProjectNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    freelancerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subcategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAproved?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuestionCreateManyCertificationTestInput = {
    id?: string
    text: string
    score?: number
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestAttemptCreateManyCertificationTestInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    score?: number | null
    passed?: boolean | null
    completionTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type QuestionUpdateWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeUpdateManyWithoutQuestionNestedInput
    answers?: AnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alternatives?: AlternativeUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: AnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestAttemptUpdateWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTestAttemptNestedInput
    answers?: AnswerUpdateManyWithoutTestAttemptNestedInput
  }

  export type TestAttemptUncheckedUpdateWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: AnswerUncheckedUpdateManyWithoutTestAttemptNestedInput
  }

  export type TestAttemptUncheckedUpdateManyWithoutCertificationTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completionTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AlternativeCreateManyQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnswerCreateManyQuestionInput = {
    id?: string
    createdAt?: Date | string
    testAttemptId: string
    alternativeId?: string | null
  }

  export type AlternativeUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUpdateManyWithoutAlternativeNestedInput
  }

  export type AlternativeUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: AnswerUncheckedUpdateManyWithoutAlternativeNestedInput
  }

  export type AlternativeUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttempt?: TestAttemptUpdateOneRequiredWithoutAnswersNestedInput
    alternative?: AlternativeUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttemptId?: StringFieldUpdateOperationsInput | string
    alternativeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttemptId?: StringFieldUpdateOperationsInput | string
    alternativeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerCreateManyAlternativeInput = {
    id?: string
    createdAt?: Date | string
    testAttemptId: string
    questionId: string
  }

  export type AnswerUpdateWithoutAlternativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttempt?: TestAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutAlternativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type AnswerUncheckedUpdateManyWithoutAlternativeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testAttemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
  }

  export type AnswerCreateManyTestAttemptInput = {
    id?: string
    createdAt?: Date | string
    questionId: string
    alternativeId?: string | null
  }

  export type AnswerUpdateWithoutTestAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutAnswersNestedInput
    alternative?: AlternativeUpdateOneWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutTestAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerUncheckedUpdateManyWithoutTestAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionId?: StringFieldUpdateOperationsInput | string
    alternativeId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}